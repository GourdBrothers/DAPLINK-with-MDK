; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\settings.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\settings.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\settings.crf ..\..\..\source\daplink\settings\settings.c]
                          THUMB

                          AREA ||i.config_init||, CODE, READONLY, ALIGN=2

                  config_init PROC
;;;67     
;;;68     void config_init()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;69     {
;;;70         uint32_t new_size;
;;;71         // Initialize RAM copy
;;;72         memset(&config_ram_copy, 0, sizeof(config_ram_copy));
000004  218d              MOVS     r1,#0x8d
000006  4827              LDR      r0,|L1.164|
000008  f7fffffe          BL       __aeabi_memclr
;;;73         // Read settings from RAM if the key is valid
;;;74         new_size = sizeof(config_ram);
00000c  258d              MOVS     r5,#0x8d
;;;75     
;;;76         if (CFG_KEY == config_ram.key) {
00000e  4826              LDR      r0,|L1.168|
000010  f7fffffe          BL       __aeabi_uread4
000014  4f25              LDR      r7,|L1.172|
000016  4c24              LDR      r4,|L1.168|
000018  4e22              LDR      r6,|L1.164|
00001a  42b8              CMP      r0,r7
00001c  d113              BNE      |L1.70|
;;;77             uint32_t size = MIN(config_ram.size, sizeof(config_ram));
00001e  7960              LDRB     r0,[r4,#5]  ; config_ram
000020  7921              LDRB     r1,[r4,#4]  ; config_ram
000022  ea412500          ORR      r5,r1,r0,LSL #8
000026  2d8d              CMP      r5,#0x8d
000028  d201              BCS      |L1.46|
00002a  462a              MOV      r2,r5
00002c  e001              B        |L1.50|
                  |L1.46|
00002e  f04f028d          MOV      r2,#0x8d
                  |L1.50|
;;;78             new_size = MAX(config_ram.size, sizeof(config_ram));
000032  d801              BHI      |L1.56|
000034  f04f058d          MOV      r5,#0x8d
                  |L1.56|
;;;79             memcpy(&config_ram_copy, (void *)&config_ram, size);
000038  491b              LDR      r1,|L1.168|
00003a  481a              LDR      r0,|L1.164|
00003c  f7fffffe          BL       __aeabi_memcpy
;;;80             config_ram_copy.assert_file_name[sizeof(config_ram_copy.assert_file_name) - 1] = 0;
000040  2000              MOVS     r0,#0
000042  f8860047          STRB     r0,[r6,#0x47]
                  |L1.70|
;;;81         }
;;;82     
;;;83         // Initialize RAM
;;;84         memset((void *)&config_ram, 0, sizeof(config_ram));
000046  218d              MOVS     r1,#0x8d
000048  4817              LDR      r0,|L1.168|
00004a  f7fffffe          BL       __aeabi_memclr
;;;85         config_ram.key = CFG_KEY;
00004e  4916              LDR      r1,|L1.168|
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       __aeabi_uwrite4
;;;86         config_ram.size = new_size;
000056  7125              STRB     r5,[r4,#4]
000058  0a28              LSRS     r0,r5,#8
00005a  7160              STRB     r0,[r4,#5]
;;;87         // Copy assert info back over (must be explicitly cleared)
;;;88         memcpy(config_ram.assert_file_name,
00005c  2241              MOVS     r2,#0x41
00005e  4635              MOV      r5,r6
000060  1df1              ADDS     r1,r6,#7
000062  1de0              ADDS     r0,r4,#7
000064  f7fffffe          BL       __aeabi_memcpy
;;;89                config_ram_copy.assert_file_name,
;;;90                sizeof(config_ram_copy.assert_file_name));
;;;91         config_ram.assert_line =  config_ram_copy.assert_line;
000068  f8950049          LDRB     r0,[r5,#0x49]  ; config_ram_copy
00006c  f8151f48          LDRB     r1,[r5,#0x48]!  ; config_ram_copy
000070  ea412000          ORR      r0,r1,r0,LSL #8
000074  f8040f48          STRB     r0,[r4,#0x48]!
000078  0a00              LSRS     r0,r0,#8
00007a  7060              STRB     r0,[r4,#1]
;;;92         config_ram.assert_source =  config_ram_copy.assert_source;
00007c  78a8              LDRB     r0,[r5,#2]  ; config_ram_copy
00007e  70a0              STRB     r0,[r4,#2]
;;;93         config_ram.valid_dumps = config_ram_copy.valid_dumps;
000080  78e8              LDRB     r0,[r5,#3]  ; config_ram_copy
000082  70e0              STRB     r0,[r4,#3]
;;;94         memcpy(config_ram.hexdump, config_ram_copy.hexdump, sizeof(config_ram_copy.hexdump[0]) * config_ram_copy.valid_dumps);
000084  0082              LSLS     r2,r0,#2
000086  4907              LDR      r1,|L1.164|
000088  4807              LDR      r0,|L1.168|
00008a  314c              ADDS     r1,r1,#0x4c
00008c  304c              ADDS     r0,r0,#0x4c
00008e  f7fffffe          BL       __aeabi_memcpy
;;;95         config_ram.disable_msd = config_ram_copy.disable_msd;
000092  f8950044          LDRB     r0,[r5,#0x44]  ; config_ram_copy
000096  f8840044          STRB     r0,[r4,#0x44]
;;;96         config_rom_init();
00009a  e8bd41f0          POP      {r4-r8,lr}
00009e  f7ffbffe          B.W      config_rom_init
;;;97     }
;;;98     
                          ENDP

0000a2  0000              DCW      0x0000
                  |L1.164|
                          DCD      ||.bss||
                  |L1.168|
                          DCD      cfgram
                  |L1.172|
                          DCD      0x6b766c64

                          AREA ||i.config_ram_add_hexdump||, CODE, READONLY, ALIGN=2

                  config_ram_add_hexdump PROC
;;;200    
;;;201    uint8_t config_ram_add_hexdump(uint32_t hexdump)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203        if (config_ram.valid_dumps >= ALLOWED_HEXDUMP) {
000002  4c09              LDR      r4,|L2.40|
000004  f894104b          LDRB     r1,[r4,#0x4b]  ; config_ram
000008  2910              CMP      r1,#0x10
00000a  d301              BCC      |L2.16|
;;;204            return 0;
00000c  2000              MOVS     r0,#0
;;;205        }
;;;206    
;;;207        //alignment is maintained here
;;;208        config_ram.hexdump[config_ram.valid_dumps++] = hexdump;
;;;209        return config_ram.valid_dumps;
;;;210    }
00000e  bd10              POP      {r4,pc}
                  |L2.16|
000010  eb040181          ADD      r1,r4,r1,LSL #2       ;208
000014  314c              ADDS     r1,r1,#0x4c           ;208
000016  f7fffffe          BL       __aeabi_uwrite4
00001a  f8140f4b          LDRB     r0,[r4,#0x4b]!        ;208  ; config_ram
00001e  1c40              ADDS     r0,r0,#1              ;208
000020  b2c0              UXTB     r0,r0                 ;208
000022  7020              STRB     r0,[r4,#0]            ;208
000024  bd10              POP      {r4,pc}
;;;211    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      cfgram

                          AREA ||i.config_ram_clear_assert||, CODE, READONLY, ALIGN=2

                  config_ram_clear_assert PROC
;;;134    
;;;135    void config_ram_clear_assert()
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137        memset(config_ram.assert_file_name, 0, sizeof(config_ram.assert_file_name));
000002  4c05              LDR      r4,|L3.24|
000004  2141              MOVS     r1,#0x41
000006  1de0              ADDS     r0,r4,#7
000008  f7fffffe          BL       __aeabi_memclr
;;;138        config_ram.assert_line = 0;
00000c  2100              MOVS     r1,#0
00000e  f8041f48          STRB     r1,[r4,#0x48]!
000012  7061              STRB     r1,[r4,#1]
;;;139        config_ram.valid_dumps = 0;
000014  70e1              STRB     r1,[r4,#3]
;;;140    }
000016  bd10              POP      {r4,pc}
;;;141    
                          ENDP

                  |L3.24|
                          DCD      cfgram

                          AREA ||i.config_ram_get_assert||, CODE, READONLY, ALIGN=2

                  config_ram_get_assert PROC
;;;151    
;;;152    bool config_ram_get_assert(char *buf, uint16_t buf_size, uint16_t *line, assert_source_t *source)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;153    {
;;;154        // Initialize
;;;155        const char *start;
;;;156        uint32_t copy_size;
;;;157        uint32_t assert_size = strlen(config_ram.assert_file_name) + 1;
000004  4f1a              LDR      r7,|L4.112|
000006  4681              MOV      r9,r0                 ;153
000008  461d              MOV      r5,r3                 ;153
00000a  4616              MOV      r6,r2                 ;153
00000c  4688              MOV      r8,r1                 ;153
00000e  1df8              ADDS     r0,r7,#7
000010  f7fffffe          BL       strlen
000014  1c44              ADDS     r4,r0,#1
;;;158    
;;;159        if (0 != buf) {
000016  f1b90000          SUBS     r0,r9,#0
00001a  d002              BEQ      |L4.34|
;;;160            memset(buf, 0, buf_size);
00001c  4641              MOV      r1,r8
00001e  f7fffffe          BL       __aeabi_memclr
                  |L4.34|
000022  2000              MOVS     r0,#0
;;;161        }
;;;162    
;;;163        if (0 != line) {
000024  b106              CBZ      r6,|L4.40|
;;;164            *line = 0;
000026  8030              STRH     r0,[r6,#0]
                  |L4.40|
;;;165        }
;;;166    
;;;167        if (0 != source) {
000028  b105              CBZ      r5,|L4.44|
;;;168            *source = ASSERT_SOURCE_NONE;
00002a  7028              STRB     r0,[r5,#0]
                  |L4.44|
;;;169        }
;;;170    
;;;171        // If the string is empty then there is no assert
;;;172        if (0 == config_ram.assert_file_name[0]) {
00002c  79f8              LDRB     r0,[r7,#7]  ; config_ram
00002e  2800              CMP      r0,#0
000030  d01c              BEQ      |L4.108|
;;;173            return false;
;;;174        }
;;;175    
;;;176        // Determine size to copy
;;;177        if (assert_size <= buf_size) {
000032  4544              CMP      r4,r8
000034  d802              BHI      |L4.60|
;;;178            start = config_ram.assert_file_name;
000036  1df9              ADDS     r1,r7,#7
;;;179            copy_size = assert_size;
000038  4622              MOV      r2,r4
00003a  e004              B        |L4.70|
                  |L4.60|
;;;180        } else {
;;;181            start = &config_ram.assert_file_name[assert_size - buf_size];
00003c  eba40008          SUB      r0,r4,r8
000040  19c1              ADDS     r1,r0,r7
;;;182            copy_size = buf_size;
000042  4642              MOV      r2,r8
000044  1dc9              ADDS     r1,r1,#7
                  |L4.70|
;;;183        }
;;;184    
;;;185        // Copy data over
;;;186        if (0 != buf) {
000046  f1b90f00          CMP      r9,#0
00004a  d006              BEQ      |L4.90|
;;;187            *line = config_ram.assert_line;
00004c  f8970049          LDRB     r0,[r7,#0x49]  ; config_ram
000050  f8973048          LDRB     r3,[r7,#0x48]  ; config_ram
000054  ea432000          ORR      r0,r3,r0,LSL #8
000058  8030              STRH     r0,[r6,#0]
                  |L4.90|
;;;188        }
;;;189    
;;;190        if (0 != line) {
00005a  b116              CBZ      r6,|L4.98|
;;;191            memcpy(buf, start, copy_size);
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       __aeabi_memcpy
                  |L4.98|
;;;192        }
;;;193    
;;;194        if (0 != source) {
000062  b115              CBZ      r5,|L4.106|
;;;195            *source = (assert_source_t)config_ram.assert_source;
000064  f897004a          LDRB     r0,[r7,#0x4a]  ; config_ram
000068  7028              STRB     r0,[r5,#0]
                  |L4.106|
;;;196        }
;;;197    
;;;198        return true;
00006a  2001              MOVS     r0,#1
                  |L4.108|
;;;199    }
00006c  e8bd87f0          POP      {r4-r10,pc}
;;;200    
                          ENDP

                  |L4.112|
                          DCD      cfgram

                          AREA ||i.config_ram_get_disable_msd||, CODE, READONLY, ALIGN=2

                  config_ram_get_disable_msd PROC
;;;227    
;;;228    uint8_t config_ram_get_disable_msd(void)
000000  4801              LDR      r0,|L5.8|
;;;229    {
;;;230        return config_ram.disable_msd;
000002  f890008c          LDRB     r0,[r0,#0x8c]  ; config_ram
;;;231    }
000006  4770              BX       lr
;;;232    
                          ENDP

                  |L5.8|
                          DCD      cfgram

                          AREA ||i.config_ram_get_hexdumps||, CODE, READONLY, ALIGN=2

                  config_ram_get_hexdumps PROC
;;;211    
;;;212    uint8_t config_ram_get_hexdumps(uint32_t **hexdumps)
000000  4905              LDR      r1,|L6.24|
;;;213    {
;;;214        if (config_ram.valid_dumps == 0) {
000002  f891204b          LDRB     r2,[r1,#0x4b]  ; config_ram
000006  b12a              CBZ      r2,|L6.20|
;;;215            return 0;
;;;216        }
;;;217        
;;;218        //prevent memcopy check alignment
;;;219        *hexdumps = config_ram.hexdump;
000008  f101024c          ADD      r2,r1,#0x4c
;;;220        return config_ram.valid_dumps;
00000c  6002              STR      r2,[r0,#0]
00000e  f891004b          LDRB     r0,[r1,#0x4b]  ; config_ram
;;;221    }
000012  4770              BX       lr
                  |L6.20|
000014  2000              MOVS     r0,#0                 ;215
000016  4770              BX       lr
;;;222    
                          ENDP

                  |L6.24|
                          DCD      cfgram

                          AREA ||i.config_ram_get_hold_in_bl||, CODE, READONLY, ALIGN=2

                  config_ram_get_hold_in_bl PROC
;;;141    
;;;142    bool config_ram_get_hold_in_bl()
000000  4802              LDR      r0,|L7.12|
;;;143    {
;;;144        return config_ram.hold_in_bl;
000002  7980              LDRB     r0,[r0,#6]  ; config_ram
000004  2800              CMP      r0,#0                 ;143
000006  d000              BEQ      |L7.10|
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;145    }
00000a  4770              BX       lr
;;;146    
                          ENDP

                  |L7.12|
                          DCD      cfgram

                          AREA ||i.config_ram_get_initial_hold_in_bl||, CODE, READONLY, ALIGN=2

                  config_ram_get_initial_hold_in_bl PROC
;;;146    
;;;147    bool config_ram_get_initial_hold_in_bl()
000000  4802              LDR      r0,|L8.12|
;;;148    {
;;;149        return config_ram_copy.hold_in_bl;
000002  7980              LDRB     r0,[r0,#6]  ; config_ram_copy
000004  2800              CMP      r0,#0                 ;148
000006  d000              BEQ      |L8.10|
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;150    }
00000a  4770              BX       lr
;;;151    
                          ENDP

                  |L8.12|
                          DCD      ||.bss||

                          AREA ||i.config_ram_set_assert||, CODE, READONLY, ALIGN=2

                  config_ram_set_assert PROC
;;;103    
;;;104    void config_ram_set_assert(const char *file, uint16_t line)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;105    {
000004  4688              MOV      r8,r1
000006  4607              MOV      r7,r0
;;;106        // Initialize
;;;107        uint32_t file_name_size = strlen(file) + 1;
000008  f7fffffe          BL       strlen
;;;108        const char *start;
;;;109        uint32_t assert_buf_size = sizeof(config_ram.assert_file_name);
;;;110        uint32_t copy_size;
;;;111        memset(config_ram.assert_file_name, 0, sizeof(config_ram.assert_file_name));
00000c  4d12              LDR      r5,|L9.88|
00000e  1c44              ADDS     r4,r0,#1              ;107
000010  2641              MOVS     r6,#0x41              ;109
000012  4631              MOV      r1,r6
000014  1de8              ADDS     r0,r5,#7
000016  f7fffffe          BL       __aeabi_memclr
;;;112    
;;;113        // Determine size to copy
;;;114        if (file_name_size <= assert_buf_size) {
00001a  2c41              CMP      r4,#0x41
00001c  d802              BHI      |L9.36|
;;;115            start = file;
00001e  4639              MOV      r1,r7
;;;116            copy_size = file_name_size;
000020  4622              MOV      r2,r4
000022  e002              B        |L9.42|
                  |L9.36|
000024  3c41              SUBS     r4,r4,#0x41
;;;117        } else {
;;;118            start = &file[file_name_size - assert_buf_size];
000026  19e1              ADDS     r1,r4,r7
;;;119            copy_size = assert_buf_size;
000028  4632              MOV      r2,r6
                  |L9.42|
;;;120        }
;;;121    
;;;122        // Write to ram
;;;123        memcpy(config_ram.assert_file_name, start, copy_size);
00002a  462c              MOV      r4,r5
00002c  1de8              ADDS     r0,r5,#7
00002e  f7fffffe          BL       __aeabi_memcpy
;;;124        config_ram.assert_line = line;
000032  f8848048          STRB     r8,[r4,#0x48]
000036  ea4f2018          LSR      r0,r8,#8
00003a  f8840049          STRB     r0,[r4,#0x49]
;;;125    
;;;126        if (daplink_is_bootloader()) {
00003e  f7fffffe          BL       daplink_is_bootloader
000042  b108              CBZ      r0,|L9.72|
;;;127            config_ram.assert_source = ASSERT_SOURCE_BL;
000044  2001              MOVS     r0,#1
000046  e003              B        |L9.80|
                  |L9.72|
;;;128        } else if (daplink_is_interface()) {
000048  f7fffffe          BL       daplink_is_interface
00004c  b100              CBZ      r0,|L9.80|
;;;129            config_ram.assert_source = ASSERT_SOURCE_APP;
00004e  2002              MOVS     r0,#2
                  |L9.80|
000050  f884004a          STRB     r0,[r4,#0x4a]         ;127
;;;130        } else {
;;;131            config_ram.assert_source = ASSERT_SOURCE_NONE;
;;;132        }
;;;133    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;134    
                          ENDP

                  |L9.88|
                          DCD      cfgram

                          AREA ||i.config_ram_set_disable_msd||, CODE, READONLY, ALIGN=2

                  config_ram_set_disable_msd PROC
;;;222    
;;;223    void config_ram_set_disable_msd(bool disable_msd)
000000  4901              LDR      r1,|L10.8|
;;;224    {
;;;225        config_ram.disable_msd = disable_msd;
000002  f881008c          STRB     r0,[r1,#0x8c]
;;;226    }
000006  4770              BX       lr
;;;227    
                          ENDP

                  |L10.8|
                          DCD      cfgram

                          AREA ||i.config_ram_set_hold_in_bl||, CODE, READONLY, ALIGN=2

                  config_ram_set_hold_in_bl PROC
;;;98     
;;;99     void config_ram_set_hold_in_bl(bool hold)
000000  4901              LDR      r1,|L11.8|
;;;100    {
;;;101        config_ram.hold_in_bl = hold;
000002  7188              STRB     r0,[r1,#6]
;;;102    }
000004  4770              BX       lr
;;;103    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      cfgram

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  config_ram_copy
                          %        141

                          AREA cfgram, DATA, NOINIT, ALIGN=0

                  config_ram
                          %        141

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\settings\\settings.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_settings_c_56d4b884____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___10_settings_c_56d4b884____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_settings_c_56d4b884____REVSH|
#line 144
|__asm___10_settings_c_56d4b884____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
