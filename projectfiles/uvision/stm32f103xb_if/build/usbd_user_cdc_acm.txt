; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\usbd_user_cdc_acm.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usbd_user_cdc_acm.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\usbd_user_cdc_acm.crf ..\..\..\source\daplink\usb2uart\usbd_user_cdc_acm.c]
                          THUMB

                          AREA ||i.USBD_CDC_ACM_PortGetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortGetLineCoding PROC
;;;104     */
;;;105    int32_t USBD_CDC_ACM_PortGetLineCoding(CDC_LINE_CODING *line_coding)
000000  b570              PUSH     {r4-r6,lr}
;;;106    {
;;;107        line_coding->dwDTERate   = UART_Config.Baudrate;
000002  4d07              LDR      r5,|L1.32|
000004  4604              MOV      r4,r0                 ;106
000006  4621              MOV      r1,r4
000008  6828              LDR      r0,[r5,#0]  ; UART_Config
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;108        line_coding->bDataBits   = UART_Config.DataBits;
00000e  7928              LDRB     r0,[r5,#4]  ; UART_Config
000010  71a0              STRB     r0,[r4,#6]
;;;109        line_coding->bParityType = UART_Config.Parity;
000012  7968              LDRB     r0,[r5,#5]  ; UART_Config
000014  7160              STRB     r0,[r4,#5]
;;;110        line_coding->bCharFormat = UART_Config.StopBits;
000016  79a8              LDRB     r0,[r5,#6]  ; UART_Config
000018  7120              STRB     r0,[r4,#4]
;;;111        return (1);
00001a  2001              MOVS     r0,#1
;;;112    }
00001c  bd70              POP      {r4-r6,pc}
;;;113    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||+0x4

                          AREA ||i.USBD_CDC_ACM_PortInitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortInitialize PROC
;;;41      */
;;;42     int32_t USBD_CDC_ACM_PortInitialize(void)
000000  b510              PUSH     {r4,lr}
;;;43     {
;;;44         uart_initialize();
000002  f7fffffe          BL       uart_initialize
;;;45         main_cdc_send_event();
000006  f7fffffe          BL       main_cdc_send_event
;;;46         return 1;
00000a  2001              MOVS     r0,#1
;;;47     }
00000c  bd10              POP      {r4,pc}
;;;48     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortReset||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortReset PROC
;;;70      */
;;;71     int32_t USBD_CDC_ACM_PortReset(void)
000000  b510              PUSH     {r4,lr}
;;;72     {
;;;73         uart_reset();
000002  f7fffffe          BL       uart_reset
;;;74         return 1;
000006  2001              MOVS     r0,#1
;;;75     }
000008  bd10              POP      {r4,pc}
;;;76     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetControlLineState||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortSetControlLineState PROC
;;;149     */
;;;150    int32_t USBD_CDC_ACM_PortSetControlLineState(uint16_t ctrl_bmp)
000000  2001              MOVS     r0,#1
;;;151    {
;;;152        return (1);
;;;153    }
000002  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortSetLineCoding PROC
;;;85      */
;;;86     int32_t USBD_CDC_ACM_PortSetLineCoding(CDC_LINE_CODING *line_coding)
000000  b510              PUSH     {r4,lr}
;;;87     {
000002  4604              MOV      r4,r0
;;;88         UART_Config.Baudrate    = line_coding->dwDTERate;
000004  f7fffffe          BL       __aeabi_uread4
000008  4907              LDR      r1,|L5.40|
;;;89         UART_Config.DataBits    = (UART_DataBits) line_coding->bDataBits;
00000a  6008              STR      r0,[r1,#0]  ; UART_Config
00000c  79a0              LDRB     r0,[r4,#6]
00000e  7108              STRB     r0,[r1,#4]
;;;90         UART_Config.Parity      = (UART_Parity)   line_coding->bParityType;
000010  7960              LDRB     r0,[r4,#5]
000012  7148              STRB     r0,[r1,#5]
;;;91         UART_Config.StopBits    = (UART_StopBits) line_coding->bCharFormat;
000014  7920              LDRB     r0,[r4,#4]
000016  7188              STRB     r0,[r1,#6]
;;;92         UART_Config.FlowControl = UART_FLOW_CONTROL_NONE;
000018  2000              MOVS     r0,#0
00001a  71c8              STRB     r0,[r1,#7]
;;;93         return uart_set_configuration(&UART_Config);
00001c  e8bd4010          POP      {r4,lr}
000020  4608              MOV      r0,r1
000022  f7ffbffe          B.W      uart_set_configuration
;;;94     }
;;;95     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      ||.data||+0x4

                          AREA ||i.USBD_CDC_ACM_PortUninitialize||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortUninitialize PROC
;;;56      */
;;;57     int32_t USBD_CDC_ACM_PortUninitialize(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59         uart_uninitialize();
000002  f7fffffe          BL       uart_uninitialize
;;;60         return 1;
000006  2001              MOVS     r0,#1
;;;61     }
000008  bd10              POP      {r4,pc}
;;;62     
                          ENDP


                          AREA ||i.USBD_CDC_ACM_SendBreak||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_SendBreak PROC
;;;114    static U32 start_break_time = 0;
;;;115    int32_t USBD_CDC_ACM_SendBreak(uint16_t dur)
000000  b570              PUSH     {r4-r6,lr}
;;;116    {
000002  4605              MOV      r5,r0
;;;117        uint32_t end_break_time;
;;;118    #ifdef DRAG_N_DROP_SUPPORT    
;;;119        if (!flash_intf_target->flash_busy()) 
000004  480d              LDR      r0,|L7.60|
000006  6800              LDR      r0,[r0,#0]  ; flash_intf_target
000008  69c1              LDR      r1,[r0,#0x1c]
00000a  4788              BLX      r1
00000c  b9a0              CBNZ     r0,|L7.56|
;;;120    #endif    
;;;121        { //added checking if flashing on target is in progress
;;;122            // reset and send the unique id over CDC
;;;123            if (dur != 0) {
;;;124                start_break_time = osKernelGetSysTimerCount();
00000e  4c0c              LDR      r4,|L7.64|
000010  b135              CBZ      r5,|L7.32|
000012  f7fffffe          BL       osKernelGetSysTimerCount
;;;125                target_set_state(RESET_HOLD);
000016  6020              STR      r0,[r4,#0]  ; start_break_time
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       target_set_state
00001e  e00b              B        |L7.56|
                  |L7.32|
;;;126            } else {
;;;127                end_break_time = osKernelGetSysTimerCount();
000020  f7fffffe          BL       osKernelGetSysTimerCount
;;;128    
;;;129                // long reset -> send uID over serial (300 -> break > 3s)
;;;130                if ((end_break_time - start_break_time) >= (300)) {
000024  6821              LDR      r1,[r4,#0]  ; start_break_time
000026  1a40              SUBS     r0,r0,r1
000028  f5b07f96          CMP      r0,#0x12c
00002c  d301              BCC      |L7.50|
;;;131                    main_reset_target(1);
00002e  2001              MOVS     r0,#1
000030  e000              B        |L7.52|
                  |L7.50|
;;;132                } else {
;;;133                    main_reset_target(0);
000032  2000              MOVS     r0,#0
                  |L7.52|
000034  f7fffffe          BL       main_reset_target
                  |L7.56|
;;;134                }
;;;135            }
;;;136        }
;;;137        return (1);
000038  2001              MOVS     r0,#1
;;;138    }
00003a  bd70              POP      {r4-r6,pc}
;;;139    
                          ENDP

                  |L7.60|
                          DCD      flash_intf_target
                  |L7.64|
                          DCD      ||.data||

                          AREA ||i.cdc_process_event||, CODE, READONLY, ALIGN=1

                  cdc_process_event PROC
;;;154    
;;;155    void cdc_process_event()
000000  b500              PUSH     {lr}
;;;156    {
000002  b091              SUB      sp,sp,#0x44
;;;157        int32_t len_data = 0;
;;;158        uint8_t data[64];
;;;159    
;;;160        len_data = USBD_CDC_ACM_DataFree();
000004  f7fffffe          BL       USBD_CDC_ACM_DataFree
;;;161    
;;;162        if (len_data > sizeof(data)) {
000008  2840              CMP      r0,#0x40
00000a  d901              BLS      |L8.16|
;;;163            len_data = sizeof(data);
00000c  2040              MOVS     r0,#0x40
00000e  e000              B        |L8.18|
                  |L8.16|
;;;164        }
;;;165    
;;;166        if (len_data) {
000010  b160              CBZ      r0,|L8.44|
                  |L8.18|
;;;167            len_data = uart_read_data(data, len_data);
000012  b281              UXTH     r1,r0
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       uart_read_data
00001a  0001              MOVS     r1,r0
00001c  d006              BEQ      |L8.44|
;;;168        }
;;;169    
;;;170        if (len_data) {
;;;171            if (USBD_CDC_ACM_DataSend(data , len_data)) {
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       USBD_CDC_ACM_DataSend
000024  b110              CBZ      r0,|L8.44|
;;;172                main_blink_cdc_led(MAIN_LED_FLASH);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       main_blink_cdc_led
                  |L8.44|
;;;173            }
;;;174        }
;;;175    
;;;176        len_data = uart_write_free();
00002c  f7fffffe          BL       uart_write_free
000030  4601              MOV      r1,r0
;;;177    
;;;178        if (len_data > sizeof(data)) {
000032  2840              CMP      r0,#0x40
000034  d901              BLS      |L8.58|
;;;179            len_data = sizeof(data);
000036  2140              MOVS     r1,#0x40
000038  e000              B        |L8.60|
                  |L8.58|
;;;180        }
;;;181    
;;;182        if (len_data) {
00003a  b159              CBZ      r1,|L8.84|
                  |L8.60|
;;;183            len_data = USBD_CDC_ACM_DataRead(data, len_data);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       USBD_CDC_ACM_DataRead
000042  b138              CBZ      r0,|L8.84|
;;;184        }
;;;185    
;;;186        if (len_data) {
;;;187            if (uart_write_data(data, len_data)) {
000044  b281              UXTH     r1,r0
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       uart_write_data
00004c  b110              CBZ      r0,|L8.84|
;;;188                main_blink_cdc_led(MAIN_LED_FLASH);
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       main_blink_cdc_led
                  |L8.84|
;;;189            }
;;;190        }
;;;191     
;;;192        // Always process events
;;;193        main_cdc_send_event();
000054  f7fffffe          BL       main_cdc_send_event
;;;194    }
000058  b011              ADD      sp,sp,#0x44
00005a  bd00              POP      {pc}
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  start_break_time
                          DCD      0x00000000
                  UART_Config
                          %        8
