; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\main.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\main.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\main.crf ..\..\..\source\daplink\interface\main.c]
                          THUMB

                          AREA ||i.USBD_SignalHandler||, CODE, READONLY, ALIGN=2

                  USBD_SignalHandler PROC
;;;177    
;;;178    void USBD_SignalHandler()
000000  4802              LDR      r0,|L1.12|
;;;179    {
;;;180        osThreadFlagsSet(main_task_id, FLAGS_MAIN_PROC_USB);
000002  f44f7100          MOV      r1,#0x200
000006  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000008  f7ffbffe          B.W      osThreadFlagsSet
;;;181    }
;;;182    
                          ENDP

                  |L1.12|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;460    
;;;461    int main(void)
000000  4908              LDR      r1,|L2.36|
;;;462    {
;;;463        // Explicitly set the vector table since the bootloader might not set
;;;464        // it to what we expect.
;;;465    #if DAPLINK_ROM_BL_SIZE > 0
;;;466        SCB->VTOR = SCB_VTOR_TBLOFF_Msk & DAPLINK_ROM_IF_START;
000002  4807              LDR      r0,|L2.32|
000004  6008              STR      r0,[r1,#0]
;;;467    #endif
;;;468        // initialize vendor sdk
;;;469        sdk_init();
000006  f7fffffe          BL       sdk_init
;;;470    
;;;471        osKernelInitialize();                 // Initialize CMSIS-RTOS
00000a  f7fffffe          BL       osKernelInitialize
;;;472        osThreadNew(main_task, NULL, NULL);    // Create application main thread
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4805              LDR      r0,|L2.40|
000014  f7fffffe          BL       osThreadNew
;;;473        osKernelStart();                      // Start thread execution
000018  f7fffffe          BL       osKernelStart
                  |L2.28|
;;;474        for (;;) {}
00001c  e7fe              B        |L2.28|
;;;475    }
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x0800c000
                  |L2.36|
                          DCD      0xe000ed08
                  |L2.40|
                          DCD      main_task

                          AREA ||i.main_blink_cdc_led||, CODE, READONLY, ALIGN=2

                  main_blink_cdc_led PROC
;;;136    // Flash CDC LED using 30mS tick
;;;137    void main_blink_cdc_led(main_led_state_t state)
000000  4902              LDR      r1,|L3.12|
;;;138    {
;;;139        cdc_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  704a              STRB     r2,[r1,#1]
;;;140        cdc_led_state = state;
000006  7108              STRB     r0,[r1,#4]
;;;141        return;
;;;142    }
000008  4770              BX       lr
;;;143    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      ||.data||

                          AREA ||i.main_blink_hid_led||, CODE, READONLY, ALIGN=2

                  main_blink_hid_led PROC
;;;128    // Flash HID LED using 30mS tick
;;;129    void main_blink_hid_led(main_led_state_t state)
000000  4902              LDR      r1,|L4.12|
;;;130    {
;;;131        hid_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  700a              STRB     r2,[r1,#0]
;;;132        hid_led_state = state;
000006  70c8              STRB     r0,[r1,#3]
;;;133        return;
;;;134    }
000008  4770              BX       lr
;;;135    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      ||.data||

                          AREA ||i.main_blink_msc_led||, CODE, READONLY, ALIGN=2

                  main_blink_msc_led PROC
;;;144    // Flash MSC LED using 30mS tick
;;;145    void main_blink_msc_led(main_led_state_t state)
000000  4902              LDR      r1,|L5.12|
;;;146    {
;;;147        msc_led_usb_activity = 1;
000002  2201              MOVS     r2,#1
000004  708a              STRB     r2,[r1,#2]
;;;148        msc_led_state = state;
000006  7148              STRB     r0,[r1,#5]
;;;149        return;
;;;150    }
000008  4770              BX       lr
;;;151    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||.data||

                          AREA ||i.main_cdc_send_event||, CODE, READONLY, ALIGN=2

                  main_cdc_send_event PROC
;;;166    // Start CDC processing
;;;167    void main_cdc_send_event(void)
000000  4802              LDR      r0,|L6.12|
;;;168    {
;;;169        osThreadFlagsSet(main_task_id, FLAGS_MAIN_CDC_EVENT);
000002  f44f6100          MOV      r1,#0x800
000006  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000008  f7ffbffe          B.W      osThreadFlagsSet
;;;170        return;
;;;171    }
;;;172    
                          ENDP

                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.main_disable_debug_event||, CODE, READONLY, ALIGN=2

                  main_disable_debug_event PROC
;;;159    // Disable debug on target
;;;160    void main_disable_debug_event(void)
000000  4802              LDR      r0,|L7.12|
;;;161    {
;;;162        osThreadFlagsSet(main_task_id, FLAGS_MAIN_DISABLEDEBUG);
000002  2120              MOVS     r1,#0x20
000004  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000006  f7ffbffe          B.W      osThreadFlagsSet
;;;163        return;
;;;164    }
;;;165    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.main_powerdown_event||, CODE, READONLY, ALIGN=2

                  main_powerdown_event PROC
;;;152    // Power down the interface
;;;153    void main_powerdown_event(void)
000000  4802              LDR      r0,|L8.12|
;;;154    {
;;;155        osThreadFlagsSet(main_task_id, FLAGS_MAIN_POWERDOWN);
000002  2110              MOVS     r1,#0x10
000004  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000006  f7ffbffe          B.W      osThreadFlagsSet
;;;156        return;
;;;157    }
;;;158    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      ||.data||

                          AREA ||i.main_reset_target||, CODE, READONLY, ALIGN=2

                  main_reset_target PROC
;;;121    // parameter should be reset type??
;;;122    void main_reset_target(uint8_t send_unique_id)
000000  4802              LDR      r0,|L9.12|
;;;123    {
;;;124        osThreadFlagsSet(main_task_id, FLAGS_MAIN_RESET);
000002  2104              MOVS     r1,#4
000004  68c0              LDR      r0,[r0,#0xc]  ; main_task_id
000006  f7ffbffe          B.W      osThreadFlagsSet
;;;125        return;
;;;126    }
;;;127    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      ||.data||

                          AREA ||i.main_task||, CODE, READONLY, ALIGN=2

                  main_task PROC
;;;184    
;;;185    void main_task(void * arg)
000000  2700              MOVS     r7,#0
;;;186    {
;;;187        // State processing
;;;188        uint16_t flags = 0;
;;;189        // LED
;;;190        gpio_led_state_t hid_led_value = HID_LED_DEF;
;;;191        gpio_led_state_t cdc_led_value = CDC_LED_DEF;
000002  463e              MOV      r6,r7
;;;192        gpio_led_state_t msc_led_value = MSC_LED_DEF;
000004  463d              MOV      r5,r7
;;;193        // USB
;;;194        uint32_t usb_state_count = USB_BUSY_TIME;
;;;195        uint32_t usb_no_config_count = USB_CONFIGURE_TIMEOUT;
000006  f04f0816          MOV      r8,#0x16
;;;196        // button state
;;;197        uint8_t reset_pressed = 0;
00000a  46ba              MOV      r10,r7
;;;198    #ifdef PBON_BUTTON
;;;199        uint8_t power_on = 1;
;;;200    #endif
;;;201    
;;;202        // Initialize settings - required for asserts to work
;;;203        config_init();
00000c  f7fffffe          BL       config_init
;;;204        // Update bootloader if it is out of date
;;;205        bootloader_check_and_update();
000010  f7fffffe          BL       bootloader_check_and_update
;;;206        // Get a reference to this task
;;;207        main_task_id = osThreadGetId();
000014  f7fffffe          BL       osThreadGetId
000018  4c98              LDR      r4,|L10.636|
;;;208        // leds
;;;209        gpio_init();
00001a  60e0              STR      r0,[r4,#0xc]  ; main_task_id
00001c  f7fffffe          BL       gpio_init
;;;210        // Turn to LED default settings
;;;211        gpio_set_hid_led(hid_led_value);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       gpio_set_hid_led
;;;212        gpio_set_cdc_led(cdc_led_value);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       gpio_set_cdc_led
;;;213        gpio_set_msc_led(msc_led_value);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       gpio_set_msc_led
;;;214        // Initialize the DAP
;;;215        DAP_Setup();
000032  f7fffffe          BL       DAP_Setup
;;;216    
;;;217        // do some init with the target before USB and files are configured
;;;218        if (g_board_info.prerun_board_config) {
000036  4892              LDR      r0,|L10.640|
000038  f7fffffe          BL       __aeabi_uread4
00003c  b100              CBZ      r0,|L10.64|
;;;219            g_board_info.prerun_board_config();
00003e  4780              BLX      r0
                  |L10.64|
;;;220        }
;;;221    
;;;222        //initialize the family
;;;223        init_family();
000040  f7fffffe          BL       init_family
;;;224    
;;;225        if (g_target_family && g_target_family->prerun_target_config) {
000044  488f              LDR      r0,|L10.644|
000046  6800              LDR      r0,[r0,#0]  ; g_target_family
000048  b110              CBZ      r0,|L10.80|
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  b100              CBZ      r0,|L10.80|
;;;226            g_target_family->prerun_target_config();
00004e  4780              BLX      r0
                  |L10.80|
;;;227        }
;;;228    
;;;229        //setup some flags
;;;230        if (g_board_info.flags & kEnableUnderResetConnect) {
000050  488b              LDR      r0,|L10.640|
000052  385e              SUBS     r0,r0,#0x5e
000054  4681              MOV      r9,r0
000056  f7fffffe          BL       __aeabi_uread4
00005a  0780              LSLS     r0,r0,#30
00005c  d502              BPL      |L10.100|
;;;231            swd_set_reset_connect(CONNECT_UNDER_RESET);
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       swd_set_reset_connect
                  |L10.100|
000064  4648              MOV      r0,r9
;;;232        }
;;;233        if (g_board_info.flags & kEnablePageErase) {
000066  f7fffffe          BL       __aeabi_uread4
00006a  07c0              LSLS     r0,r0,#31
00006c  d002              BEQ      |L10.116|
;;;234    #ifdef DRAG_N_DROP_SUPPORT
;;;235            flash_manager_set_page_erase(true);
00006e  2001              MOVS     r0,#1
000070  f7fffffe          BL       flash_manager_set_page_erase
                  |L10.116|
;;;236    #endif
;;;237        }
;;;238    
;;;239        // Update versions and IDs
;;;240        info_init();
000074  f7fffffe          BL       info_init
;;;241        // USB
;;;242        usbd_init();
000078  f7fffffe          BL       usbd_init
;;;243    #ifdef DRAG_N_DROP_SUPPORT
;;;244        vfs_mngr_fs_enable((config_ram_get_disable_msd()==0));
00007c  f7fffffe          BL       config_ram_get_disable_msd
000080  b3f0              CBZ      r0,|L10.256|
000082  2000              MOVS     r0,#0
                  |L10.132|
000084  f7fffffe          BL       vfs_mngr_fs_enable
;;;245    #endif
;;;246        usbd_connect(0);
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       usbd_connect
;;;247        usb_state = USB_CONNECTING;
00008e  487b              LDR      r0,|L10.636|
000090  2101              MOVS     r1,#1
;;;248        usb_state_count = USB_CONNECT_DELAY;
;;;249    
;;;250        // Start timer tasks
;;;251        osTimerId_t tmr_id = osTimerNew(timer_task_30mS, osTimerPeriodic, NULL, NULL);
000092  2300              MOVS     r3,#0
000094  71c1              STRB     r1,[r0,#7]            ;247
000096  f04f0b0b          MOV      r11,#0xb              ;248
00009a  461a              MOV      r2,r3
00009c  487a              LDR      r0,|L10.648|
00009e  f7fffffe          BL       osTimerNew
;;;252        osTimerStart(tmr_id, 3);
0000a2  2103              MOVS     r1,#3
0000a4  f7fffffe          BL       osTimerStart
0000a8  f04f0900          MOV      r9,#0
                  |L10.172|
;;;253        while (1) {
;;;254            flags = osThreadFlagsWait(FLAGS_MAIN_RESET             // Put target in reset state
0000ac  f04f32ff          MOV      r2,#0xffffffff
0000b0  2100              MOVS     r1,#0
0000b2  f6402037          MOV      r0,#0xa37
0000b6  f7fffffe          BL       osThreadFlagsWait
0000ba  b284              UXTH     r4,r0
;;;255                           | FLAGS_MAIN_90MS            // 90mS tick
;;;256                           | FLAGS_MAIN_30MS            // 30mS tick
;;;257                           | FLAGS_MAIN_POWERDOWN       // Power down interface
;;;258                           | FLAGS_MAIN_DISABLEDEBUG    // Disable target debug
;;;259                           | FLAGS_MAIN_PROC_USB        // process usb events
;;;260                           | FLAGS_MAIN_CDC_EVENT       // cdc event
;;;261                           , osFlagsWaitAny
;;;262                           , osWaitForever);
;;;263    
;;;264            if (flags & FLAGS_MAIN_PROC_USB) {
0000bc  05a0              LSLS     r0,r4,#22
0000be  d507              BPL      |L10.208|
;;;265                if (usb_test_mode) {
0000c0  486e              LDR      r0,|L10.636|
0000c2  7980              LDRB     r0,[r0,#6]  ; usb_test_mode
0000c4  b110              CBZ      r0,|L10.204|
;;;266                    // When in USB test mode Insert a delay to
;;;267                    // simulate worst-case behavior.
;;;268                    osDelay(1);
0000c6  2001              MOVS     r0,#1
0000c8  f7fffffe          BL       osDelay
                  |L10.204|
;;;269                }
;;;270                USBD_Handler();
0000cc  f7fffffe          BL       USBD_Handler
                  |L10.208|
;;;271            }
;;;272    
;;;273            if (flags & FLAGS_MAIN_RESET) {
0000d0  0760              LSLS     r0,r4,#29
0000d2  d502              BPL      |L10.218|
;;;274                target_set_state(RESET_RUN);
0000d4  2002              MOVS     r0,#2
0000d6  f7fffffe          BL       target_set_state
                  |L10.218|
;;;275            }
;;;276    
;;;277            if (flags & FLAGS_MAIN_POWERDOWN) {
0000da  06e0              LSLS     r0,r4,#27
0000dc  d516              BPL      |L10.268|
;;;278                // Disable debug
;;;279                target_set_state(NO_DEBUG);
0000de  2003              MOVS     r0,#3
0000e0  f7fffffe          BL       target_set_state
;;;280                // Disable board power before USB is disconnected.
;;;281                gpio_set_board_power(false);
0000e4  2000              MOVS     r0,#0
0000e6  f7fffffe          BL       gpio_set_board_power
;;;282                // Disconnect USB
;;;283                usbd_connect(0);
0000ea  2000              MOVS     r0,#0
0000ec  f7fffffe          BL       usbd_connect
;;;284                // Turn off LED
;;;285                gpio_set_hid_led(GPIO_LED_OFF);
0000f0  2000              MOVS     r0,#0
0000f2  f7fffffe          BL       gpio_set_hid_led
;;;286                gpio_set_cdc_led(GPIO_LED_OFF);
0000f6  2000              MOVS     r0,#0
0000f8  f7fffffe          BL       gpio_set_cdc_led
;;;287                gpio_set_msc_led(GPIO_LED_OFF);
0000fc  2000              MOVS     r0,#0
0000fe  e000              B        |L10.258|
                  |L10.256|
000100  e002              B        |L10.264|
                  |L10.258|
000102  f7fffffe          BL       gpio_set_msc_led
                  |L10.262|
;;;288    
;;;289                // TODO: put the interface chip in sleep mode
;;;290                while (1);
000106  e7fe              B        |L10.262|
                  |L10.264|
000108  2001              MOVS     r0,#1                 ;244
00010a  e7bb              B        |L10.132|
                  |L10.268|
;;;291            }
;;;292    
;;;293            if (flags & FLAGS_MAIN_DISABLEDEBUG) {
00010c  06a0              LSLS     r0,r4,#26
00010e  d502              BPL      |L10.278|
;;;294                // Disable debug
;;;295                target_set_state(NO_DEBUG);
000110  2003              MOVS     r0,#3
000112  f7fffffe          BL       target_set_state
                  |L10.278|
;;;296            }
;;;297    
;;;298            if (flags & FLAGS_MAIN_CDC_EVENT) {
000116  0520              LSLS     r0,r4,#20
000118  d501              BPL      |L10.286|
;;;299                cdc_process_event();
00011a  f7fffffe          BL       cdc_process_event
                  |L10.286|
;;;300            }
;;;301    
;;;302            if (flags & FLAGS_MAIN_90MS) {
00011e  07e0              LSLS     r0,r4,#31
000120  d03b              BEQ      |L10.410|
;;;303                // Update USB busy status
;;;304    #ifdef DRAG_N_DROP_SUPPORT
;;;305                vfs_mngr_periodic(90); // FLAGS_MAIN_90MS
000122  205a              MOVS     r0,#0x5a
000124  f7fffffe          BL       vfs_mngr_periodic
;;;306    #endif
;;;307                // Update USB connect status
;;;308                switch (usb_state) {
000128  4854              LDR      r0,|L10.636|
00012a  79c0              LDRB     r0,[r0,#7]  ; usb_state
00012c  b1f8              CBZ      r0,|L10.366|
00012e  2801              CMP      r0,#1
000130  d00d              BEQ      |L10.334|
000132  2803              CMP      r0,#3
000134  d01c              BEQ      |L10.368|
000136  2805              CMP      r0,#5
000138  d12f              BNE      |L10.410|
;;;309                    case USB_DISCONNECTING:
;;;310                        usb_state = USB_DISCONNECTED;
00013a  4950              LDR      r1,|L10.636|
;;;311                        // Disable board power before USB is disconnected.
;;;312                        gpio_set_board_power(false);
00013c  2000              MOVS     r0,#0
00013e  f8819007          STRB     r9,[r1,#7]            ;310
000142  f7fffffe          BL       gpio_set_board_power
;;;313                        usbd_connect(0);
000146  2000              MOVS     r0,#0
000148  f7fffffe          BL       usbd_connect
;;;314                        break;
00014c  e025              B        |L10.410|
                  |L10.334|
;;;315    
;;;316                    case USB_CONNECTING:
;;;317                        // Wait before connecting
;;;318                        if (DECZERO(usb_state_count) == 0) {
00014e  f1bb0f00          CMP      r11,#0
000152  d004              BEQ      |L10.350|
000154  f1ab0001          SUB      r0,r11,#1
000158  ea5f0b00          MOVS     r11,r0
00015c  d11d              BNE      |L10.410|
                  |L10.350|
;;;319                            usbd_connect(1);
00015e  2001              MOVS     r0,#1
000160  f7fffffe          BL       usbd_connect
;;;320                            usb_state = USB_CHECK_CONNECTED;
000164  4845              LDR      r0,|L10.636|
000166  2103              MOVS     r1,#3
;;;321                            // Reset connect timeout
;;;322                            usb_no_config_count = USB_CONFIGURE_TIMEOUT;
000168  f04f0816          MOV      r8,#0x16
00016c  71c1              STRB     r1,[r0,#7]            ;320
                  |L10.366|
00016e  e014              B        |L10.410|
                  |L10.368|
;;;323                        }
;;;324    
;;;325                        break;
;;;326    
;;;327                    case USB_CHECK_CONNECTED:
;;;328                        if (usbd_configured()) {
000170  f7fffffe          BL       usbd_configured
000174  b130              CBZ      r0,|L10.388|
;;;329                            // Let the HIC enable power to the target now that high power has been negotiated.
;;;330                            gpio_set_board_power(true);
000176  2001              MOVS     r0,#1
000178  f7fffffe          BL       gpio_set_board_power
;;;331    
;;;332                            usb_state = USB_CONNECTED;
00017c  483f              LDR      r0,|L10.636|
00017e  2102              MOVS     r1,#2
000180  71c1              STRB     r1,[r0,#7]
000182  e00a              B        |L10.410|
                  |L10.388|
;;;333                        }
;;;334                        else if (DECZERO(usb_no_config_count) == 0) {
000184  f1b80f00          CMP      r8,#0
000188  d004              BEQ      |L10.404|
00018a  f1a80001          SUB      r0,r8,#1
00018e  ea5f0800          MOVS     r8,r0
000192  d102              BNE      |L10.410|
                  |L10.404|
;;;335                            // USB configuration timed out, which most likely indicates that the HIC is
;;;336                            // powered by a USB wall wart or similar power source. Go ahead and enable
;;;337                            // board power.
;;;338                            gpio_set_board_power(true);
000194  2001              MOVS     r0,#1
000196  f7fffffe          BL       gpio_set_board_power
                  |L10.410|
;;;339                        }
;;;340    
;;;341                        break;
;;;342    
;;;343                    case USB_CONNECTED:
;;;344                    case USB_DISCONNECTED:
;;;345                    default:
;;;346                        break;
;;;347                }
;;;348            }
;;;349    
;;;350            // 30mS tick used for flashing LED when USB is busy
;;;351            if (flags & FLAGS_MAIN_30MS) {
00019a  07a0              LSLS     r0,r4,#30
00019c  d586              BPL      |L10.172|
;;;352    
;;;353                // handle reset button without eventing
;;;354                if (!reset_pressed && gpio_get_reset_btn_fwrd()) {
00019e  f1ba0f00          CMP      r10,#0
0001a2  d003              BEQ      |L10.428|
;;;355    #ifdef DRAG_N_DROP_SUPPORT
;;;356                   if (!flash_intf_target->flash_busy()) //added checking if flashing on target is in progress
;;;357    #endif
;;;358                    {
;;;359                        // Reset button pressed
;;;360                        target_set_state(RESET_HOLD);
;;;361                        reset_pressed = 1;
;;;362                    }
;;;363                } else if (reset_pressed && !gpio_get_reset_btn_fwrd()) {
0001a4  f7fffffe          BL       gpio_get_reset_btn_fwrd
0001a8  b168              CBZ      r0,|L10.454|
0001aa  e011              B        |L10.464|
                  |L10.428|
0001ac  f7fffffe          BL       gpio_get_reset_btn_fwrd
0001b0  b170              CBZ      r0,|L10.464|
0001b2  4836              LDR      r0,|L10.652|
0001b4  6800              LDR      r0,[r0,#0]            ;356  ; flash_intf_target
0001b6  69c0              LDR      r0,[r0,#0x1c]         ;356
0001b8  4780              BLX      r0                    ;356
0001ba  b948              CBNZ     r0,|L10.464|
0001bc  2000              MOVS     r0,#0                 ;360
0001be  f7fffffe          BL       target_set_state
0001c2  2001              MOVS     r0,#1                 ;361
0001c4  e003              B        |L10.462|
                  |L10.454|
;;;364                    // Reset button released
;;;365                    target_set_state(RESET_RUN);
0001c6  2002              MOVS     r0,#2
0001c8  f7fffffe          BL       target_set_state
;;;366                    reset_pressed = 0;
0001cc  2000              MOVS     r0,#0
                  |L10.462|
0001ce  4682              MOV      r10,r0
                  |L10.464|
;;;367                }
;;;368    
;;;369    #ifdef PBON_BUTTON
;;;370                // handle PBON pressed
;;;371                if(gpio_get_pbon_btn())
;;;372                {
;;;373                    if(power_on)
;;;374                    {
;;;375                        // Loop till PBON is pressed
;;;376                        while (gpio_get_pbon_btn()) {;}
;;;377                        // Power button released when target was running
;;;378                        target_set_state(SHUTDOWN);
;;;379                        power_on = 0;
;;;380                    }
;;;381                    else
;;;382                    {
;;;383                        // Loop till PBON is pressed
;;;384                        while (gpio_get_pbon_btn()) {;}
;;;385                        // Power button released when target was already powered off
;;;386                        target_set_state(POWER_ON);
;;;387                        power_on = 1;
;;;388                    }
;;;389                }
;;;390    #endif
;;;391    
;;;392                // DAP LED
;;;393                if (hid_led_usb_activity) {
0001d0  4c2a              LDR      r4,|L10.636|
0001d2  7820              LDRB     r0,[r4,#0]  ; hid_led_usb_activity
0001d4  b150              CBZ      r0,|L10.492|
;;;394    
;;;395                    if ((hid_led_state == MAIN_LED_FLASH) || (hid_led_state == MAIN_LED_FLASH_PERMANENT)) {
0001d6  78e0              LDRB     r0,[r4,#3]  ; hid_led_state
0001d8  2801              CMP      r0,#1
0001da  d024              BEQ      |L10.550|
0001dc  2802              CMP      r0,#2
0001de  d022              BEQ      |L10.550|
;;;396                        // Toggle LED value
;;;397                        hid_led_value = GPIO_LED_ON == hid_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
;;;398    
;;;399                        // If in flash mode stop after one cycle
;;;400                        if ((HID_LED_DEF == hid_led_value) && (MAIN_LED_FLASH == hid_led_state)) {
;;;401                            hid_led_usb_activity = 0;
;;;402                            hid_led_state = MAIN_LED_DEF;
;;;403                        }
;;;404                    } else {
;;;405                        //LED next state is MAIN_LED_DEF
;;;406                        hid_led_value = HID_LED_DEF;
0001e0  2700              MOVS     r7,#0
;;;407                        hid_led_usb_activity = 0;
0001e2  f8849000          STRB     r9,[r4,#0]
                  |L10.486|
;;;408                    }
;;;409    
;;;410                    // Update hardware
;;;411                    gpio_set_hid_led(hid_led_value);
0001e6  4638              MOV      r0,r7
0001e8  f7fffffe          BL       gpio_set_hid_led
                  |L10.492|
;;;412                }
;;;413    
;;;414                // MSD LED
;;;415                if (msc_led_usb_activity) {
0001ec  78a0              LDRB     r0,[r4,#2]  ; msc_led_usb_activity
0001ee  b150              CBZ      r0,|L10.518|
;;;416    
;;;417                    if ((msc_led_state == MAIN_LED_FLASH) || (msc_led_state == MAIN_LED_FLASH_PERMANENT)) {
0001f0  7960              LDRB     r0,[r4,#5]  ; msc_led_state
0001f2  2801              CMP      r0,#1
0001f4  d025              BEQ      |L10.578|
0001f6  2802              CMP      r0,#2
0001f8  d023              BEQ      |L10.578|
;;;418                        // Toggle LED value
;;;419                        msc_led_value = GPIO_LED_ON == msc_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
;;;420    
;;;421                        // If in flash mode stop after one cycle
;;;422                        if ((MSC_LED_DEF == msc_led_value) && (MAIN_LED_FLASH == msc_led_state)) {
;;;423                            msc_led_usb_activity = 0;
;;;424                            msc_led_state = MAIN_LED_DEF;
;;;425                        }
;;;426                    } else {
;;;427                        //LED next state is MAIN_LED_DEF
;;;428                        msc_led_value = MSC_LED_DEF;
0001fa  2500              MOVS     r5,#0
;;;429                        msc_led_usb_activity = 0;
0001fc  f8849002          STRB     r9,[r4,#2]
                  |L10.512|
;;;430                    }
;;;431    
;;;432                    // Update hardware
;;;433                    gpio_set_msc_led(msc_led_value);
000200  4628              MOV      r0,r5
000202  f7fffffe          BL       gpio_set_msc_led
                  |L10.518|
;;;434                }
;;;435    
;;;436                // CDC LED
;;;437                if (cdc_led_usb_activity) {
000206  7860              LDRB     r0,[r4,#1]  ; cdc_led_usb_activity
000208  2800              CMP      r0,#0
00020a  f43faf4f          BEQ      |L10.172|
;;;438    
;;;439                    if ((cdc_led_state == MAIN_LED_FLASH) || (cdc_led_state == MAIN_LED_FLASH_PERMANENT)){
00020e  7920              LDRB     r0,[r4,#4]  ; cdc_led_state
000210  2801              CMP      r0,#1
000212  d024              BEQ      |L10.606|
000214  2802              CMP      r0,#2
000216  d022              BEQ      |L10.606|
;;;440                        // Toggle LED value
;;;441                        cdc_led_value = GPIO_LED_ON == cdc_led_value ? GPIO_LED_OFF : GPIO_LED_ON;
;;;442    
;;;443                        // If in flash mode stop after one cycle
;;;444                        if ((CDC_LED_DEF == cdc_led_value) && (MAIN_LED_FLASH == cdc_led_state)) {
;;;445                            cdc_led_usb_activity = 0;
;;;446                            cdc_led_state = MAIN_LED_DEF;
;;;447                        }
;;;448                    }else{
;;;449                        //LED next state is MAIN_LED_DEF
;;;450                        cdc_led_value = CDC_LED_DEF;
000218  2600              MOVS     r6,#0
;;;451                        cdc_led_usb_activity = 0;
00021a  f8849001          STRB     r9,[r4,#1]
                  |L10.542|
;;;452                    }
;;;453    
;;;454                    // Update hardware
;;;455                    gpio_set_cdc_led(cdc_led_value);
00021e  4630              MOV      r0,r6
000220  f7fffffe          BL       gpio_set_cdc_led
000224  e742              B        |L10.172|
                  |L10.550|
000226  2f01              CMP      r7,#1                 ;397
000228  d001              BEQ      |L10.558|
00022a  2701              MOVS     r7,#1                 ;397
00022c  e000              B        |L10.560|
                  |L10.558|
00022e  2700              MOVS     r7,#0                 ;397
                  |L10.560|
000230  2f00              CMP      r7,#0                 ;400
000232  d1d8              BNE      |L10.486|
000234  2801              CMP      r0,#1                 ;400
000236  d1d6              BNE      |L10.486|
000238  f8849000          STRB     r9,[r4,#0]            ;401
00023c  f8849003          STRB     r9,[r4,#3]            ;402
000240  e7d1              B        |L10.486|
                  |L10.578|
000242  2d01              CMP      r5,#1                 ;419
000244  d001              BEQ      |L10.586|
000246  2501              MOVS     r5,#1                 ;419
000248  e000              B        |L10.588|
                  |L10.586|
00024a  2500              MOVS     r5,#0                 ;419
                  |L10.588|
00024c  2d00              CMP      r5,#0                 ;422
00024e  d1d7              BNE      |L10.512|
000250  2801              CMP      r0,#1                 ;422
000252  d1d5              BNE      |L10.512|
000254  f8849002          STRB     r9,[r4,#2]            ;423
000258  f8849005          STRB     r9,[r4,#5]            ;424
00025c  e7d0              B        |L10.512|
                  |L10.606|
00025e  2e01              CMP      r6,#1                 ;441
000260  d001              BEQ      |L10.614|
000262  2601              MOVS     r6,#1                 ;441
000264  e000              B        |L10.616|
                  |L10.614|
000266  2600              MOVS     r6,#0                 ;441
                  |L10.616|
000268  2e00              CMP      r6,#0                 ;444
00026a  d1d8              BNE      |L10.542|
00026c  2801              CMP      r0,#1                 ;444
00026e  d1d6              BNE      |L10.542|
000270  f8849001          STRB     r9,[r4,#1]            ;445
000274  f8849004          STRB     r9,[r4,#4]            ;446
000278  e7d1              B        |L10.542|
;;;456                }
;;;457            }
;;;458        }
;;;459    }
;;;460    
                          ENDP

00027a  0000              DCW      0x0000
                  |L10.636|
                          DCD      ||.data||
                  |L10.640|
                          DCD      g_board_info+0x6a
                  |L10.644|
                          DCD      g_target_family
                  |L10.648|
                          DCD      timer_task_30mS
                  |L10.652|
                          DCD      flash_intf_target

                          AREA ||i.main_usb_set_test_mode||, CODE, READONLY, ALIGN=2

                  main_usb_set_test_mode PROC
;;;172    
;;;173    void main_usb_set_test_mode(bool enabled)
000000  4901              LDR      r1,|L11.8|
;;;174    {
;;;175        usb_test_mode = enabled;
000002  7188              STRB     r0,[r1,#6]
;;;176    }
000004  4770              BX       lr
;;;177    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||.data||

                          AREA ||i.timer_task_30mS||, CODE, READONLY, ALIGN=2

                  timer_task_30mS PROC
;;;110    // Timer task, set flags every 30mS and 90mS
;;;111    void timer_task_30mS(void * arg)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113        static uint32_t i = 0;
;;;114        osThreadFlagsSet(main_task_id, FLAGS_MAIN_30MS);
000002  4c0b              LDR      r4,|L12.48|
000004  2102              MOVS     r1,#2
000006  68e0              LDR      r0,[r4,#0xc]  ; main_task_id
000008  f7fffffe          BL       osThreadFlagsSet
;;;115        if (!(i++ % 3)) {
00000c  68a0              LDR      r0,[r4,#8]  ; i
00000e  2103              MOVS     r1,#3
000010  fbb0f2f1          UDIV     r2,r0,r1
000014  fb010112          MLS      r1,r1,r2,r0
000018  1c40              ADDS     r0,r0,#1
00001a  60a0              STR      r0,[r4,#8]  ; i
00001c  2900              CMP      r1,#0
00001e  d105              BNE      |L12.44|
;;;116            osThreadFlagsSet(main_task_id, FLAGS_MAIN_90MS);
000020  68e0              LDR      r0,[r4,#0xc]  ; main_task_id
000022  e8bd4010          POP      {r4,lr}
000026  2101              MOVS     r1,#1
000028  f7ffbffe          B.W      osThreadFlagsSet
                  |L12.44|
;;;117        }
;;;118    }
00002c  bd10              POP      {r4,pc}
;;;119    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  hid_led_usb_activity
000000  00                DCB      0x00
                  cdc_led_usb_activity
000001  00                DCB      0x00
                  msc_led_usb_activity
000002  00                DCB      0x00
                  hid_led_state
000003  01                DCB      0x01
                  cdc_led_state
000004  01                DCB      0x01
                  msc_led_state
000005  01                DCB      0x01
                  usb_test_mode
000006  00                DCB      0x00
                  usb_state
000007  00                DCB      0x00
                  i
                          DCD      0x00000000
                  main_task_id
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\interface\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_3e3da33c____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___6_main_c_3e3da33c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_3e3da33c____REVSH|
#line 144
|__asm___6_main_c_3e3da33c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
