; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\virtual_fs.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\virtual_fs.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\virtual_fs.crf ..\..\..\source\daplink\drag-n-drop\virtual_fs.c]
                          THUMB

                          AREA ||i.file_change_cb_stub||, CODE, READONLY, ALIGN=1

                  file_change_cb_stub PROC
;;;676    
;;;677    static void file_change_cb_stub(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
000000  4770              BX       lr
;;;678    {
;;;679        // Do nothing
;;;680    }
;;;681    
                          ENDP


                          AREA ||i.filename_valid||, CODE, READONLY, ALIGN=2

                  filename_valid PROC
;;;687    
;;;688    static bool filename_valid(const vfs_filename_t  filename)
000000  b5f0              PUSH     {r4-r7,lr}
;;;689    {
;;;690        // Information on valid 8.3 filenames can be found in
;;;691        // the microsoft hardware whitepaper:
;;;692        //
;;;693        // Microsoft Extensible Firmware Initiative
;;;694        // FAT32 File System Specification
;;;695        // FAT: General Overview of On-Disk Format
;;;696        const char invalid_starting_chars[] = {
000002  a118              ADR      r1,|L2.100|
000004  b085              SUB      sp,sp,#0x14           ;689
000006  6809              LDR      r1,[r1,#0]
;;;697            0xE5, // Deleted
;;;698            0x00, // Deleted (and all following entries are free)
;;;699            0x20, // Space not allowed as first character
;;;700        };
;;;701        uint32_t i;
;;;702    
;;;703        // Check for invalid starting characters
;;;704        for (i = 0; i < sizeof(invalid_starting_chars); i++) {
000008  9104              STR      r1,[sp,#0x10]
;;;705            if (invalid_starting_chars[i] == filename[0]) {
00000a  7802              LDRB     r2,[r0,#0]
00000c  2100              MOVS     r1,#0                 ;704
00000e  ab04              ADD      r3,sp,#0x10           ;696
                  |L2.16|
000010  5c5c              LDRB     r4,[r3,r1]
000012  4294              CMP      r4,r2
000014  d024              BEQ      |L2.96|
000016  1c49              ADDS     r1,r1,#1
000018  2903              CMP      r1,#3                 ;704
00001a  d3f9              BCC      |L2.16|
00001c  a112              ADR      r1,|L2.104|
;;;706                return false;
;;;707            }
;;;708        }
;;;709    
;;;710        // Make sure all the characters are valid
;;;711        for (i = 0; i < sizeof(vfs_filename_t); i++) {
00001e  2200              MOVS     r2,#0
000020  e8910078          LDM      r1,{r3-r6}
000024  466f              MOV      r7,sp
                  |L2.38|
;;;712            if (!filename_character_valid(filename[i])) {
000026  5c81              LDRB     r1,[r0,r2]
000028  e88d0078          STM      sp,{r3-r6}
00002c  f1a10c61          SUB      r12,r1,#0x61
000030  f1bc0f19          CMP      r12,#0x19
000034  d914              BLS      |L2.96|
000036  2920              CMP      r1,#0x20
000038  d201              BCS      |L2.62|
00003a  2905              CMP      r1,#5
00003c  d110              BNE      |L2.96|
                  |L2.62|
00003e  f04f0c00          MOV      r12,#0
                  |L2.66|
000042  f817e00c          LDRB     lr,[r7,r12]
000046  458e              CMP      lr,r1
000048  d00a              BEQ      |L2.96|
00004a  f10c0c01          ADD      r12,r12,#1
00004e  f1bc0f10          CMP      r12,#0x10
000052  d3f6              BCC      |L2.66|
000054  1c52              ADDS     r2,r2,#1
000056  2a0b              CMP      r2,#0xb               ;711
000058  d3e5              BCC      |L2.38|
;;;713                return false;
;;;714            }
;;;715        }
;;;716    
;;;717        // All checks have passed so filename is valid
;;;718        return true;
00005a  2001              MOVS     r0,#1
                  |L2.92|
;;;719    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bdf0              POP      {r4-r7,pc}
                  |L2.96|
000060  2000              MOVS     r0,#0                 ;713
000062  e7fb              B        |L2.92|
;;;720    
                          ENDP

                  |L2.100|
000064  e500              DCB      229,0
000066  2000              DCB      " ",0
                  |L2.104|
000068  222a2b2c          DCB      """*+,./:;<=>?[\\]|"
00006c  2e2f3a3b
000070  3c3d3e3f
000074  5b5c5d7c

                          AREA ||i.read_dir||, CODE, READONLY, ALIGN=2

                  read_dir PROC
;;;608    
;;;609    static uint32_t read_dir(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b570              PUSH     {r4-r6,lr}
;;;610    {
000002  4614              MOV      r4,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;611        if ((sector_offset + num_sectors) * VFS_SECTOR_SIZE > sizeof(dir_current)) {
000008  4420              ADD      r0,r0,r4
00000a  f44f6180          MOV      r1,#0x400
00000e  ebb12f40          CMP      r1,r0,LSL #9
000012  d207              BCS      |L3.36|
;;;612            // Trying to read too much of the root directory
;;;613            util_assert(0);
000014  f2402265          MOV      r2,#0x265
000018  a10a              ADR      r1,|L3.68|
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       _util_assert
;;;614            return 0;
000020  2000              MOVS     r0,#0
;;;615        }
;;;616       
;;;617        // Zero buffer data is VFS_SECTOR_SIZE max
;;;618        memset(data, 0, VFS_SECTOR_SIZE);
;;;619    
;;;620        if (sector_offset == 0) { //Handle the first 512 bytes
;;;621            // Copy data that is actually created in the directory
;;;622            memcpy(data, &dir_current.f[0], dir_idx*sizeof(FatDirectoryEntry_t));
;;;623        }
;;;624    
;;;625        return num_sectors * VFS_SECTOR_SIZE;
;;;626    }
000022  bd70              POP      {r4-r6,pc}
                  |L3.36|
000024  f44f7100          MOV      r1,#0x200             ;618
000028  4630              MOV      r0,r6                 ;618
00002a  f7fffffe          BL       __aeabi_memclr
00002e  b935              CBNZ     r5,|L3.62|
000030  4811              LDR      r0,|L3.120|
000032  4912              LDR      r1,|L3.124|
000034  6900              LDR      r0,[r0,#0x10]         ;622  ; dir_idx
000036  0142              LSLS     r2,r0,#5              ;622
000038  4630              MOV      r0,r6                 ;622
00003a  f7fffffe          BL       __aeabi_memcpy
                  |L3.62|
00003e  0260              LSLS     r0,r4,#9              ;625
000040  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
000044  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
000048  2e5c2e2e
00004c  5c736f75
000050  7263655c
000054  6461706c
000058  696e6b5c
00005c  64726167
000060  2d6e2d64
000064  726f705c
000068  76697274
00006c  75616c5f
000070  66732e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L3.120|
                          DCD      ||.data||
                  |L3.124|
                          DCD      ||.bss||+0x4c0

                          AREA ||i.read_fat||, CODE, READONLY, ALIGN=2

                  read_fat PROC
;;;592    
;;;593    static uint32_t read_fat(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b510              PUSH     {r4,lr}
;;;594    {
000002  460b              MOV      r3,r1
;;;595        uint32_t read_size = sizeof(file_allocation_table_t);
000004  f44f7400          MOV      r4,#0x200
000008  b108              CBZ      r0,|L4.14|
;;;596        COMPILER_ASSERT(sizeof(file_allocation_table_t) <= VFS_SECTOR_SIZE);
;;;597    
;;;598        if (sector_offset != 0) {
;;;599            // Don't worry about reading other sectors
;;;600            return 0;
00000a  2000              MOVS     r0,#0
;;;601        }
;;;602    
;;;603        memcpy(data, &fat, read_size);
;;;604        return read_size;
;;;605    }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  4622              MOV      r2,r4                 ;603
000010  4902              LDR      r1,|L4.28|
000012  4618              MOV      r0,r3                 ;603
000014  f7fffffe          BL       __aeabi_memcpy
000018  4620              MOV      r0,r4                 ;604
00001a  bd10              POP      {r4,pc}
;;;606    
                          ENDP

                  |L4.28|
                          DCD      ||.bss||+0x200

                          AREA ||i.read_mbr||, CODE, READONLY, ALIGN=2

                  read_mbr PROC
;;;576    
;;;577    static uint32_t read_mbr(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b510              PUSH     {r4,lr}
;;;578    {
000002  460b              MOV      r3,r1
;;;579        uint32_t read_size = sizeof(mbr_t);
000004  f44f7400          MOV      r4,#0x200
000008  b108              CBZ      r0,|L5.14|
;;;580        COMPILER_ASSERT(sizeof(mbr_t) <= VFS_SECTOR_SIZE);
;;;581    
;;;582        if (sector_offset != 0) {
;;;583            // Don't worry about reading other sectors
;;;584            return 0;
00000a  2000              MOVS     r0,#0
;;;585        }
;;;586    
;;;587        memcpy(data, &mbr, read_size);
;;;588        return read_size;
;;;589    }
00000c  bd10              POP      {r4,pc}
                  |L5.14|
00000e  4622              MOV      r2,r4                 ;587
000010  4902              LDR      r1,|L5.28|
000012  4618              MOV      r0,r3                 ;587
000014  f7fffffe          BL       __aeabi_memcpy
000018  4620              MOV      r0,r4                 ;588
00001a  bd10              POP      {r4,pc}
;;;590    
                          ENDP

                  |L5.28|
                          DCD      ||.bss||

                          AREA ||i.read_zero||, CODE, READONLY, ALIGN=1

                  read_zero PROC
;;;564    
;;;565    static uint32_t read_zero(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b510              PUSH     {r4,lr}
;;;566    {
000002  4608              MOV      r0,r1
;;;567        uint32_t read_size = VFS_SECTOR_SIZE * num_sectors;
000004  0254              LSLS     r4,r2,#9
;;;568        memset(data, 0, read_size);
000006  4621              MOV      r1,r4
000008  f7fffffe          BL       __aeabi_memclr
;;;569        return read_size;
00000c  4620              MOV      r0,r4
;;;570    }
00000e  bd10              POP      {r4,pc}
;;;571    
                          ENDP


                          AREA ||i.vfs_create_file||, CODE, READONLY, ALIGN=2

                  vfs_create_file PROC
;;;399    
;;;400    vfs_file_t vfs_create_file(const vfs_filename_t filename, vfs_read_cb_t read_cb, vfs_write_cb_t write_cb, uint32_t len)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;401    {
000004  4699              MOV      r9,r3
000006  4692              MOV      r10,r2
000008  468b              MOV      r11,r1
;;;402        uint32_t first_cluster;
;;;403        FatDirectoryEntry_t *de;
;;;404        uint32_t clusters;
;;;405        uint32_t cluster_size;
;;;406        uint32_t i;
;;;407        util_assert(filename_valid(filename));
00000a  9800              LDR      r0,[sp,#0]
00000c  f7fffffe          BL       filename_valid
000010  f2401297          MOV      r2,#0x197
000014  a140              ADR      r1,|L7.280|
000016  f7fffffe          BL       _util_assert
;;;408        // Compute the number of clusters in the file
;;;409        cluster_size = mbr.bytes_per_sector * mbr.sectors_per_cluster;
00001a  494c              LDR      r1,|L7.332|
;;;410        clusters = (len + cluster_size - 1) / cluster_size;
;;;411        // Write the cluster chain to the fat table
;;;412        first_cluster = 0;
00001c  2600              MOVS     r6,#0
;;;413    
;;;414        if (len > 0) {
;;;415            first_cluster = fat_idx;
00001e  4d4c              LDR      r5,|L7.336|
000020  7b08              LDRB     r0,[r1,#0xc]          ;409  ; mbr
000022  7aca              LDRB     r2,[r1,#0xb]          ;409  ; mbr
000024  7b49              LDRB     r1,[r1,#0xd]          ;409  ; mbr
000026  ea422000          ORR      r0,r2,r0,LSL #8       ;409
00002a  4348              MULS     r0,r1,r0              ;409
00002c  eb090100          ADD      r1,r9,r0              ;410
000030  1e49              SUBS     r1,r1,#1              ;410
000032  fbb1f7f0          UDIV     r7,r1,r0              ;410
000036  f1b90f00          CMP      r9,#0                 ;414
00003a  d019              BEQ      |L7.112|
;;;416    
;;;417            for (i = 0; i < clusters - 1; i++) {
00003c  2400              MOVS     r4,#0
00003e  f1a70801          SUB      r8,r7,#1
000042  68ee              LDR      r6,[r5,#0xc]  ; fat_idx
000044  e009              B        |L7.90|
                  |L7.70|
;;;418                write_fat(&fat, fat_idx, fat_idx + 1);
000046  68e9              LDR      r1,[r5,#0xc]  ; fat_idx
000048  1c48              ADDS     r0,r1,#1
00004a  b282              UXTH     r2,r0
00004c  4841              LDR      r0,|L7.340|
00004e  f7fffffe          BL       write_fat
;;;419                fat_idx++;
000052  68e8              LDR      r0,[r5,#0xc]  ; fat_idx
000054  1c40              ADDS     r0,r0,#1
000056  1c64              ADDS     r4,r4,#1
000058  60e8              STR      r0,[r5,#0xc]  ; fat_idx
                  |L7.90|
00005a  4544              CMP      r4,r8                 ;417
00005c  d3f3              BCC      |L7.70|
;;;420            }
;;;421    
;;;422            write_fat(&fat, fat_idx, 0xFFFF);
00005e  f64f72ff          MOV      r2,#0xffff
000062  483c              LDR      r0,|L7.340|
000064  68e9              LDR      r1,[r5,#0xc]  ; fat_idx
000066  f7fffffe          BL       write_fat
;;;423            fat_idx++;
00006a  68e8              LDR      r0,[r5,#0xc]  ; fat_idx
00006c  1c40              ADDS     r0,r0,#1
00006e  60e8              STR      r0,[r5,#0xc]  ; fat_idx
                  |L7.112|
;;;424        }
;;;425    
;;;426        // Update directory entry
;;;427        if (dir_idx >= ELEMENTS_IN_ARRAY(dir_current.f)) {
000070  6928              LDR      r0,[r5,#0x10]  ; dir_idx
000072  2820              CMP      r0,#0x20
000074  d302              BCC      |L7.124|
;;;428            util_assert(0);
000076  f44f72d6          MOV      r2,#0x1ac
;;;429            return VFS_FILE_INVALID;
00007a  e01f              B        |L7.188|
                  |L7.124|
;;;430        }
;;;431    
;;;432        de = &dir_current.f[dir_idx];
00007c  4936              LDR      r1,|L7.344|
;;;433        dir_idx++;
;;;434        memcpy(de, &dir_entry_tmpl, sizeof(dir_entry_tmpl));
00007e  2220              MOVS     r2,#0x20
000080  eb011440          ADD      r4,r1,r0,LSL #5       ;432
000084  1c40              ADDS     r0,r0,#1              ;432
000086  6128              STR      r0,[r5,#0x10]  ; dir_idx
000088  4934              LDR      r1,|L7.348|
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       __aeabi_memcpy
;;;435        memcpy(de->filename, filename, 11);
000090  220b              MOVS     r2,#0xb
000092  4620              MOV      r0,r4
000094  9900              LDR      r1,[sp,#0]
000096  f7fffffe          BL       __aeabi_memcpy
;;;436        de->filesize = len;
00009a  f104011c          ADD      r1,r4,#0x1c
00009e  4648              MOV      r0,r9
0000a0  f7fffffe          BL       __aeabi_uwrite4
;;;437        de->first_cluster_high_16 = (first_cluster >> 16) & 0xFFFF;
0000a4  0c30              LSRS     r0,r6,#16
0000a6  7520              STRB     r0,[r4,#0x14]
0000a8  0a00              LSRS     r0,r0,#8
0000aa  7560              STRB     r0,[r4,#0x15]
;;;438        de->first_cluster_low_16 = (first_cluster >> 0) & 0xFFFF;
0000ac  76a6              STRB     r6,[r4,#0x1a]
0000ae  0a30              LSRS     r0,r6,#8
0000b0  76e0              STRB     r0,[r4,#0x1b]
;;;439    
;;;440        // Update virtual media
;;;441        if (virtual_media_idx >= ELEMENTS_IN_ARRAY(virtual_media)) {
0000b2  68a9              LDR      r1,[r5,#8]  ; virtual_media_idx
0000b4  2910              CMP      r1,#0x10
0000b6  d309              BCC      |L7.204|
;;;442            util_assert(0);
0000b8  f44f72dd          MOV      r2,#0x1ba
                  |L7.188|
0000bc  a116              ADR      r1,|L7.280|
0000be  2000              MOVS     r0,#0
0000c0  f7fffffe          BL       _util_assert
;;;443            return VFS_FILE_INVALID;
0000c4  2000              MOVS     r0,#0
                  |L7.198|
;;;444        }
;;;445    
;;;446        virtual_media[virtual_media_idx].read_cb = read_zero;
;;;447        virtual_media[virtual_media_idx].write_cb = write_none;
;;;448    
;;;449        if (0 != read_cb) {
;;;450            virtual_media[virtual_media_idx].read_cb = read_cb;
;;;451        }
;;;452    
;;;453        if (0 != write_cb) {
;;;454            virtual_media[virtual_media_idx].write_cb = write_cb;
;;;455        }
;;;456    
;;;457        virtual_media[virtual_media_idx].length = clusters * mbr.bytes_per_sector * mbr.sectors_per_cluster;
;;;458        virtual_media_idx++;
;;;459        file_count += 1;
;;;460        return de;
;;;461    }
0000c6  b004              ADD      sp,sp,#0x10
0000c8  e8bd9ff0          POP      {r4-r12,pc}
                  |L7.204|
0000cc  4b22              LDR      r3,|L7.344|
0000ce  eb010041          ADD      r0,r1,r1,LSL #1       ;446
0000d2  3bc0              SUBS     r3,r3,#0xc0           ;446
0000d4  4a22              LDR      r2,|L7.352|
0000d6  f8432020          STR      r2,[r3,r0,LSL #2]     ;446
0000da  eb030280          ADD      r2,r3,r0,LSL #2       ;447
0000de  4e21              LDR      r6,|L7.356|
0000e0  6056              STR      r6,[r2,#4]            ;449
0000e2  f1bb0f00          CMP      r11,#0                ;449
0000e6  d001              BEQ      |L7.236|
0000e8  f843b020          STR      r11,[r3,r0,LSL #2]    ;450
                  |L7.236|
0000ec  f1ba0f00          CMP      r10,#0                ;453
0000f0  d001              BEQ      |L7.246|
0000f2  f8c2a004          STR      r10,[r2,#4]           ;454
                  |L7.246|
0000f6  4815              LDR      r0,|L7.332|
0000f8  1c49              ADDS     r1,r1,#1              ;457
0000fa  7b03              LDRB     r3,[r0,#0xc]          ;457  ; mbr
0000fc  7ac6              LDRB     r6,[r0,#0xb]          ;457  ; mbr
0000fe  7b40              LDRB     r0,[r0,#0xd]          ;457  ; mbr
000100  ea462303          ORR      r3,r6,r3,LSL #8       ;457
000104  4343              MULS     r3,r0,r3              ;457
000106  437b              MULS     r3,r7,r3              ;457
000108  6093              STR      r3,[r2,#8]            ;458
00010a  60a9              STR      r1,[r5,#8]            ;459  ; virtual_media_idx
00010c  7828              LDRB     r0,[r5,#0]            ;459  ; file_count
00010e  1c40              ADDS     r0,r0,#1              ;459
000110  7028              STRB     r0,[r5,#0]            ;459
000112  4620              MOV      r0,r4                 ;460
000114  e7d7              B        |L7.198|
;;;462    
                          ENDP

000116  0000              DCW      0x0000
                  |L7.280|
000118  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
00011c  2e5c2e2e
000120  5c736f75
000124  7263655c
000128  6461706c
00012c  696e6b5c
000130  64726167
000134  2d6e2d64
000138  726f705c
00013c  76697274
000140  75616c5f
000144  66732e63
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0
                  |L7.332|
                          DCD      ||.bss||
                  |L7.336|
                          DCD      ||.data||
                  |L7.340|
                          DCD      ||.bss||+0x200
                  |L7.344|
                          DCD      ||.bss||+0x4c0
                  |L7.348|
                          DCD      ||.constdata||+0x250
                  |L7.352|
                          DCD      read_zero
                  |L7.356|
                          DCD      write_none

                          AREA ||i.vfs_file_get_attr||, CODE, READONLY, ALIGN=1

                  vfs_file_get_attr PROC
;;;485    
;;;486    vfs_file_attr_bit_t vfs_file_get_attr(vfs_file_t file)
000000  7ac0              LDRB     r0,[r0,#0xb]
;;;487    {
;;;488        FatDirectoryEntry_t *de = file;
;;;489        return (vfs_file_attr_bit_t)de->attributes;
;;;490    }
000002  4770              BX       lr
;;;491    
                          ENDP


                          AREA ||i.vfs_file_get_size||, CODE, READONLY, ALIGN=1

                  vfs_file_get_size PROC
;;;479    
;;;480    uint32_t vfs_file_get_size(vfs_file_t file)
000000  301c              ADDS     r0,r0,#0x1c
;;;481    {
;;;482        FatDirectoryEntry_t *de = file;
;;;483        return de->filesize;
000002  f7ffbffe          B.W      __aeabi_uread4
;;;484    }
;;;485    
                          ENDP


                          AREA ||i.vfs_file_get_start_sector||, CODE, READONLY, ALIGN=2

                  vfs_file_get_start_sector PROC
;;;468    
;;;469    vfs_sector_t vfs_file_get_start_sector(vfs_file_t file)
000000  b510              PUSH     {r4,lr}
;;;470    {
;;;471        FatDirectoryEntry_t *de = file;
000002  4604              MOV      r4,r0
;;;472    
;;;473        if (vfs_file_get_size(file) == 0) {
000004  f7fffffe          BL       vfs_file_get_size
000008  b188              CBZ      r0,|L10.46|
;;;474            return VFS_INVALID_SECTOR;
;;;475        }
;;;476    
;;;477        return cluster_to_sector(de->first_cluster_low_16);
00000a  7ee0              LDRB     r0,[r4,#0x1b]
00000c  7ea1              LDRB     r1,[r4,#0x1a]
00000e  ea412200          ORR      r2,r1,r0,LSL #8
000012  4808              LDR      r0,|L10.52|
000014  1e92              SUBS     r2,r2,#2
000016  7b01              LDRB     r1,[r0,#0xc]  ; mbr
000018  7ac3              LDRB     r3,[r0,#0xb]  ; mbr
00001a  7b40              LDRB     r0,[r0,#0xd]  ; mbr
00001c  ea432101          ORR      r1,r3,r1,LSL #8
000020  4b05              LDR      r3,|L10.56|
000022  695b              LDR      r3,[r3,#0x14]  ; data_start
000024  fbb3f1f1          UDIV     r1,r3,r1
000028  fb021000          MLA      r0,r2,r0,r1
;;;478    }
00002c  bd10              POP      {r4,pc}
                  |L10.46|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;474
000032  bd10              POP      {r4,pc}
;;;479    
                          ENDP

                  |L10.52|
                          DCD      ||.bss||
                  |L10.56|
                          DCD      ||.data||

                          AREA ||i.vfs_file_set_attr||, CODE, READONLY, ALIGN=1

                  vfs_file_set_attr PROC
;;;462    
;;;463    void vfs_file_set_attr(vfs_file_t file, vfs_file_attr_bit_t attr)
000000  72c1              STRB     r1,[r0,#0xb]
;;;464    {
;;;465        FatDirectoryEntry_t *de = file;
;;;466        de->attributes = attr;
;;;467    }
000002  4770              BX       lr
;;;468    
                          ENDP


                          AREA ||i.vfs_get_total_size||, CODE, READONLY, ALIGN=2

                  vfs_get_total_size PROC
;;;385    
;;;386    uint32_t vfs_get_total_size()
000000  b570              PUSH     {r4-r6,lr}
;;;387    {
;;;388        uint32_t size;
;;;389        if (mbr.total_logical_sectors > 0) {
000002  480f              LDR      r0,|L12.64|
000004  7d01              LDRB     r1,[r0,#0x14]  ; mbr
000006  7cc0              LDRB     r0,[r0,#0x13]  ; mbr
000008  ea502401          ORRS     r4,r0,r1,LSL #8
00000c  480c              LDR      r0,|L12.64|
;;;390            size = mbr.total_logical_sectors * mbr.bytes_per_sector;
00000e  7b01              LDRB     r1,[r0,#0xc]
000010  7ac0              LDRB     r0,[r0,#0xb]
000012  ea402501          ORR      r5,r0,r1,LSL #8
000016  d001              BEQ      |L12.28|
000018  436c              MULS     r4,r5,r4
00001a  e00e              B        |L12.58|
                  |L12.28|
;;;391        } else if (mbr.big_sectors_on_drive > 0) {
00001c  4808              LDR      r0,|L12.64|
00001e  3020              ADDS     r0,r0,#0x20
000020  f7fffffe          BL       __aeabi_uread4
000024  b110              CBZ      r0,|L12.44|
;;;392            size = mbr.big_sectors_on_drive * mbr.bytes_per_sector;
000026  fb00f405          MUL      r4,r0,r5
00002a  e006              B        |L12.58|
                  |L12.44|
;;;393        } else {
;;;394            size = 0;
00002c  2400              MOVS     r4,#0
;;;395            util_assert(0);
00002e  f240128b          MOV      r2,#0x18b
000032  a104              ADR      r1,|L12.68|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       _util_assert
                  |L12.58|
;;;396        }
;;;397        return size;
00003a  4620              MOV      r0,r4
;;;398    }
00003c  bd70              POP      {r4-r6,pc}
;;;399    
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.bss||
                  |L12.68|
000044  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
000048  2e5c2e2e
00004c  5c736f75
000050  7263655c
000054  6461706c
000058  696e6b5c
00005c  64726167
000060  2d6e2d64
000064  726f705c
000068  76697274
00006c  75616c5f
000070  66732e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.vfs_init||, CODE, READONLY, ALIGN=2

                  vfs_init PROC
;;;322    
;;;323    void vfs_init(const vfs_filename_t drive_name, uint32_t disk_size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;324    {
000004  460f              MOV      r7,r1
000006  4680              MOV      r8,r0
;;;325        uint32_t i;
;;;326        uint32_t num_clusters;
;;;327        uint32_t total_sectors;
;;;328        // Clear everything
;;;329        memset(&mbr, 0, sizeof(mbr));
000008  f44f7600          MOV      r6,#0x200
00000c  4631              MOV      r1,r6
00000e  484e              LDR      r0,|L13.328|
000010  f7fffffe          BL       __aeabi_memclr4
;;;330        memset(&fat, 0, sizeof(fat));
000014  4631              MOV      r1,r6
000016  484d              LDR      r0,|L13.332|
000018  f7fffffe          BL       __aeabi_memclr4
;;;331        fat_idx = 0;
00001c  4c4c              LDR      r4,|L13.336|
00001e  2500              MOVS     r5,#0
;;;332        memset(&virtual_media, 0, sizeof(virtual_media));
000020  21c0              MOVS     r1,#0xc0
000022  484c              LDR      r0,|L13.340|
000024  60e5              STR      r5,[r4,#0xc]  ; fat_idx
000026  f7fffffe          BL       __aeabi_memclr4
;;;333        memset(&dir_current, 0, sizeof(dir_current));
00002a  484a              LDR      r0,|L13.340|
00002c  0071              LSLS     r1,r6,#1
00002e  30c0              ADDS     r0,r0,#0xc0
000030  f7fffffe          BL       __aeabi_memclr4
;;;334        dir_idx = 0;
;;;335        file_count = 0;
000034  6125              STR      r5,[r4,#0x10]  ; dir_idx
000036  7025              STRB     r5,[r4,#0]
;;;336        file_change_cb = file_change_cb_stub;
000038  4847              LDR      r0,|L13.344|
00003a  e9c40501          STRD     r0,r5,[r4,#4]
;;;337        virtual_media_idx = 0;
;;;338        data_start = 0;
;;;339        // Initialize MBR
;;;340        memcpy(&mbr, &mbr_tmpl, sizeof(mbr_t));
00003e  4632              MOV      r2,r6
000040  4946              LDR      r1,|L13.348|
000042  4841              LDR      r0,|L13.328|
000044  6165              STR      r5,[r4,#0x14]  ; data_start
000046  f7fffffe          BL       __aeabi_memcpy4
;;;341        total_sectors = ((disk_size + KB(64)) / mbr.bytes_per_sector);
00004a  4e3f              LDR      r6,|L13.328|
00004c  f5073780          ADD      r7,r7,#0x10000
000050  7b30              LDRB     r0,[r6,#0xc]  ; mbr
000052  7af1              LDRB     r1,[r6,#0xb]  ; mbr
000054  ea412000          ORR      r0,r1,r0,LSL #8
000058  fbb7f7f0          UDIV     r7,r7,r0
;;;342        // Make sure this is the right size for a FAT16 volume
;;;343        if (total_sectors < FAT_CLUSTERS_MIN * mbr.sectors_per_cluster) {
00005c  7b70              LDRB     r0,[r6,#0xd]  ; mbr
00005e  f640012d          MOV      r1,#0x82d
000062  4341              MULS     r1,r0,r1
000064  ebb70f41          CMP      r7,r1,LSL #1
000068  d209              BCS      |L13.126|
;;;344            util_assert(0);
00006a  f44f72ac          MOV      r2,#0x158
00006e  a13c              ADR      r1,|L13.352|
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       _util_assert
;;;345            total_sectors = FAT_CLUSTERS_MIN * mbr.sectors_per_cluster;
000076  7b77              LDRB     r7,[r6,#0xd]  ; mbr
000078  f241005a          MOV      r0,#0x105a
00007c  e00d              B        |L13.154|
                  |L13.126|
;;;346        } else if (total_sectors > FAT_CLUSTERS_MAX * mbr.sectors_per_cluster) {
00007e  f64f7191          MOV      r1,#0xff91
000082  4348              MULS     r0,r1,r0
000084  42b8              CMP      r0,r7
000086  d209              BCS      |L13.156|
;;;347            util_assert(0);
000088  f240125b          MOV      r2,#0x15b
00008c  a134              ADR      r1,|L13.352|
00008e  2000              MOVS     r0,#0
000090  f7fffffe          BL       _util_assert
;;;348            total_sectors = FAT_CLUSTERS_MAX * mbr.sectors_per_cluster;
000094  7b77              LDRB     r7,[r6,#0xd]  ; mbr
000096  f64f7091          MOV      r0,#0xff91
                  |L13.154|
00009a  4347              MULS     r7,r0,r7
                  |L13.156|
00009c  492a              LDR      r1,|L13.328|
00009e  3120              ADDS     r1,r1,#0x20           ;329
;;;349        }
;;;350        if (total_sectors >= 0x10000) {
0000a0  f5b73f80          CMP      r7,#0x10000
0000a4  d304              BCC      |L13.176|
;;;351            mbr.total_logical_sectors = 0;
0000a6  74f5              STRB     r5,[r6,#0x13]
0000a8  0a28              LSRS     r0,r5,#8
0000aa  7530              STRB     r0,[r6,#0x14]
;;;352            mbr.big_sectors_on_drive  = total_sectors;  
0000ac  4638              MOV      r0,r7
0000ae  e003              B        |L13.184|
                  |L13.176|
;;;353        } else {
;;;354            mbr.total_logical_sectors = total_sectors;
0000b0  74f7              STRB     r7,[r6,#0x13]
0000b2  0a38              LSRS     r0,r7,#8
0000b4  7530              STRB     r0,[r6,#0x14]
;;;355            mbr.big_sectors_on_drive  = 0;  
0000b6  2000              MOVS     r0,#0
                  |L13.184|
0000b8  f7fffffe          BL       __aeabi_uwrite4
;;;356        }
;;;357        // FAT table will likely be larger than needed, but this is allowed by the
;;;358        // fat specification
;;;359        num_clusters = total_sectors / mbr.sectors_per_cluster;
0000bc  7b70              LDRB     r0,[r6,#0xd]  ; mbr
;;;360        mbr.logical_sectors_per_fat = (num_clusters * 2 + VFS_SECTOR_SIZE - 1) / VFS_SECTOR_SIZE;
0000be  f24011ff          MOV      r1,#0x1ff
0000c2  fbb7f0f0          UDIV     r0,r7,r0              ;359
0000c6  eb010040          ADD      r0,r1,r0,LSL #1
0000ca  f3c0274f          UBFX     r7,r0,#9,#16
0000ce  82f7              STRH     r7,[r6,#0x16]
;;;361        // Initailize virtual media
;;;362        memcpy(&virtual_media, &virtual_media_tmpl, sizeof(virtual_media_tmpl));
0000d0  2230              MOVS     r2,#0x30
0000d2  4930              LDR      r1,|L13.404|
0000d4  481f              LDR      r0,|L13.340|
0000d6  f7fffffe          BL       __aeabi_memcpy4
;;;363        virtual_media[MEDIA_IDX_FAT1].length = VFS_SECTOR_SIZE * mbr.logical_sectors_per_fat;
0000da  491e              LDR      r1,|L13.340|
0000dc  0278              LSLS     r0,r7,#9
;;;364        virtual_media[MEDIA_IDX_FAT2].length = VFS_SECTOR_SIZE * mbr.logical_sectors_per_fat;
0000de  6148              STR      r0,[r1,#0x14]  ; virtual_media
;;;365        // Initialize indexes
;;;366        virtual_media_idx = MEDIA_IDX_COUNT;
0000e0  6208              STR      r0,[r1,#0x20]  ; virtual_media
0000e2  2004              MOVS     r0,#4
;;;367        data_start = 0;
;;;368    
;;;369        for (i = 0; i < ELEMENTS_IN_ARRAY(virtual_media_tmpl); i++) {
0000e4  6165              STR      r5,[r4,#0x14]  ; data_start
0000e6  60a0              STR      r0,[r4,#8]  ; virtual_media_idx
0000e8  2000              MOVS     r0,#0
                  |L13.234|
;;;370            data_start += virtual_media[i].length;
0000ea  eb000240          ADD      r2,r0,r0,LSL #1
0000ee  eb010282          ADD      r2,r1,r2,LSL #2
0000f2  6963              LDR      r3,[r4,#0x14]  ; data_start
0000f4  6892              LDR      r2,[r2,#8]
0000f6  1c40              ADDS     r0,r0,#1
0000f8  441a              ADD      r2,r2,r3
0000fa  6162              STR      r2,[r4,#0x14]         ;369  ; data_start
0000fc  2804              CMP      r0,#4                 ;369
0000fe  d3f4              BCC      |L13.234|
;;;371        }
;;;372    
;;;373        // Initialize FAT
;;;374        fat_idx = 0;
;;;375        write_fat(&fat, fat_idx, 0xFFF8);    // Media type "media_descriptor"
000100  f64f72f8          MOV      r2,#0xfff8
000104  4629              MOV      r1,r5
000106  4811              LDR      r0,|L13.332|
000108  60e5              STR      r5,[r4,#0xc]  ; fat_idx
00010a  f7fffffe          BL       write_fat
;;;376        fat_idx++;
00010e  68e1              LDR      r1,[r4,#0xc]  ; fat_idx
;;;377        write_fat(&fat, fat_idx, 0xFFFF);    // FAT12 - always 0xFFF (no meaning), FAT16 - dirty/clean (clean = 0xFFFF)
000110  f64f72ff          MOV      r2,#0xffff
000114  1c49              ADDS     r1,r1,#1              ;376
000116  480d              LDR      r0,|L13.332|
000118  60e1              STR      r1,[r4,#0xc]  ; fat_idx
00011a  f7fffffe          BL       write_fat
;;;378        fat_idx++;
00011e  68e0              LDR      r0,[r4,#0xc]  ; fat_idx
;;;379        // Initialize root dir
;;;380        dir_idx = 0;
;;;381        dir_current.f[dir_idx] = root_dir_entry;
000120  491c              LDR      r1,|L13.404|
000122  1c40              ADDS     r0,r0,#1              ;378
000124  e9c40503          STRD     r0,r5,[r4,#0xc]       ;378
000128  4d0a              LDR      r5,|L13.340|
00012a  2220              MOVS     r2,#0x20
00012c  35c0              ADDS     r5,r5,#0xc0
00012e  4628              MOV      r0,r5
000130  3130              ADDS     r1,r1,#0x30
000132  f7fffffe          BL       __aeabi_memcpy
;;;382        memcpy(dir_current.f[dir_idx].filename, drive_name, sizeof(dir_current.f[0].filename));
000136  4628              MOV      r0,r5
000138  220b              MOVS     r2,#0xb
00013a  4641              MOV      r1,r8
00013c  f7fffffe          BL       __aeabi_memcpy
;;;383        dir_idx++;
000140  2001              MOVS     r0,#1
000142  6120              STR      r0,[r4,#0x10]  ; dir_idx
;;;384    }
000144  e8bd81f0          POP      {r4-r8,pc}
;;;385    
                          ENDP

                  |L13.328|
                          DCD      ||.bss||
                  |L13.332|
                          DCD      ||.bss||+0x200
                  |L13.336|
                          DCD      ||.data||
                  |L13.340|
                          DCD      ||.bss||+0x400
                  |L13.344|
                          DCD      file_change_cb_stub
                  |L13.348|
                          DCD      ||.constdata||
                  |L13.352|
000160  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
000164  2e5c2e2e
000168  5c736f75
00016c  7263655c
000170  6461706c
000174  696e6b5c
000178  64726167
00017c  2d6e2d64
000180  726f705c
000184  76697274
000188  75616c5f
00018c  66732e63
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L13.404|
                          DCD      ||.constdata||+0x200

                          AREA ||i.vfs_read||, CODE, READONLY, ALIGN=2

                  vfs_read PROC
;;;496    
;;;497    void vfs_read(uint32_t requested_sector, uint8_t *buf, uint32_t num_sectors)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;498    {
000004  468a              MOV      r10,r1
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
;;;499        uint8_t i = 0;
00000a  2600              MOVS     r6,#0
;;;500        uint32_t current_sector;
;;;501        // Zero out the buffer
;;;502        memset(buf, 0, num_sectors * VFS_SECTOR_SIZE);
00000c  0251              LSLS     r1,r2,#9
00000e  4650              MOV      r0,r10
000010  f7fffffe          BL       __aeabi_memclr
;;;503        current_sector = 0;
;;;504    
;;;505        for (i = 0; i < ELEMENTS_IN_ARRAY(virtual_media); i++) {
;;;506            uint32_t vm_sectors = virtual_media[i].length / VFS_SECTOR_SIZE;
000014  f8df9048          LDR      r9,|L14.96|
000018  2000              MOVS     r0,#0                 ;503
                  |L14.26|
00001a  eb060246          ADD      r2,r6,r6,LSL #1
00001e  eb090182          ADD      r1,r9,r2,LSL #2
;;;507            uint32_t vm_start = current_sector;
;;;508            uint32_t vm_end = current_sector + vm_sectors;
;;;509    
;;;510            // Data can be used in this sector
;;;511            if ((requested_sector >= vm_start) && (requested_sector < vm_end)) {
000022  4284              CMP      r4,r0
000024  6889              LDR      r1,[r1,#8]            ;506
000026  eb002151          ADD      r1,r0,r1,LSR #9       ;508
00002a  4688              MOV      r8,r1                 ;508
00002c  d30e              BCC      |L14.76|
00002e  428c              CMP      r4,r1
000030  d20c              BCS      |L14.76|
;;;512                uint32_t sector_offset;
;;;513                uint32_t sectors_to_write = vm_end - requested_sector;
000032  eba80704          SUB      r7,r8,r4
;;;514                sectors_to_write = MIN(sectors_to_write, num_sectors);
000036  42af              CMP      r7,r5
000038  d300              BCC      |L14.60|
00003a  462f              MOV      r7,r5
                  |L14.60|
;;;515                sector_offset = requested_sector - current_sector;
;;;516                virtual_media[i].read_cb(sector_offset, buf, sectors_to_write);
00003c  f8593022          LDR      r3,[r9,r2,LSL #2]
000040  1a20              SUBS     r0,r4,r0              ;515
000042  463a              MOV      r2,r7
000044  4651              MOV      r1,r10
000046  4798              BLX      r3
;;;517                // Update requested sector
;;;518                requested_sector += sectors_to_write;
000048  443c              ADD      r4,r4,r7
;;;519                num_sectors -= sectors_to_write;
00004a  1bed              SUBS     r5,r5,r7
                  |L14.76|
;;;520            }
;;;521    
;;;522            // If there is no more data to be read then break
;;;523            if (num_sectors == 0) {
00004c  2d00              CMP      r5,#0
00004e  d004              BEQ      |L14.90|
000050  1c76              ADDS     r6,r6,#1
000052  b2f6              UXTB     r6,r6                 ;505
000054  4640              MOV      r0,r8
000056  2e10              CMP      r6,#0x10              ;505
000058  d3df              BCC      |L14.26|
                  |L14.90|
;;;524                break;
;;;525            }
;;;526    
;;;527            // Move to the next virtual media entry
;;;528            current_sector += vm_sectors;
;;;529        }
;;;530    }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;531    
                          ENDP

00005e  0000              DCW      0x0000
                  |L14.96|
                          DCD      ||.bss||+0x400

                          AREA ||i.vfs_set_file_change_callback||, CODE, READONLY, ALIGN=2

                  vfs_set_file_change_callback PROC
;;;491    
;;;492    void vfs_set_file_change_callback(vfs_file_change_cb_t cb)
000000  4901              LDR      r1,|L15.8|
;;;493    {
;;;494        file_change_cb = cb;
000002  6048              STR      r0,[r1,#4]  ; file_change_cb
;;;495    }
000004  4770              BX       lr
;;;496    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.data||

                          AREA ||i.vfs_write||, CODE, READONLY, ALIGN=2

                  vfs_write PROC
;;;531    
;;;532    void vfs_write(uint32_t requested_sector, const uint8_t *buf, uint32_t num_sectors)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;533    {
000004  4604              MOV      r4,r0
;;;534        uint8_t i = 0;
000006  2600              MOVS     r6,#0
000008  4615              MOV      r5,r2                 ;533
00000a  468b              MOV      r11,r1                ;533
;;;535        uint32_t current_sector;
;;;536        current_sector = 0;
00000c  4630              MOV      r0,r6
;;;537    
;;;538        for (i = 0; i < virtual_media_idx; i++) {
;;;539            uint32_t vm_sectors = virtual_media[i].length / VFS_SECTOR_SIZE;
00000e  f8df9050          LDR      r9,|L16.96|
000012  f8dfa050          LDR      r10,|L16.100|
000016  e01c              B        |L16.82|
                  |L16.24|
000018  eb060246          ADD      r2,r6,r6,LSL #1
00001c  eb090282          ADD      r2,r9,r2,LSL #2
;;;540            uint32_t vm_start = current_sector;
;;;541            uint32_t vm_end = current_sector + vm_sectors;
;;;542    
;;;543            // Data can be used in this sector
;;;544            if ((requested_sector >= vm_start) && (requested_sector < vm_end)) {
000020  4284              CMP      r4,r0
000022  6891              LDR      r1,[r2,#8]            ;541
000024  eb002151          ADD      r1,r0,r1,LSR #9       ;541
000028  4688              MOV      r8,r1                 ;541
00002a  d30d              BCC      |L16.72|
00002c  428c              CMP      r4,r1
00002e  d20b              BCS      |L16.72|
;;;545                uint32_t sector_offset;
;;;546                uint32_t sectors_to_read = vm_end - requested_sector;
000030  eba80704          SUB      r7,r8,r4
;;;547                sectors_to_read = MIN(sectors_to_read, num_sectors);
000034  42af              CMP      r7,r5
000036  d300              BCC      |L16.58|
000038  462f              MOV      r7,r5
                  |L16.58|
;;;548                sector_offset = requested_sector - current_sector;
;;;549                virtual_media[i].write_cb(sector_offset, buf, sectors_to_read);
00003a  6853              LDR      r3,[r2,#4]
00003c  1a20              SUBS     r0,r4,r0              ;548
00003e  463a              MOV      r2,r7
000040  4659              MOV      r1,r11
000042  4798              BLX      r3
;;;550                // Update requested sector
;;;551                requested_sector += sectors_to_read;
000044  443c              ADD      r4,r4,r7
;;;552                num_sectors -= sectors_to_read;
000046  1bed              SUBS     r5,r5,r7
                  |L16.72|
;;;553            }
;;;554    
;;;555            // If there is no more data to be read then break
;;;556            if (num_sectors == 0) {
000048  2d00              CMP      r5,#0
00004a  d006              BEQ      |L16.90|
00004c  1c76              ADDS     r6,r6,#1
00004e  4640              MOV      r0,r8
000050  b2f6              UXTB     r6,r6                 ;538
                  |L16.82|
000052  f8da1008          LDR      r1,[r10,#8]           ;538  ; virtual_media_idx
000056  428e              CMP      r6,r1                 ;538
000058  d3de              BCC      |L16.24|
                  |L16.90|
;;;557                break;
;;;558            }
;;;559    
;;;560            // Move to the next virtual media entry
;;;561            current_sector += vm_sectors;
;;;562        }
;;;563    }
00005a  e8bd9ff0          POP      {r4-r12,pc}
;;;564    
                          ENDP

00005e  0000              DCW      0x0000
                  |L16.96|
                          DCD      ||.bss||+0x400
                  |L16.100|
                          DCD      ||.data||

                          AREA ||i.write_dir||, CODE, READONLY, ALIGN=2

                  write_dir PROC
;;;627    
;;;628    static void write_dir(uint32_t sector_offset, const uint8_t *data, uint32_t num_sectors)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;629    {
000004  4689              MOV      r9,r1
;;;630        FatDirectoryEntry_t *old_entry;
;;;631        FatDirectoryEntry_t *new_entry;
;;;632        uint32_t start_index;
;;;633        uint32_t num_entries;
;;;634        uint32_t i;
;;;635    
;;;636        if ((sector_offset + num_sectors) * VFS_SECTOR_SIZE > sizeof(dir_current)) {
000006  1881              ADDS     r1,r0,r2
000008  f44f6380          MOV      r3,#0x400
00000c  ebb32f41          CMP      r3,r1,LSL #9
000010  d207              BCS      |L17.34|
;;;637            // Trying to write too much of the root directory
;;;638            util_assert(0);
000012  e8bd4ff8          POP      {r3-r11,lr}
000016  f240227e          MOV      r2,#0x27e
00001a  a127              ADR      r1,|L17.184|
00001c  2000              MOVS     r0,#0
00001e  f7ffbffe          B.W      _util_assert
                  |L17.34|
;;;639            return;
;;;640        }
;;;641    
;;;642        start_index = sector_offset * VFS_SECTOR_SIZE / sizeof(FatDirectoryEntry_t);
000022  0241              LSLS     r1,r0,#9
000024  094b              LSRS     r3,r1,#5
;;;643        num_entries = num_sectors * VFS_SECTOR_SIZE / sizeof(FatDirectoryEntry_t);
000026  0251              LSLS     r1,r2,#9
000028  ea4f1b51          LSR      r11,r1,#5
;;;644        old_entry = &dir_current.f[start_index];
00002c  9100              STR      r1,[sp,#0]
00002e  492f              LDR      r1,|L17.236|
000030  eb011a43          ADD      r10,r1,r3,LSL #5
;;;645        new_entry = (FatDirectoryEntry_t *)data;
;;;646        // If this is the first sector start at index 1 to get past drive name
;;;647        i = 0 == sector_offset ? 1 : 0;
000034  b110              CBZ      r0,|L17.60|
000036  2600              MOVS     r6,#0
                  |L17.56|
;;;648    
;;;649        for (; i < num_entries; i++) {
;;;650            bool same_name;
;;;651    
;;;652            if (0 == memcmp(&old_entry[i], &new_entry[i], sizeof(FatDirectoryEntry_t))) {
;;;653                continue;
;;;654            }
;;;655    
;;;656            // If were at this point then something has changed in the file
;;;657            same_name = (0 == memcmp(old_entry[i].filename, new_entry[i].filename, sizeof(new_entry[i].filename))) ? 1 : 0;
;;;658            // Changed
;;;659            file_change_cb(new_entry[i].filename, VFS_FILE_CHANGED, (vfs_file_t)&old_entry[i], (vfs_file_t)&new_entry[i]);
000038  4f2d              LDR      r7,|L17.240|
00003a  e033              B        |L17.164|
                  |L17.60|
00003c  2601              MOVS     r6,#1                 ;647
00003e  e7fb              B        |L17.56|
                  |L17.64|
000040  eb091446          ADD      r4,r9,r6,LSL #5       ;652
000044  eb0a1546          ADD      r5,r10,r6,LSL #5      ;652
000048  2220              MOVS     r2,#0x20              ;652
00004a  4621              MOV      r1,r4                 ;652
00004c  4628              MOV      r0,r5                 ;652
00004e  f7fffffe          BL       memcmp
000052  b330              CBZ      r0,|L17.162|
000054  4621              MOV      r1,r4                 ;652
000056  4628              MOV      r0,r5                 ;652
000058  220b              MOVS     r2,#0xb               ;657
00005a  f7fffffe          BL       memcmp
00005e  b178              CBZ      r0,|L17.128|
000060  2000              MOVS     r0,#0                 ;657
                  |L17.98|
000062  4680              MOV      r8,r0                 ;657
000064  f8d7c004          LDR      r12,[r7,#4]  ; file_change_cb
000068  4623              MOV      r3,r4
00006a  462a              MOV      r2,r5
00006c  4620              MOV      r0,r4
00006e  2102              MOVS     r1,#2
000070  47e0              BLX      r12
;;;660    
;;;661            // Deleted
;;;662            if (0xe5 == (uint8_t)new_entry[i].filename[0]) {
000072  7820              LDRB     r0,[r4,#0]
000074  28e5              CMP      r0,#0xe5
000076  d005              BEQ      |L17.132|
;;;663                file_change_cb(old_entry[i].filename, VFS_FILE_DELETED, (vfs_file_t)&old_entry[i], (vfs_file_t)&new_entry[i]);
;;;664                continue;
;;;665            }
;;;666    
;;;667            // Created
;;;668            if (!same_name && filename_valid(new_entry[i].filename)) {
000078  f1b80f00          CMP      r8,#0
00007c  d007              BEQ      |L17.142|
00007e  e010              B        |L17.162|
                  |L17.128|
000080  2001              MOVS     r0,#1                 ;657
000082  e7ee              B        |L17.98|
                  |L17.132|
000084  462a              MOV      r2,r5                 ;657
000086  4623              MOV      r3,r4                 ;657
000088  4610              MOV      r0,r2                 ;657
00008a  2101              MOVS     r1,#1                 ;663
00008c  e007              B        |L17.158|
                  |L17.142|
00008e  4620              MOV      r0,r4                 ;664
000090  f7fffffe          BL       filename_valid
000094  b128              CBZ      r0,|L17.162|
000096  4623              MOV      r3,r4
000098  462a              MOV      r2,r5
00009a  4618              MOV      r0,r3
;;;669                file_change_cb(new_entry[i].filename, VFS_FILE_CREATED, (vfs_file_t)&old_entry[i], (vfs_file_t)&new_entry[i]);
00009c  2100              MOVS     r1,#0
                  |L17.158|
00009e  687c              LDR      r4,[r7,#4]  ; file_change_cb
0000a0  47a0              BLX      r4
                  |L17.162|
0000a2  1c76              ADDS     r6,r6,#1
                  |L17.164|
0000a4  455e              CMP      r6,r11                ;649
0000a6  d3cb              BCC      |L17.64|
0000a8  4650              MOV      r0,r10                ;649
;;;670                continue;
;;;671            }
;;;672        }
;;;673    
;;;674        memcpy(&dir_current.f[start_index], data, num_sectors * VFS_SECTOR_SIZE);
0000aa  4649              MOV      r1,r9
0000ac  9a00              LDR      r2,[sp,#0]
0000ae  e8bd4ff8          POP      {r3-r11,lr}
0000b2  f7ffbffe          B.W      __aeabi_memcpy
;;;675    }
;;;676    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L17.184|
0000b8  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
0000bc  2e5c2e2e
0000c0  5c736f75
0000c4  7263655c
0000c8  6461706c
0000cc  696e6b5c
0000d0  64726167
0000d4  2d6e2d64
0000d8  726f705c
0000dc  76697274
0000e0  75616c5f
0000e4  66732e63
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L17.236|
                          DCD      ||.bss||+0x4c0
                  |L17.240|
                          DCD      ||.data||

                          AREA ||i.write_fat||, CODE, READONLY, ALIGN=2

                  write_fat PROC
;;;305    
;;;306    static void write_fat(file_allocation_table_t *fat, uint32_t idx, uint16_t val)
000000  b430              PUSH     {r4,r5}
;;;307    {
;;;308        uint32_t low_idx;
;;;309        uint32_t high_idx;
;;;310        low_idx = idx * 2 + 0;
000002  004b              LSLS     r3,r1,#1
;;;311        high_idx = idx * 2 + 1;
000004  2401              MOVS     r4,#1
000006  eb040141          ADD      r1,r4,r1,LSL #1
;;;312    
;;;313        // Assert that this is still within the fat table
;;;314        if (high_idx >= ELEMENTS_IN_ARRAY(fat->f)) {
00000a  f5b17f00          CMP      r1,#0x200
00000e  d306              BCC      |L18.30|
;;;315            util_assert(0);
000010  bc30              POP      {r4,r5}
000012  f240123b          MOV      r2,#0x13b
000016  a104              ADR      r1,|L18.40|
000018  2000              MOVS     r0,#0
00001a  f7ffbffe          B.W      _util_assert
                  |L18.30|
;;;316            return;
;;;317        }
;;;318    
;;;319        fat->f[low_idx] = (val >> 0) & 0xFF;
00001e  54c2              STRB     r2,[r0,r3]
;;;320        fat->f[high_idx] = (val >> 8) & 0xFF;
000020  0a12              LSRS     r2,r2,#8
000022  5442              STRB     r2,[r0,r1]
;;;321    }
000024  bc30              POP      {r4,r5}
000026  4770              BX       lr
;;;322    
                          ENDP

                  |L18.40|
000028  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\virtual_fs.c",0
00002c  2e5c2e2e
000030  5c736f75
000034  7263655c
000038  6461706c
00003c  696e6b5c
000040  64726167
000044  2d6e2d64
000048  726f705c
00004c  76697274
000050  75616c5f
000054  66732e63
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.write_none||, CODE, READONLY, ALIGN=1

                  write_none PROC
;;;571    
;;;572    static void write_none(uint32_t sector_offset, const uint8_t *data, uint32_t num_sectors)
000000  4770              BX       lr
;;;573    {
;;;574        // Do nothing
;;;575    }
;;;576    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mbr
                          %        512
                  ||fat||
                          %        512
                  virtual_media
                          %        192
                  dir_current
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  mbr_tmpl
000000  eb3c904d          DCB      0xeb,0x3c,0x90,0x4d
000004  53443053          DCB      0x53,0x44,0x30,0x53
000008  342e31            DCB      0x34,0x2e,0x31
00000b  0200              DCWU     0x0200
00000d  08                DCB      0x08
00000e  0001              DCW      0x0001
000010  02                DCB      0x02
000011  0020              DCWU     0x0020
000013  1f50              DCWU     0x1f50
000015  f8                DCB      0xf8
000016  0001              DCW      0x0001
000018  00010001          DCW      0x0001,0x0001
                          DCD      0x00000000
                          DCD      0x00000000
000024  000029            DCB      0x00,0x00,0x29
                          DCDU     0x27021974
00002b  44                DCB      0x44
00002c  41504c49          DCB      0x41,0x50,0x4c,0x49
000030  4e4b2d44          DCB      0x4e,0x4b,0x2d,0x44
000034  4e444641          DCB      0x4e,0x44,0x46,0x41
000038  54313620          DCB      0x54,0x31,0x36,0x20
00003c  2020fab8          DCB      0x20,0x20,0xfa,0xb8
000040  c0070520          DCB      0xc0,0x07,0x05,0x20
000044  018ed0bc          DCB      0x01,0x8e,0xd0,0xbc
000048  0010b8c0          DCB      0x00,0x10,0xb8,0xc0
00004c  078ed8be          DCB      0x07,0x8e,0xd8,0xbe
000050  6d00e80b          DCB      0x6d,0x00,0xe8,0x0b
000054  00ebfeb4          DCB      0x00,0xeb,0xfe,0xb4
000058  0eb700b3          DCB      0x0e,0xb7,0x00,0xb3
00005c  07cd10c3          DCB      0x07,0xcd,0x10,0xc3
000060  8a044608          DCB      0x8a,0x04,0x46,0x08
000064  c07405e8          DCB      0xc0,0x74,0x05,0xe8
000068  edffebf4          DCB      0xed,0xff,0xeb,0xf4
00006c  c3504c45          DCB      0xc3,0x50,0x4c,0x45
000070  41534520          DCB      0x41,0x53,0x45,0x20
000074  52454d4f          DCB      0x52,0x45,0x4d,0x4f
000078  56452054          DCB      0x56,0x45,0x20,0x54
00007c  48452041          DCB      0x48,0x45,0x20,0x41
000080  524d204d          DCB      0x52,0x4d,0x20,0x4d
000084  42454420          DCB      0x42,0x45,0x44,0x20
000088  4441504c          DCB      0x44,0x41,0x50,0x4c
00008c  494e4b20          DCB      0x49,0x4e,0x4b,0x20
000090  55534220          DCB      0x55,0x53,0x42,0x20
000094  44455649          DCB      0x44,0x45,0x56,0x49
000098  43452041          DCB      0x43,0x45,0x20,0x41
00009c  4e442052          DCB      0x4e,0x44,0x20,0x52
0000a0  45424f4f          DCB      0x45,0x42,0x4f,0x4f
0000a4  54205448          DCB      0x54,0x20,0x54,0x48
0000a8  45205359          DCB      0x45,0x20,0x53,0x59
0000ac  5354454d          DCB      0x53,0x54,0x45,0x4d
0000b0  2e2e0000          DCB      0x2e,0x2e,0x00,0x00
0000b4  00000000          DCB      0x00,0x00,0x00,0x00
0000b8  00000000          DCB      0x00,0x00,0x00,0x00
0000bc  00000000          DCB      0x00,0x00,0x00,0x00
0000c0  00000000          DCB      0x00,0x00,0x00,0x00
0000c4  00000000          DCB      0x00,0x00,0x00,0x00
0000c8  00000000          DCB      0x00,0x00,0x00,0x00
0000cc  00000000          DCB      0x00,0x00,0x00,0x00
0000d0  00000000          DCB      0x00,0x00,0x00,0x00
0000d4  00000000          DCB      0x00,0x00,0x00,0x00
0000d8  00000000          DCB      0x00,0x00,0x00,0x00
0000dc  00000000          DCB      0x00,0x00,0x00,0x00
0000e0  00000000          DCB      0x00,0x00,0x00,0x00
0000e4  00000000          DCB      0x00,0x00,0x00,0x00
0000e8  00000000          DCB      0x00,0x00,0x00,0x00
0000ec  00000000          DCB      0x00,0x00,0x00,0x00
0000f0  00000000          DCB      0x00,0x00,0x00,0x00
0000f4  00000000          DCB      0x00,0x00,0x00,0x00
0000f8  00000000          DCB      0x00,0x00,0x00,0x00
0000fc  00000000          DCB      0x00,0x00,0x00,0x00
000100  00000000          DCB      0x00,0x00,0x00,0x00
000104  00000000          DCB      0x00,0x00,0x00,0x00
000108  00000000          DCB      0x00,0x00,0x00,0x00
00010c  00000000          DCB      0x00,0x00,0x00,0x00
000110  00000000          DCB      0x00,0x00,0x00,0x00
000114  00000000          DCB      0x00,0x00,0x00,0x00
000118  00000000          DCB      0x00,0x00,0x00,0x00
00011c  00000000          DCB      0x00,0x00,0x00,0x00
000120  00000000          DCB      0x00,0x00,0x00,0x00
000124  00000000          DCB      0x00,0x00,0x00,0x00
000128  00000000          DCB      0x00,0x00,0x00,0x00
00012c  00000000          DCB      0x00,0x00,0x00,0x00
000130  00000000          DCB      0x00,0x00,0x00,0x00
000134  00000000          DCB      0x00,0x00,0x00,0x00
000138  00000000          DCB      0x00,0x00,0x00,0x00
00013c  00000000          DCB      0x00,0x00,0x00,0x00
000140  00000000          DCB      0x00,0x00,0x00,0x00
000144  00000000          DCB      0x00,0x00,0x00,0x00
000148  00000000          DCB      0x00,0x00,0x00,0x00
00014c  00000000          DCB      0x00,0x00,0x00,0x00
000150  00000000          DCB      0x00,0x00,0x00,0x00
000154  00000000          DCB      0x00,0x00,0x00,0x00
000158  00000000          DCB      0x00,0x00,0x00,0x00
00015c  00000000          DCB      0x00,0x00,0x00,0x00
000160  00000000          DCB      0x00,0x00,0x00,0x00
000164  00000000          DCB      0x00,0x00,0x00,0x00
000168  00000000          DCB      0x00,0x00,0x00,0x00
00016c  00000000          DCB      0x00,0x00,0x00,0x00
000170  00000000          DCB      0x00,0x00,0x00,0x00
000174  00000000          DCB      0x00,0x00,0x00,0x00
000178  00000000          DCB      0x00,0x00,0x00,0x00
00017c  00000000          DCB      0x00,0x00,0x00,0x00
000180  00000000          DCB      0x00,0x00,0x00,0x00
000184  00000000          DCB      0x00,0x00,0x00,0x00
000188  00000000          DCB      0x00,0x00,0x00,0x00
00018c  00000000          DCB      0x00,0x00,0x00,0x00
000190  00000000          DCB      0x00,0x00,0x00,0x00
000194  00000000          DCB      0x00,0x00,0x00,0x00
000198  00000000          DCB      0x00,0x00,0x00,0x00
00019c  00000000          DCB      0x00,0x00,0x00,0x00
0001a0  00000000          DCB      0x00,0x00,0x00,0x00
0001a4  00000000          DCB      0x00,0x00,0x00,0x00
0001a8  00000000          DCB      0x00,0x00,0x00,0x00
0001ac  00000000          DCB      0x00,0x00,0x00,0x00
0001b0  00000000          DCB      0x00,0x00,0x00,0x00
0001b4  00000000          DCB      0x00,0x00,0x00,0x00
0001b8  00000000          DCB      0x00,0x00,0x00,0x00
0001bc  00000000          DCB      0x00,0x00,0x00,0x00
0001c0  00000000          DCB      0x00,0x00,0x00,0x00
0001c4  00000000          DCB      0x00,0x00,0x00,0x00
0001c8  00000000          DCB      0x00,0x00,0x00,0x00
0001cc  00000000          DCB      0x00,0x00,0x00,0x00
0001d0  00000000          DCB      0x00,0x00,0x00,0x00
0001d4  00000000          DCB      0x00,0x00,0x00,0x00
0001d8  00000000          DCB      0x00,0x00,0x00,0x00
0001dc  00000000          DCB      0x00,0x00,0x00,0x00
0001e0  00000000          DCB      0x00,0x00,0x00,0x00
0001e4  00000000          DCB      0x00,0x00,0x00,0x00
0001e8  00000000          DCB      0x00,0x00,0x00,0x00
0001ec  00000000          DCB      0x00,0x00,0x00,0x00
0001f0  00000000          DCB      0x00,0x00,0x00,0x00
0001f4  00000000          DCB      0x00,0x00,0x00,0x00
0001f8  00000000          DCB      0x00,0x00,0x00,0x00
0001fc  0000              DCB      0x00,0x00
0001fe  aa55              DCW      0xaa55
                  virtual_media_tmpl
                          DCD      read_mbr
                          DCD      write_none
                          DCD      0x00000200
                          DCD      read_fat
                          DCD      write_none
                          DCD      0x00000000
                          DCD      read_fat
                          DCD      write_none
                          DCD      0x00000000
                          DCD      read_dir
                          DCD      write_dir
                          DCD      0x00000400
                  root_dir_entry
000230  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000238  00000028          DCB      0x00,0x00,0x00,0x28
00023c  0000              DCB      0x00,0x00
00023e  0000              DCW      0x0000
000240  00000000          DCW      0x0000,0x0000
000244  00008e41          DCW      0x0000,0x8e41
000248  32bb0000          DCW      0x32bb,0x0000
                          DCD      0x00000000
                  dir_entry_tmpl
000250  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000258  00000001          DCB      0x00,0x00,0x00,0x01
00025c  0000              DCB      0x00,0x00
00025e  0000              DCW      0x0000
000260  48764876          DCW      0x4876,0x4876
000264  000083dc          DCW      0x0000,0x83dc
000268  48760000          DCW      0x4876,0x0000
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  file_count
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  file_change_cb
                          DCD      0x00000000
                  virtual_media_idx
                          DCD      0x00000000
                  fat_idx
                          DCD      0x00000000
                  dir_idx
                          DCD      0x00000000
                  data_start
                          DCD      0x00000000
