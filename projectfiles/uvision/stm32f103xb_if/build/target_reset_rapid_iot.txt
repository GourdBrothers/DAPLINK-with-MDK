; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\target_reset_rapid_iot.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\target_reset_rapid_iot.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\target_reset_rapid_iot.crf ..\..\..\source\family\freescale\target_reset_rapid_iot.c]
                          THUMB

                          AREA ||i.security_bits_set||, CODE, READONLY, ALIGN=1

                  security_bits_set PROC
;;;114    //
;;;115    static uint8_t security_bits_set(uint32_t addr, uint8_t *data, uint32_t size)
000000  f240430c          MOV      r3,#0x40c
;;;116    {
;;;117        const uint32_t fsec_addr = 0x40C;
;;;118    
;;;119        if ((addr <= fsec_addr) && (addr + size) > fsec_addr) {
000004  4298              CMP      r0,r3
000006  d80f              BHI      |L1.40|
000008  4402              ADD      r2,r2,r0
00000a  429a              CMP      r2,r3
00000c  d90c              BLS      |L1.40|
;;;120            uint8_t fsec = data[fsec_addr - addr];
00000e  1a08              SUBS     r0,r1,r0
000010  f890040c          LDRB     r0,[r0,#0x40c]
;;;121    
;;;122            // make sure we can unsecure the device or dont program at all
;;;123            if ((fsec & 0x30) == 0x20) {
000014  f3c01101          UBFX     r1,r0,#4,#2
000018  2902              CMP      r1,#2
00001a  d003              BEQ      |L1.36|
;;;124                // Dont allow programming mass-erase disabled state
;;;125                return 1;
;;;126            }
;;;127    
;;;128            // Security is OK long as we can mass-erase (comment the following out to enable target security)
;;;129            if ((fsec & 0x03) != 0x02) {
00001c  f0000003          AND      r0,r0,#3
000020  2802              CMP      r0,#2
000022  d001              BEQ      |L1.40|
                  |L1.36|
;;;130                return 1;
000024  2001              MOVS     r0,#1
;;;131            }
;;;132        }
;;;133    
;;;134        return 0;
;;;135    }
000026  4770              BX       lr
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;134
00002a  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.target_unlock_sequence||, CODE, READONLY, ALIGN=2

                  target_unlock_sequence PROC
;;;40     
;;;41     static uint8_t target_unlock_sequence(void)
000000  b538              PUSH     {r3-r5,lr}
;;;42     {
;;;43         uint32_t val;
;;;44     
;;;45         // read the device ID
;;;46         if (!swd_read_ap(MDM_IDR, &val)) {
000002  4669              MOV      r1,sp
000004  4816              LDR      r0,|L2.96|
000006  f7fffffe          BL       swd_read_ap
00000a  2800              CMP      r0,#0
00000c  d027              BEQ      |L2.94|
;;;47             return 0;
;;;48         }
;;;49         /*
;;;50         // verify the result
;;;51         if (val != mdm_id) {
;;;52             return 0;
;;;53         }
;;;54         */
;;;55     
;;;56         if (!swd_read_ap(MDM_STATUS, &val)) {
00000e  f04f7580          MOV      r5,#0x1000000
000012  4669              MOV      r1,sp
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       swd_read_ap
00001a  2800              CMP      r0,#0
00001c  d01f              BEQ      |L2.94|
;;;57             return 0;
;;;58         }
;;;59     
;;;60         // flash in secured mode
;;;61         if (val & (1 << 2)) {
00001e  9800              LDR      r0,[sp,#0]
000020  0740              LSLS     r0,r0,#29
000022  d51b              BPL      |L2.92|
;;;62             // hold the device in reset
;;;63             swd_set_target_reset(1);
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       swd_set_target_reset
;;;64     
;;;65             // write the mass-erase enable bit
;;;66             if (!swd_write_ap(MDM_CTRL, 1)) {
00002a  1d2c              ADDS     r4,r5,#4
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       swd_write_ap
000034  2800              CMP      r0,#0
000036  d012              BEQ      |L2.94|
                  |L2.56|
;;;67                 return 0;
;;;68             }
;;;69     
;;;70             while (1) {
;;;71                 // wait until mass erase is started
;;;72                 if (!swd_read_ap(MDM_STATUS, &val)) {
000038  4669              MOV      r1,sp
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       swd_read_ap
000040  2800              CMP      r0,#0
000042  d00c              BEQ      |L2.94|
;;;73                     return 0;
;;;74                 }
;;;75     
;;;76                 if (val & 1) {
000044  9800              LDR      r0,[sp,#0]
000046  07c0              LSLS     r0,r0,#31
000048  d0f6              BEQ      |L2.56|
                  |L2.74|
;;;77                     break;
;;;78                 }
;;;79             }
;;;80     
;;;81             // mass erase in progress
;;;82             while (1) {
;;;83                 // keep reading until procedure is complete
;;;84                 if (!swd_read_ap(MDM_CTRL, &val)) {
00004a  4669              MOV      r1,sp
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       swd_read_ap
000052  2800              CMP      r0,#0
000054  d003              BEQ      |L2.94|
;;;85                     return 0;
;;;86                 }
;;;87     
;;;88                 if (val == 0) {
000056  9800              LDR      r0,[sp,#0]
000058  2800              CMP      r0,#0
00005a  d1f6              BNE      |L2.74|
                  |L2.92|
;;;89                     break;
;;;90                 }
;;;91             }
;;;92         }
;;;93     
;;;94         return 1;
00005c  2001              MOVS     r0,#1
                  |L2.94|
;;;95     }
00005e  bd38              POP      {r3-r5,pc}
;;;96     
                          ENDP

                  |L2.96|
                          DCD      0x010000fc

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_nxp_rapid_iot
000000  0b04              DCW      0x0b04
000002  0100              DCB      0x01,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      target_unlock_sequence
                          DCD      security_bits_set
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
