; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\circ_buf.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\circ_buf.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\circ_buf.crf ..\..\..\source\daplink\circ_buf.c]
                          THUMB

                          AREA ||i.circ_buf_count_free||, CODE, READONLY, ALIGN=1

                  circ_buf_count_free PROC
;;;97         
;;;98     uint32_t circ_buf_count_free(circ_buf_t *circ_buf)
000000  b530              PUSH     {r4,r5,lr}
;;;99     {
000002  4605              MOV      r5,r0
000004  f3ef8010          MRS      r0,PRIMASK
000008  f0000401          AND      r4,r0,#1
00000c  b672              CPSID    i
;;;100        uint32_t cnt;
;;;101        cortex_int_state_t state;
;;;102    
;;;103        state = cortex_int_get_and_disable();
;;;104    
;;;105        cnt = circ_buf->size - circ_buf_count_used(circ_buf) - 1;
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       circ_buf_count_used
000014  68a9              LDR      r1,[r5,#8]
000016  1a08              SUBS     r0,r1,r0
000018  1e40              SUBS     r0,r0,#1
00001a  2c00              CMP      r4,#0
00001c  d100              BNE      |L1.32|
00001e  b662              CPSIE    i
                  |L1.32|
;;;106    
;;;107        cortex_int_restore(state);
;;;108        return cnt;
;;;109    }
000020  bd30              POP      {r4,r5,pc}
;;;110    
                          ENDP


                          AREA ||i.circ_buf_count_used||, CODE, READONLY, ALIGN=1

                  circ_buf_count_used PROC
;;;80     
;;;81     uint32_t circ_buf_count_used(circ_buf_t *circ_buf)
000000  f3ef8110          MRS      r1,PRIMASK
000004  f0010301          AND      r3,r1,#1
000008  b672              CPSID    i
00000a  e9d01200          LDRD     r1,r2,[r0,#0]
;;;82     {
;;;83         uint32_t cnt;
;;;84         cortex_int_state_t state;
;;;85     
;;;86         state = cortex_int_get_and_disable();
;;;87     
;;;88         if (circ_buf->tail >= circ_buf->head) {
00000e  428a              CMP      r2,r1
000010  d301              BCC      |L2.22|
;;;89             cnt = circ_buf->tail - circ_buf->head;
000012  1a50              SUBS     r0,r2,r1
000014  e002              B        |L2.28|
                  |L2.22|
;;;90         } else {
;;;91             cnt = circ_buf->tail + circ_buf->size - circ_buf->head;
000016  6880              LDR      r0,[r0,#8]
000018  4410              ADD      r0,r0,r2
00001a  1a40              SUBS     r0,r0,r1
                  |L2.28|
00001c  2b00              CMP      r3,#0
00001e  d100              BNE      |L2.34|
000020  b662              CPSIE    i
                  |L2.34|
;;;92         }
;;;93     
;;;94         cortex_int_restore(state);
;;;95         return cnt;
;;;96     }
000022  4770              BX       lr
;;;97         
                          ENDP


                          AREA ||i.circ_buf_init||, CODE, READONLY, ALIGN=1

                  circ_buf_init PROC
;;;27     
;;;28     void circ_buf_init(circ_buf_t *circ_buf, uint8_t *buffer, uint32_t size)
000000  f3ef8310          MRS      r3,PRIMASK
000004  f0130f01          TST      r3,#1
000008  b672              CPSID    i
00000a  e9c02102          STRD     r2,r1,[r0,#8]
;;;29     {
;;;30         cortex_int_state_t state;
;;;31         state = cortex_int_get_and_disable();
;;;32     
;;;33         circ_buf->buf = buffer;
;;;34         circ_buf->size = size;
;;;35         circ_buf->head = 0;
00000e  f04f0100          MOV      r1,#0
;;;36         circ_buf->tail = 0;
000012  6001              STR      r1,[r0,#0]
000014  6041              STR      r1,[r0,#4]            ;29
000016  d100              BNE      |L3.26|
000018  b662              CPSIE    i                     ;29
                  |L3.26|
;;;37     
;;;38         cortex_int_restore(state);
;;;39     }
00001a  4770              BX       lr
;;;40     
                          ENDP


                          AREA ||i.circ_buf_pop||, CODE, READONLY, ALIGN=2

                  circ_buf_pop PROC
;;;58     
;;;59     uint8_t circ_buf_pop(circ_buf_t *circ_buf)
000000  b570              PUSH     {r4-r6,lr}
;;;60     {
000002  4604              MOV      r4,r0
000004  f3ef8010          MRS      r0,PRIMASK
000008  f0000501          AND      r5,r0,#1
00000c  b672              CPSID    i
00000e  e9d40100          LDRD     r0,r1,[r4,#0]
;;;61         uint8_t data;
;;;62         cortex_int_state_t state;
;;;63     
;;;64         state = cortex_int_get_and_disable();
;;;65     
;;;66         // Assert buffer isn't empty
;;;67         util_assert(circ_buf->head != circ_buf->tail);
000012  4288              CMP      r0,r1
000014  d001              BEQ      |L4.26|
000016  2001              MOVS     r0,#1
000018  e000              B        |L4.28|
                  |L4.26|
00001a  2000              MOVS     r0,#0
                  |L4.28|
00001c  2243              MOVS     r2,#0x43
00001e  a10e              ADR      r1,|L4.88|
000020  f7fffffe          BL       _util_assert
;;;68     
;;;69         data = circ_buf->buf[circ_buf->head];
000024  68e1              LDR      r1,[r4,#0xc]
000026  6820              LDR      r0,[r4,#0]
000028  5c0e              LDRB     r6,[r1,r0]
00002a  1c40              ADDS     r0,r0,#1
;;;70         circ_buf->head += 1;
;;;71         if (circ_buf->head >= circ_buf->size) {
00002c  6020              STR      r0,[r4,#0]
00002e  68a1              LDR      r1,[r4,#8]
000030  4288              CMP      r0,r1
000032  d30c              BCC      |L4.78|
;;;72             util_assert(circ_buf->head == circ_buf->size);
000034  d102              BNE      |L4.60|
000036  f04f0001          MOV      r0,#1
00003a  e001              B        |L4.64|
                  |L4.60|
00003c  f04f0000          MOV      r0,#0
                  |L4.64|
000040  f04f0248          MOV      r2,#0x48
000044  a104              ADR      r1,|L4.88|
000046  f7fffffe          BL       _util_assert
;;;73             circ_buf->head = 0;
00004a  2000              MOVS     r0,#0
00004c  6020              STR      r0,[r4,#0]
                  |L4.78|
00004e  b905              CBNZ     r5,|L4.82|
000050  b662              CPSIE    i
                  |L4.82|
;;;74         }
;;;75     
;;;76         cortex_int_restore(state);
;;;77         
;;;78         return data;
000052  4630              MOV      r0,r6
;;;79     }
000054  bd70              POP      {r4-r6,pc}
;;;80     
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
000058  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\circ_buf.c",0
00005c  2e5c2e2e
000060  5c736f75
000064  7263655c
000068  6461706c
00006c  696e6b5c
000070  63697263
000074  5f627566
000078  2e6300  
00007b  00                DCB      0

                          AREA ||i.circ_buf_push||, CODE, READONLY, ALIGN=2

                  circ_buf_push PROC
;;;40     
;;;41     void circ_buf_push(circ_buf_t *circ_buf, uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;42     {
000002  4604              MOV      r4,r0
000004  f3ef8010          MRS      r0,PRIMASK
000008  f0000501          AND      r5,r0,#1
00000c  b672              CPSID    i
;;;43         cortex_int_state_t state;
;;;44         state = cortex_int_get_and_disable();
;;;45     
;;;46         circ_buf->buf[circ_buf->tail] = data;
00000e  6862              LDR      r2,[r4,#4]
000010  68e0              LDR      r0,[r4,#0xc]
000012  5481              STRB     r1,[r0,r2]
;;;47         circ_buf->tail += 1;
000014  6860              LDR      r0,[r4,#4]
000016  1c40              ADDS     r0,r0,#1
;;;48         if (circ_buf->tail >= circ_buf->size) {
000018  6060              STR      r0,[r4,#4]
00001a  68a1              LDR      r1,[r4,#8]
00001c  4288              CMP      r0,r1
00001e  d30c              BCC      |L5.58|
;;;49             util_assert(circ_buf->tail == circ_buf->size);
000020  d102              BNE      |L5.40|
000022  f04f0001          MOV      r0,#1
000026  e001              B        |L5.44|
                  |L5.40|
000028  f04f0000          MOV      r0,#0
                  |L5.44|
00002c  f04f0231          MOV      r2,#0x31
000030  a109              ADR      r1,|L5.88|
000032  f7fffffe          BL       _util_assert
;;;50             circ_buf->tail = 0;
000036  2000              MOVS     r0,#0
000038  6060              STR      r0,[r4,#4]
                  |L5.58|
00003a  e9d40100          LDRD     r0,r1,[r4,#0]
;;;51         }
;;;52     
;;;53         // Assert no overflow
;;;54         util_assert(circ_buf->head != circ_buf->tail);
00003e  4288              CMP      r0,r1
000040  d001              BEQ      |L5.70|
000042  2001              MOVS     r0,#1
000044  e000              B        |L5.72|
                  |L5.70|
000046  2000              MOVS     r0,#0
                  |L5.72|
000048  2236              MOVS     r2,#0x36
00004a  a103              ADR      r1,|L5.88|
00004c  f7fffffe          BL       _util_assert
000050  2d00              CMP      r5,#0
000052  d100              BNE      |L5.86|
000054  b662              CPSIE    i
                  |L5.86|
;;;55     
;;;56         cortex_int_restore(state);
;;;57     }
000056  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

                  |L5.88|
000058  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\circ_buf.c",0
00005c  2e5c2e2e
000060  5c736f75
000064  7263655c
000068  6461706c
00006c  696e6b5c
000070  63697263
000074  5f627566
000078  2e6300  
00007b  00                DCB      0

                          AREA ||i.circ_buf_read||, CODE, READONLY, ALIGN=1

                  circ_buf_read PROC
;;;110    
;;;111    uint32_t circ_buf_read(circ_buf_t *circ_buf, uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;112    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;113        uint32_t cnt;
;;;114        uint32_t i;
;;;115    
;;;116        cnt = circ_buf_count_used(circ_buf);
00000a  f7fffffe          BL       circ_buf_count_used
;;;117        cnt = MIN(size, cnt);
00000e  4284              CMP      r4,r0
000010  d200              BCS      |L6.20|
000012  4620              MOV      r0,r4
                  |L6.20|
000014  4605              MOV      r5,r0
;;;118        for (i = 0; i < cnt; i++) {
000016  2400              MOVS     r4,#0
000018  e004              B        |L6.36|
                  |L6.26|
;;;119            data[i] = circ_buf_pop(circ_buf);
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       circ_buf_pop
000020  5530              STRB     r0,[r6,r4]
000022  1c64              ADDS     r4,r4,#1
                  |L6.36|
000024  42ac              CMP      r4,r5                 ;118
000026  d3f8              BCC      |L6.26|
;;;120        }
;;;121    
;;;122        return cnt;
000028  4628              MOV      r0,r5
;;;123    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;124    
                          ENDP


                          AREA ||i.circ_buf_write||, CODE, READONLY, ALIGN=1

                  circ_buf_write PROC
;;;124    
;;;125    uint32_t circ_buf_write(circ_buf_t *circ_buf, const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;126    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;127        uint32_t cnt;
;;;128        uint32_t i;
;;;129    
;;;130        cnt = circ_buf_count_free(circ_buf);
00000a  f7fffffe          BL       circ_buf_count_free
;;;131        cnt = MIN(size, cnt);
00000e  4284              CMP      r4,r0
000010  d200              BCS      |L7.20|
000012  4620              MOV      r0,r4
                  |L7.20|
000014  4605              MOV      r5,r0
;;;132        for (i = 0; i < cnt; i++) {
000016  2400              MOVS     r4,#0
000018  e004              B        |L7.36|
                  |L7.26|
;;;133            circ_buf_push(circ_buf, data[i]);
00001a  5d31              LDRB     r1,[r6,r4]
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       circ_buf_push
000022  1c64              ADDS     r4,r4,#1
                  |L7.36|
000024  42ac              CMP      r4,r5                 ;132
000026  d3f8              BCC      |L7.26|
;;;134        }
;;;135    
;;;136        return cnt;
000028  4628              MOV      r0,r5
;;;137    }
00002a  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\circ_buf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_circ_buf_c_9783ab12____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___10_circ_buf_c_9783ab12____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_circ_buf_c_9783ab12____REVSH|
#line 144
|__asm___10_circ_buf_c_9783ab12____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
