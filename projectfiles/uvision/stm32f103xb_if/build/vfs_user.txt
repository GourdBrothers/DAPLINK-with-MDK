; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\vfs_user.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\vfs_user.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\vfs_user.crf ..\..\..\source\daplink\drag-n-drop\vfs_user.c]
                          THUMB

                          AREA ||i.expand_info||, CODE, READONLY, ALIGN=2

                  expand_info PROC
;;;460    // expanding the special characters in mbed_redirect_file.
;;;461    static uint32_t expand_info(uint8_t *buf, uint32_t bufsize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;462    {
000004  4689              MOV      r9,r1
000006  4604              MOV      r4,r0
;;;463        uint8_t *orig_buf = buf;
000008  4680              MOV      r8,r0
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  1c64              ADDS     r4,r4,#1              ;462
                  |L1.14|
;;;464        uint8_t *insert_string;
;;;465    
;;;466        do {
;;;467            // Look for key or the end of the string
;;;468            while ((*buf != '@') && (*buf != 0)) {
00000e  7820              LDRB     r0,[r4,#0]
000010  2840              CMP      r0,#0x40
000012  d002              BEQ      |L1.26|
000014  2800              CMP      r0,#0
000016  d1f9              BNE      |L1.12|
000018  e063              B        |L1.226|
                  |L1.26|
;;;469                buf++;
;;;470            }
;;;471    
;;;472            // If key was found then replace it
;;;473            if ('@' == *buf) {
;;;474                switch (*(buf + 1)) {
00001a  7860              LDRB     r0,[r4,#1]
00001c  2862              CMP      r0,#0x62
00001e  d047              BEQ      |L1.176|
000020  dc12              BGT      |L1.72|
000022  2852              CMP      r0,#0x52
000024  d053              BEQ      |L1.206|
000026  dc08              BGT      |L1.58|
000028  2842              CMP      r0,#0x42
00002a  d041              BEQ      |L1.176|
00002c  2844              CMP      r0,#0x44
00002e  d048              BEQ      |L1.194|
000030  2848              CMP      r0,#0x48
000032  d040              BEQ      |L1.182|
000034  284d              CMP      r0,#0x4d
000036  d117              BNE      |L1.104|
000038  e033              B        |L1.162|
                  |L1.58|
00003a  2854              CMP      r0,#0x54
00003c  d03e              BEQ      |L1.188|
00003e  2855              CMP      r0,#0x55
000040  d032              BEQ      |L1.168|
000042  2856              CMP      r0,#0x56
000044  d110              BNE      |L1.104|
000046  e03f              B        |L1.200|
                  |L1.72|
000048  2872              CMP      r0,#0x72
00004a  d040              BEQ      |L1.206|
00004c  dc06              BGT      |L1.92|
00004e  2864              CMP      r0,#0x64
000050  d037              BEQ      |L1.194|
000052  2868              CMP      r0,#0x68
000054  d02f              BEQ      |L1.182|
000056  286d              CMP      r0,#0x6d
000058  d106              BNE      |L1.104|
00005a  e022              B        |L1.162|
                  |L1.92|
00005c  2874              CMP      r0,#0x74
00005e  d02d              BEQ      |L1.188|
000060  2875              CMP      r0,#0x75
000062  d021              BEQ      |L1.168|
000064  2876              CMP      r0,#0x76
000066  d02f              BEQ      |L1.200|
                  |L1.104|
;;;475                    case 'm':
;;;476                    case 'M':   // MAC address
;;;477                        insert_string = (uint8_t *)info_get_mac();
;;;478                        break;
;;;479    
;;;480                    case 'u':
;;;481                    case 'U':   // UUID
;;;482                        insert_string = (uint8_t *)info_get_unique_id();
;;;483                        break;
;;;484    
;;;485                    case 'b':
;;;486                    case 'B':   // Board ID
;;;487                        insert_string = (uint8_t *)info_get_board_id();
;;;488                        break;
;;;489    
;;;490                    case 'h':
;;;491                    case 'H':   // Host ID
;;;492                        insert_string = (uint8_t *)info_get_host_id();
;;;493                        break;
;;;494    
;;;495                    case 't':
;;;496                    case 'T':   // Target ID
;;;497                        insert_string = (uint8_t *)info_get_target_id();
;;;498                        break;
;;;499    
;;;500                    case 'd':
;;;501                    case 'D':   // HIC
;;;502                        insert_string = (uint8_t *)info_get_hic_id();
;;;503                        break;
;;;504    
;;;505                    case 'v':
;;;506                    case 'V':   // Firmware version
;;;507                        insert_string = (uint8_t *)info_get_version();
;;;508                        break;
;;;509    
;;;510                    case 'r':
;;;511                    case 'R':   // URL replacement
;;;512                        insert_string = (uint8_t *)get_daplink_target_url();
;;;513                        break;
;;;514    
;;;515                    default:
;;;516                        insert_string = (uint8_t *)"ERROR";
000068  a520              ADR      r5,|L1.236|
                  |L1.106|
;;;517                        break;
;;;518                }
;;;519    
;;;520                // Remove strip_count characters from the start of buf and then insert
;;;521                // insert_string at the new start of buf.
;;;522                uint32_t buf_len = strlen((const char *)buf);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       strlen
000070  4607              MOV      r7,r0
;;;523                uint32_t str_len = strlen((const char *)insert_string);
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       strlen
000078  4606              MOV      r6,r0
;;;524                //buffer overflow check on insert
;;;525                if( (buf + str_len + buf_len - 2) < (orig_buf+bufsize)){
00007a  19a0              ADDS     r0,r4,r6
00007c  19c1              ADDS     r1,r0,r7
00007e  eb080209          ADD      r2,r8,r9
000082  1e89              SUBS     r1,r1,#2
000084  4291              CMP      r1,r2
000086  d22b              BCS      |L1.224|
;;;526                    // push out string
;;;527                    memmove(buf + str_len, buf + 2, buf_len - 2);
000088  1eba              SUBS     r2,r7,#2
00008a  1ca1              ADDS     r1,r4,#2
00008c  f7fffffe          BL       __aeabi_memmove
;;;528                    // insert
;;;529                    memcpy(buf, insert_string, str_len);
000090  4632              MOV      r2,r6
000092  4629              MOV      r1,r5
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       __aeabi_memcpy
;;;530                }else{
;;;531                    //stop the string expansion and leave as it is
;;;532                    buf += buf_len;
;;;533                    break;
;;;534                }
;;;535    
;;;536            }
;;;537        } while (*buf != '\0');
00009a  7820              LDRB     r0,[r4,#0]
00009c  2800              CMP      r0,#0                 ;529
00009e  d1b6              BNE      |L1.14|
0000a0  e01f              B        |L1.226|
                  |L1.162|
0000a2  f7fffffe          BL       info_get_mac
0000a6  e001              B        |L1.172|
                  |L1.168|
0000a8  f7fffffe          BL       info_get_unique_id
                  |L1.172|
0000ac  4605              MOV      r5,r0                 ;477
0000ae  e7dc              B        |L1.106|
                  |L1.176|
0000b0  f7fffffe          BL       info_get_board_id
0000b4  e7fa              B        |L1.172|
                  |L1.182|
0000b6  f7fffffe          BL       info_get_host_id
0000ba  e7f7              B        |L1.172|
                  |L1.188|
0000bc  f7fffffe          BL       info_get_target_id
0000c0  e7f4              B        |L1.172|
                  |L1.194|
0000c2  f7fffffe          BL       info_get_hic_id
0000c6  e7f1              B        |L1.172|
                  |L1.200|
0000c8  f7fffffe          BL       info_get_version
0000cc  e7ee              B        |L1.172|
                  |L1.206|
0000ce  4809              LDR      r0,|L1.244|
0000d0  f890002a          LDRB     r0,[r0,#0x2a]         ;508  ; g_board_info
0000d4  b110              CBZ      r0,|L1.220|
0000d6  4d07              LDR      r5,|L1.244|
0000d8  352a              ADDS     r5,r5,#0x2a           ;508
0000da  e7c6              B        |L1.106|
                  |L1.220|
0000dc  a506              ADR      r5,|L1.248|
0000de  e7c4              B        |L1.106|
                  |L1.224|
0000e0  443c              ADD      r4,r4,r7              ;532
                  |L1.226|
;;;538    
;;;539        return (buf - orig_buf);
0000e2  eba40008          SUB      r0,r4,r8
;;;540    }
0000e6  e8bd87f0          POP      {r4-r10,pc}
;;;541    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L1.236|
0000ec  4552524f          DCB      "ERROR",0
0000f0  5200    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L1.244|
                          DCD      g_board_info
                  |L1.248|
0000f8  68747470          DCB      "https://mbed.org/device/?code=@U?version=@V?target_id=@"
0000fc  733a2f2f
000100  6d626564
000104  2e6f7267
000108  2f646576
00010c  6963652f
000110  3f636f64
000114  653d4055
000118  3f766572
00011c  73696f6e
000120  3d40563f
000124  74617267
000128  65745f69
00012c  643d40  
00012f  5400              DCB      "T",0
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0

                          AREA ||i.get_file_size||, CODE, READONLY, ALIGN=2

                  get_file_size PROC
;;;212    // The file data must be null terminated for this to work correctly.
;;;213    static uint32_t get_file_size(vfs_read_cb_t read_func)
000000  4603              MOV      r3,r0
;;;214    {
;;;215        // Determine size of the file by faking a read
;;;216        return read_func(0, file_buffer, 1);
000002  2201              MOVS     r2,#1
000004  4901              LDR      r1,|L2.12|
000006  2000              MOVS     r0,#0
000008  4718              BX       r3
;;;217    }
;;;218    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.read_file_assert_txt||, CODE, READONLY, ALIGN=2

                  read_file_assert_txt PROC
;;;288    // File callback to be used with vfs_add_file to return file contents
;;;289    static uint32_t read_file_assert_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;290    {
000004  460c              MOV      r4,r1
;;;291        uint32_t pos;
;;;292        const char *source_str;
;;;293        char *buf = (char *)data;
;;;294        uint32_t * hexdumps = 0;
000006  2100              MOVS     r1,#0
;;;295        uint8_t valid_hexdumps = 0;
;;;296        uint8_t index = 0;
000008  460e              MOV      r6,r1
00000a  9100              STR      r1,[sp,#0]            ;290
00000c  b110              CBZ      r0,|L3.20|
;;;297        
;;;298        if (sector_offset != 0) {
;;;299            return 0;
00000e  2000              MOVS     r0,#0
                  |L3.16|
;;;300        }
;;;301    
;;;302        pos = 0;
;;;303    
;;;304        if (ASSERT_SOURCE_BL == assert_source) {
;;;305            source_str = "Bootloader";
;;;306        } else if (ASSERT_SOURCE_APP == assert_source) {
;;;307            source_str = "Application";
;;;308        } else {
;;;309            source_str = 0;
;;;310        }
;;;311    
;;;312        pos += util_write_string(buf + pos, "Assert\r\n");
;;;313        pos += util_write_string(buf + pos, "File: ");
;;;314        pos += util_write_string(buf + pos, assert_buf);
;;;315        pos += util_write_string(buf + pos, "\r\n");
;;;316        pos += util_write_string(buf + pos, "Line: ");
;;;317        pos += util_write_uint32(buf + pos, assert_line);
;;;318        pos += util_write_string(buf + pos, "\r\n");
;;;319    
;;;320        if (source_str != 0) {
;;;321            pos += util_write_string(buf + pos, "Source: ");
;;;322            pos += util_write_string(buf + pos, source_str);
;;;323            pos += util_write_string(buf + pos, "\r\n");
;;;324        }
;;;325    
;;;326        valid_hexdumps = config_ram_get_hexdumps(&hexdumps);
;;;327        if ((valid_hexdumps > 0) && (hexdumps != 0)) {
;;;328            //print hexdumps
;;;329            pos += util_write_string(buf + pos, "Hexdumps\r\n");
;;;330            while ((index < valid_hexdumps) && ((pos + 10) < VFS_SECTOR_SIZE)) { //hexdumps + newline is always 10 characters
;;;331                pos += util_write_hex32(buf + pos, hexdumps[index++]);
;;;332                pos += util_write_string(buf + pos, "\r\n");
;;;333            }
;;;334        }
;;;335        
;;;336        return pos;
;;;337    }
000010  e8bd83f8          POP      {r3-r9,pc}
                  |L3.20|
000014  f8df80c8          LDR      r8,|L3.224|
000018  f8980000          LDRB     r0,[r8,#0]            ;304  ; assert_source
00001c  2801              CMP      r0,#1                 ;304
00001e  d045              BEQ      |L3.172|
000020  2802              CMP      r0,#2                 ;306
000022  d045              BEQ      |L3.176|
000024  2700              MOVS     r7,#0                 ;309
                  |L3.38|
000026  4620              MOV      r0,r4                 ;312
000028  a12e              ADR      r1,|L3.228|
00002a  f7fffffe          BL       util_write_string
00002e  4605              MOV      r5,r0                 ;312
000030  1960              ADDS     r0,r4,r5              ;313
000032  a12f              ADR      r1,|L3.240|
000034  f7fffffe          BL       util_write_string
000038  4405              ADD      r5,r5,r0              ;313
00003a  1960              ADDS     r0,r4,r5              ;314
00003c  492e              LDR      r1,|L3.248|
00003e  f7fffffe          BL       util_write_string
000042  4405              ADD      r5,r5,r0              ;314
000044  1960              ADDS     r0,r4,r5              ;315
000046  a12d              ADR      r1,|L3.252|
000048  f7fffffe          BL       util_write_string
00004c  4405              ADD      r5,r5,r0              ;315
00004e  1960              ADDS     r0,r4,r5              ;316
000050  a12b              ADR      r1,|L3.256|
000052  f7fffffe          BL       util_write_string
000056  4405              ADD      r5,r5,r0              ;316
000058  1960              ADDS     r0,r4,r5              ;317
00005a  f8b81002          LDRH     r1,[r8,#2]            ;317  ; assert_line
00005e  f7fffffe          BL       util_write_uint32
000062  4405              ADD      r5,r5,r0              ;317
000064  1960              ADDS     r0,r4,r5              ;318
000066  a125              ADR      r1,|L3.252|
000068  f7fffffe          BL       util_write_string
00006c  4405              ADD      r5,r5,r0              ;318
00006e  b177              CBZ      r7,|L3.142|
000070  1960              ADDS     r0,r4,r5              ;321
000072  a125              ADR      r1,|L3.264|
000074  f7fffffe          BL       util_write_string
000078  4405              ADD      r5,r5,r0              ;321
00007a  1960              ADDS     r0,r4,r5              ;322
00007c  4639              MOV      r1,r7                 ;322
00007e  f7fffffe          BL       util_write_string
000082  4405              ADD      r5,r5,r0              ;322
000084  1960              ADDS     r0,r4,r5              ;323
000086  a11d              ADR      r1,|L3.252|
000088  f7fffffe          BL       util_write_string
00008c  4405              ADD      r5,r5,r0              ;323
                  |L3.142|
00008e  4668              MOV      r0,sp                 ;326
000090  f7fffffe          BL       config_ram_get_hexdumps
000094  0007              MOVS     r7,r0                 ;326
000096  d021              BEQ      |L3.220|
000098  9800              LDR      r0,[sp,#0]            ;327
00009a  b1f8              CBZ      r0,|L3.220|
00009c  1960              ADDS     r0,r4,r5              ;329
00009e  a11d              ADR      r1,|L3.276|
0000a0  f7fffffe          BL       util_write_string
0000a4  4405              ADD      r5,r5,r0              ;329
0000a6  f44f7800          MOV      r8,#0x200             ;330
0000aa  e011              B        |L3.208|
                  |L3.172|
0000ac  a71c              ADR      r7,|L3.288|
0000ae  e7ba              B        |L3.38|
                  |L3.176|
0000b0  a71e              ADR      r7,|L3.300|
0000b2  e7b8              B        |L3.38|
                  |L3.180|
0000b4  9800              LDR      r0,[sp,#0]            ;331
0000b6  f8501026          LDR      r1,[r0,r6,LSL #2]     ;331
0000ba  1c76              ADDS     r6,r6,#1              ;331
0000bc  b2f6              UXTB     r6,r6                 ;331
0000be  1960              ADDS     r0,r4,r5              ;331
0000c0  f7fffffe          BL       util_write_hex32
0000c4  4405              ADD      r5,r5,r0              ;331
0000c6  1960              ADDS     r0,r4,r5              ;332
0000c8  a10c              ADR      r1,|L3.252|
0000ca  f7fffffe          BL       util_write_string
0000ce  4405              ADD      r5,r5,r0              ;332
                  |L3.208|
0000d0  42be              CMP      r6,r7                 ;330
0000d2  d203              BCS      |L3.220|
0000d4  f105000a          ADD      r0,r5,#0xa            ;330
0000d8  4540              CMP      r0,r8                 ;330
0000da  d3eb              BCC      |L3.180|
                  |L3.220|
0000dc  4628              MOV      r0,r5                 ;336
0000de  e797              B        |L3.16|
;;;338    
                          ENDP

                  |L3.224|
                          DCD      ||.data||
                  |L3.228|
0000e4  41737365          DCB      "Assert\r\n",0
0000e8  72740d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L3.240|
0000f0  46696c65          DCB      "File: ",0
0000f4  3a2000  
0000f7  00                DCB      0
                  |L3.248|
                          DCD      ||.bss||+0x200
                  |L3.252|
0000fc  0d0a00            DCB      "\r\n",0
0000ff  00                DCB      0
                  |L3.256|
000100  4c696e65          DCB      "Line: ",0
000104  3a2000  
000107  00                DCB      0
                  |L3.264|
000108  536f7572          DCB      "Source: ",0
00010c  63653a20
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L3.276|
000114  48657864          DCB      "Hexdumps\r\n",0
000118  756d7073
00011c  0d0a00  
00011f  00                DCB      0
                  |L3.288|
000120  426f6f74          DCB      "Bootloader",0
000124  6c6f6164
000128  657200  
00012b  00                DCB      0
                  |L3.300|
00012c  4170706c          DCB      "Application",0
000130  69636174
000134  696f6e00

                          AREA ||i.read_file_details_txt||, CODE, READONLY, ALIGN=1

                  read_file_details_txt PROC
;;;229    // File callback to be used with vfs_add_file to return file contents
;;;230    static uint32_t read_file_details_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  460a              MOV      r2,r1
;;;231    {
000002  b108              CBZ      r0,|L4.8|
;;;232    
;;;233        if (sector_offset != 0) {
;;;234            return 0;
000004  2000              MOVS     r0,#0
;;;235        }
;;;236    
;;;237        return update_details_txt_file(data, VFS_SECTOR_SIZE);
;;;238    }
000006  4770              BX       lr
                  |L4.8|
000008  f44f7100          MOV      r1,#0x200             ;237
00000c  4610              MOV      r0,r2                 ;237
00000e  f7ffbffe          B.W      update_details_txt_file
;;;239    
                          ENDP


                          AREA ||i.read_file_fail_txt||, CODE, READONLY, ALIGN=2

                  read_file_fail_txt PROC
;;;251    // File callback to be used with vfs_add_file to return file contents
;;;252    static uint32_t read_file_fail_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;253    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;254        uint32_t size = 0;
;;;255        char *buf = (char *)data;
;;;256        error_t status = vfs_mngr_get_transfer_status();
000008  f7fffffe          BL       vfs_mngr_get_transfer_status
00000c  4606              MOV      r6,r0
;;;257        const char *contents = error_get_string(status);
00000e  f7fffffe          BL       error_get_string
000012  4607              MOV      r7,r0
;;;258        error_type_t type = error_get_type(status);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       error_get_type
00001a  4606              MOV      r6,r0
;;;259    
;;;260        if (sector_offset != 0) {
00001c  b114              CBZ      r4,|L5.36|
;;;261            return 0;
00001e  2000              MOVS     r0,#0
                  |L5.32|
;;;262        }
;;;263    
;;;264        size += util_write_string(buf + size, error_prefix);
;;;265        size += util_write_string(buf + size, contents);
;;;266        size += util_write_string(buf + size, "\r\n");
;;;267        size += util_write_string(buf + size, error_type_prefix);
;;;268    
;;;269        // Write each applicable error type, separated by commas
;;;270        int index = 0;
;;;271        bool first = true;
;;;272        while (type && index < ARRAY_SIZE(error_type_names)) {
;;;273            if (!first) {
;;;274                size += util_write_string(buf + size, ", ");
;;;275            }
;;;276            if (type & 1) {
;;;277                size += util_write_string(buf + size, error_type_names[index]);
;;;278                first = false;
;;;279            }
;;;280            index++;
;;;281            type >>= 1;
;;;282        }
;;;283    
;;;284        size += util_write_string(buf + size, "\r\n");
;;;285        return size;
;;;286    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L5.36|
000024  4628              MOV      r0,r5                 ;264
000026  491b              LDR      r1,|L5.148|
000028  f7fffffe          BL       util_write_string
00002c  4604              MOV      r4,r0                 ;264
00002e  1928              ADDS     r0,r5,r4              ;265
000030  4639              MOV      r1,r7                 ;265
000032  f7fffffe          BL       util_write_string
000036  4404              ADD      r4,r4,r0              ;265
000038  1928              ADDS     r0,r5,r4              ;266
00003a  a117              ADR      r1,|L5.152|
00003c  f7fffffe          BL       util_write_string
000040  4914              LDR      r1,|L5.148|
000042  4404              ADD      r4,r4,r0              ;266
000044  1928              ADDS     r0,r5,r4              ;267
000046  1fc9              SUBS     r1,r1,#7              ;267
000048  f7fffffe          BL       util_write_string
00004c  4404              ADD      r4,r4,r0              ;267
00004e  2700              MOVS     r7,#0                 ;270
000050  f04f0801          MOV      r8,#1                 ;271
000054  f8df9044          LDR      r9,|L5.156|
000058  e013              B        |L5.130|
                  |L5.90|
00005a  f1b80f00          CMP      r8,#0                 ;273
00005e  d104              BNE      |L5.106|
000060  1928              ADDS     r0,r5,r4              ;274
000062  a10f              ADR      r1,|L5.160|
000064  f7fffffe          BL       util_write_string
000068  4404              ADD      r4,r4,r0              ;274
                  |L5.106|
00006a  07f0              LSLS     r0,r6,#31             ;276
00006c  d007              BEQ      |L5.126|
00006e  f8591027          LDR      r1,[r9,r7,LSL #2]     ;277
000072  1928              ADDS     r0,r5,r4              ;277
000074  f7fffffe          BL       util_write_string
000078  4404              ADD      r4,r4,r0              ;277
00007a  f04f0800          MOV      r8,#0                 ;278
                  |L5.126|
00007e  0876              LSRS     r6,r6,#1              ;281
000080  1c7f              ADDS     r7,r7,#1              ;281
                  |L5.130|
000082  b10e              CBZ      r6,|L5.136|
000084  2f05              CMP      r7,#5                 ;272
000086  d3e8              BCC      |L5.90|
                  |L5.136|
000088  1928              ADDS     r0,r5,r4              ;284
00008a  a103              ADR      r1,|L5.152|
00008c  f7fffffe          BL       util_write_string
000090  4420              ADD      r0,r0,r4              ;284
000092  e7c5              B        |L5.32|
;;;287    
                          ENDP

                  |L5.148|
                          DCD      ||.constdata||+0x7
                  |L5.152|
000098  0d0a00            DCB      "\r\n",0
00009b  00                DCB      0
                  |L5.156|
                          DCD      ||.constdata||+0x110
                  |L5.160|
0000a0  2c2000            DCB      ", ",0
0000a3  00                DCB      0

                          AREA ||i.read_file_mbed_htm||, CODE, READONLY, ALIGN=2

                  read_file_mbed_htm PROC
;;;219    // File callback to be used with vfs_add_file to return file contents
;;;220    static uint32_t read_file_mbed_htm(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  b570              PUSH     {r4-r6,lr}
;;;221    {
000002  460c              MOV      r4,r1
000004  b108              CBZ      r0,|L6.10|
;;;222        if (sector_offset != 0) {
;;;223            return 0;
000006  2000              MOVS     r0,#0
;;;224        }
;;;225    
;;;226        return update_html_file(data, VFS_SECTOR_SIZE);
;;;227    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  f44f7500          MOV      r5,#0x200             ;226
00000e  4629              MOV      r1,r5                 ;226
000010  4620              MOV      r0,r4                 ;226
000012  f7fffffe          BL       __aeabi_memclr
000016  4807              LDR      r0,|L6.52|
000018  f7fffffe          BL       strlen
00001c  4602              MOV      r2,r0                 ;226
00001e  4905              LDR      r1,|L6.52|
000020  4620              MOV      r0,r4                 ;226
000022  f7fffffe          BL       __aeabi_memcpy
000026  4629              MOV      r1,r5                 ;226
000028  4620              MOV      r0,r4                 ;226
00002a  e8bd4070          POP      {r4-r6,lr}            ;226
00002e  f7ffbffe          B.W      expand_info
;;;228    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      ||.constdata||+0xf

                          AREA ||i.read_file_need_bl_txt||, CODE, READONLY, ALIGN=2

                  read_file_need_bl_txt PROC
;;;339    // File callback to be used with vfs_add_file to return file contents
;;;340    static uint32_t read_file_need_bl_txt(uint32_t sector_offset, uint8_t *data, uint32_t num_sectors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;341    {
;;;342        const char *contents = "A bootloader update was started but unable to complete.\r\n"
000004  4d08              LDR      r5,|L7.40|
000006  4606              MOV      r6,r0                 ;341
000008  460f              MOV      r7,r1                 ;341
;;;343                               "Reload the bootloader to fix this error message.\r\n";
;;;344        uint32_t size = strlen(contents);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       strlen
000010  4604              MOV      r4,r0
;;;345    
;;;346        if (sector_offset != 0) {
000012  b116              CBZ      r6,|L7.26|
;;;347            return 0;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;348        }
;;;349    
;;;350        memcpy(data, contents, size);
;;;351        return size;
;;;352    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  4602              MOV      r2,r0                 ;350
00001c  4629              MOV      r1,r5                 ;350
00001e  4638              MOV      r0,r7                 ;350
000020  f7fffffe          BL       __aeabi_memcpy
000024  4620              MOV      r0,r4                 ;351
000026  e7f6              B        |L7.22|
;;;353    
                          ENDP

                  |L7.40|
                          DCD      ||.conststring||+0x34

                          AREA ||i.update_details_txt_file||, CODE, READONLY, ALIGN=2

                  update_details_txt_file PROC
;;;364    
;;;365    static uint32_t update_details_txt_file(uint8_t *data, uint32_t datasize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;366    {
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;367        uint32_t pos=0;
;;;368        const char *mode_str;
;;;369    
;;;370        char *buf = (char *)data;
;;;371    
;;;372        //Needed by expand_info strlen
;;;373        memset(buf, 0, datasize);
000008  f7fffffe          BL       __aeabi_memclr
;;;374    
;;;375        pos += util_write_string(buf + pos, "# DAPLink Firmware - see https://mbed.com/daplink\r\n");
00000c  4620              MOV      r0,r4
00000e  a18a              ADR      r1,|L8.568|
000010  f7fffffe          BL       util_write_string
000014  4605              MOV      r5,r0
;;;376        // Unique ID
;;;377        pos += util_write_string(buf + pos, "Unique ID: @U\r\n");
000016  1960              ADDS     r0,r4,r5
000018  a194              ADR      r1,|L8.620|
00001a  f7fffffe          BL       util_write_string
00001e  4405              ADD      r5,r5,r0
;;;378        // HIC ID
;;;379        pos += util_write_string(buf + pos, "HIC ID: @D\r\n");
000020  1960              ADDS     r0,r4,r5
000022  a196              ADR      r1,|L8.636|
000024  f7fffffe          BL       util_write_string
000028  4405              ADD      r5,r5,r0
;;;380        // Settings
;;;381        pos += util_write_string(buf + pos, "Auto Reset: ");
00002a  1960              ADDS     r0,r4,r5
00002c  a197              ADR      r1,|L8.652|
00002e  f7fffffe          BL       util_write_string
000032  4405              ADD      r5,r5,r0
;;;382        pos += util_write_string(buf + pos, config_get_auto_rst() ? "1" : "0");
000034  f7fffffe          BL       config_get_auto_rst
000038  b108              CBZ      r0,|L8.62|
00003a  a198              ADR      r1,|L8.668|
00003c  e000              B        |L8.64|
                  |L8.62|
00003e  a198              ADR      r1,|L8.672|
                  |L8.64|
000040  1960              ADDS     r0,r4,r5
000042  f7fffffe          BL       util_write_string
000046  4405              ADD      r5,r5,r0
;;;383        pos += util_write_string(buf + pos, "\r\n");
000048  1960              ADDS     r0,r4,r5
00004a  a196              ADR      r1,|L8.676|
00004c  f7fffffe          BL       util_write_string
000050  4405              ADD      r5,r5,r0
;;;384        pos += util_write_string(buf + pos, "Automation allowed: ");
000052  1960              ADDS     r0,r4,r5
000054  a194              ADR      r1,|L8.680|
000056  f7fffffe          BL       util_write_string
00005a  4405              ADD      r5,r5,r0
;;;385        pos += util_write_string(buf + pos, config_get_automation_allowed() ? "1" : "0");
00005c  f7fffffe          BL       config_get_automation_allowed
000060  b108              CBZ      r0,|L8.102|
000062  a18e              ADR      r1,|L8.668|
000064  e000              B        |L8.104|
                  |L8.102|
000066  a18e              ADR      r1,|L8.672|
                  |L8.104|
000068  1960              ADDS     r0,r4,r5
00006a  f7fffffe          BL       util_write_string
00006e  4405              ADD      r5,r5,r0
;;;386        pos += util_write_string(buf + pos, "\r\n");
000070  1960              ADDS     r0,r4,r5
000072  a18c              ADR      r1,|L8.676|
000074  f7fffffe          BL       util_write_string
000078  4405              ADD      r5,r5,r0
;;;387        pos += util_write_string(buf + pos, "Overflow detection: ");
00007a  1960              ADDS     r0,r4,r5
00007c  a190              ADR      r1,|L8.704|
00007e  f7fffffe          BL       util_write_string
000082  4405              ADD      r5,r5,r0
;;;388        pos += util_write_string(buf + pos, config_get_overflow_detect() ? "1" : "0");
000084  f7fffffe          BL       config_get_overflow_detect
000088  b108              CBZ      r0,|L8.142|
00008a  a184              ADR      r1,|L8.668|
00008c  e000              B        |L8.144|
                  |L8.142|
00008e  a184              ADR      r1,|L8.672|
                  |L8.144|
000090  1960              ADDS     r0,r4,r5
000092  f7fffffe          BL       util_write_string
000096  4405              ADD      r5,r5,r0
;;;389        pos += util_write_string(buf + pos, "\r\n");
000098  1960              ADDS     r0,r4,r5
00009a  a182              ADR      r1,|L8.676|
00009c  f7fffffe          BL       util_write_string
0000a0  4405              ADD      r5,r5,r0
;;;390        // Current mode
;;;391        mode_str = daplink_is_bootloader() ? "Bootloader" : "Interface";
0000a2  f7fffffe          BL       daplink_is_bootloader
0000a6  b108              CBZ      r0,|L8.172|
0000a8  a68b              ADR      r6,|L8.728|
0000aa  e000              B        |L8.174|
                  |L8.172|
0000ac  a68d              ADR      r6,|L8.740|
                  |L8.174|
;;;392        pos += util_write_string(buf + pos, "Daplink Mode: ");
0000ae  1960              ADDS     r0,r4,r5
0000b0  a18f              ADR      r1,|L8.752|
0000b2  f7fffffe          BL       util_write_string
0000b6  4405              ADD      r5,r5,r0
;;;393        pos += util_write_string(buf + pos, mode_str);
0000b8  1960              ADDS     r0,r4,r5
0000ba  4631              MOV      r1,r6
0000bc  f7fffffe          BL       util_write_string
0000c0  4405              ADD      r5,r5,r0
;;;394        pos += util_write_string(buf + pos, "\r\n");
0000c2  1960              ADDS     r0,r4,r5
0000c4  a177              ADR      r1,|L8.676|
0000c6  f7fffffe          BL       util_write_string
0000ca  4405              ADD      r5,r5,r0
;;;395        // Current build's version
;;;396        pos += util_write_string(buf + pos, mode_str);
0000cc  1960              ADDS     r0,r4,r5
0000ce  4631              MOV      r1,r6
0000d0  f7fffffe          BL       util_write_string
0000d4  4405              ADD      r5,r5,r0
;;;397        pos += util_write_string(buf + pos, " Version: @V\r\n");
0000d6  1960              ADDS     r0,r4,r5
0000d8  a189              ADR      r1,|L8.768|
0000da  f7fffffe          BL       util_write_string
0000de  4405              ADD      r5,r5,r0
;;;398    
;;;399        // Other builds version (bl or if)
;;;400        if (!daplink_is_bootloader() && info_get_bootloader_present()) {
0000e0  f7fffffe          BL       daplink_is_bootloader
0000e4  b9a0              CBNZ     r0,|L8.272|
0000e6  f7fffffe          BL       info_get_bootloader_present
0000ea  b188              CBZ      r0,|L8.272|
;;;401            pos += util_write_string(buf + pos, "Bootloader Version: ");
0000ec  1960              ADDS     r0,r4,r5
0000ee  a188              ADR      r1,|L8.784|
0000f0  f7fffffe          BL       util_write_string
0000f4  4405              ADD      r5,r5,r0
;;;402            pos += util_write_uint32_zp(buf + pos, info_get_bootloader_version(), 4);
0000f6  f7fffffe          BL       info_get_bootloader_version
0000fa  4601              MOV      r1,r0
0000fc  1960              ADDS     r0,r4,r5
0000fe  2204              MOVS     r2,#4
000100  f7fffffe          BL       util_write_uint32_zp
000104  4405              ADD      r5,r5,r0
;;;403            pos += util_write_string(buf + pos, "\r\n");
000106  1960              ADDS     r0,r4,r5
000108  a166              ADR      r1,|L8.676|
00010a  f7fffffe          BL       util_write_string
00010e  4405              ADD      r5,r5,r0
                  |L8.272|
;;;404        }
;;;405    
;;;406        if (!daplink_is_interface() && info_get_interface_present()) {
000110  f7fffffe          BL       daplink_is_interface
000114  b9a0              CBNZ     r0,|L8.320|
000116  f7fffffe          BL       info_get_interface_present
00011a  b188              CBZ      r0,|L8.320|
;;;407            pos += util_write_string(buf + pos, "Interface Version: ");
00011c  1960              ADDS     r0,r4,r5
00011e  a182              ADR      r1,|L8.808|
000120  f7fffffe          BL       util_write_string
000124  4405              ADD      r5,r5,r0
;;;408            pos += util_write_uint32_zp(buf + pos, info_get_interface_version(), 4);
000126  f7fffffe          BL       info_get_interface_version
00012a  4601              MOV      r1,r0
00012c  1960              ADDS     r0,r4,r5
00012e  2204              MOVS     r2,#4
000130  f7fffffe          BL       util_write_uint32_zp
000134  4405              ADD      r5,r5,r0
;;;409            pos += util_write_string(buf + pos, "\r\n");
000136  1960              ADDS     r0,r4,r5
000138  a15a              ADR      r1,|L8.676|
00013a  f7fffffe          BL       util_write_string
00013e  4405              ADD      r5,r5,r0
                  |L8.320|
;;;410        }
;;;411    
;;;412        // GIT sha
;;;413        pos += util_write_string(buf + pos, "Git SHA: ");
000140  1960              ADDS     r0,r4,r5
000142  a17e              ADR      r1,|L8.828|
000144  f7fffffe          BL       util_write_string
000148  4405              ADD      r5,r5,r0
;;;414        pos += util_write_string(buf + pos, GIT_COMMIT_SHA);
00014a  1960              ADDS     r0,r4,r5
00014c  a17e              ADR      r1,|L8.840|
00014e  f7fffffe          BL       util_write_string
000152  4405              ADD      r5,r5,r0
;;;415        pos += util_write_string(buf + pos, "\r\n");
000154  1960              ADDS     r0,r4,r5
000156  a153              ADR      r1,|L8.676|
000158  f7fffffe          BL       util_write_string
00015c  4405              ADD      r5,r5,r0
;;;416        // Local modifications when making the build
;;;417        pos += util_write_string(buf + pos, "Local Mods: ");
00015e  1960              ADDS     r0,r4,r5
000160  a184              ADR      r1,|L8.884|
000162  f7fffffe          BL       util_write_string
000166  4405              ADD      r5,r5,r0
;;;418        pos += util_write_uint32(buf + pos, GIT_LOCAL_MODS);
000168  1960              ADDS     r0,r4,r5
00016a  2100              MOVS     r1,#0
00016c  f7fffffe          BL       util_write_uint32
000170  4405              ADD      r5,r5,r0
;;;419        pos += util_write_string(buf + pos, "\r\n");
000172  1960              ADDS     r0,r4,r5
000174  a14b              ADR      r1,|L8.676|
000176  f7fffffe          BL       util_write_string
00017a  4405              ADD      r5,r5,r0
;;;420        // Supported USB endpoints
;;;421        pos += util_write_string(buf + pos, "USB Interfaces: ");
00017c  1960              ADDS     r0,r4,r5
00017e  a181              ADR      r1,|L8.900|
000180  f7fffffe          BL       util_write_string
000184  4405              ADD      r5,r5,r0
;;;422    #ifdef MSC_ENDPOINT
;;;423        pos += util_write_string(buf + pos, "MSD");
000186  1960              ADDS     r0,r4,r5
000188  a183              ADR      r1,|L8.920|
00018a  f7fffffe          BL       util_write_string
00018e  4405              ADD      r5,r5,r0
;;;424    #endif
;;;425    #ifdef CDC_ENDPOINT
;;;426        pos += util_write_string(buf + pos, ", CDC");
000190  1960              ADDS     r0,r4,r5
000192  a182              ADR      r1,|L8.924|
000194  f7fffffe          BL       util_write_string
000198  4405              ADD      r5,r5,r0
;;;427    #endif
;;;428    #ifdef HID_ENDPOINT
;;;429        pos += util_write_string(buf + pos, ", HID");
00019a  1960              ADDS     r0,r4,r5
00019c  a181              ADR      r1,|L8.932|
00019e  f7fffffe          BL       util_write_string
0001a2  4405              ADD      r5,r5,r0
;;;430    #endif
;;;431    #if (WEBUSB_INTERFACE)
;;;432        pos += util_write_string(buf + pos, ", WebUSB");
0001a4  1960              ADDS     r0,r4,r5
0001a6  a181              ADR      r1,|L8.940|
0001a8  f7fffffe          BL       util_write_string
0001ac  4405              ADD      r5,r5,r0
;;;433    #endif
;;;434        pos += util_write_string(buf + pos, "\r\n");
0001ae  1960              ADDS     r0,r4,r5
0001b0  a13c              ADR      r1,|L8.676|
0001b2  f7fffffe          BL       util_write_string
0001b6  4405              ADD      r5,r5,r0
;;;435    
;;;436        // CRC of the bootloader (if there is one)
;;;437        if (info_get_bootloader_present()) {
0001b8  f7fffffe          BL       info_get_bootloader_present
0001bc  b180              CBZ      r0,|L8.480|
;;;438            pos += util_write_string(buf + pos, "Bootloader CRC: 0x");
0001be  1960              ADDS     r0,r4,r5
0001c0  a17d              ADR      r1,|L8.952|
0001c2  f7fffffe          BL       util_write_string
0001c6  4405              ADD      r5,r5,r0
;;;439            pos += util_write_hex32(buf + pos, info_get_crc_bootloader());
0001c8  f7fffffe          BL       info_get_crc_bootloader
0001cc  4601              MOV      r1,r0
0001ce  1960              ADDS     r0,r4,r5
0001d0  f7fffffe          BL       util_write_hex32
0001d4  4405              ADD      r5,r5,r0
;;;440            pos += util_write_string(buf + pos, "\r\n");
0001d6  1960              ADDS     r0,r4,r5
0001d8  a132              ADR      r1,|L8.676|
0001da  f7fffffe          BL       util_write_string
0001de  4405              ADD      r5,r5,r0
                  |L8.480|
;;;441        }
;;;442    
;;;443        // CRC of the interface
;;;444        pos += util_write_string(buf + pos, "Interface CRC: 0x");
0001e0  1960              ADDS     r0,r4,r5
0001e2  a17a              ADR      r1,|L8.972|
0001e4  f7fffffe          BL       util_write_string
0001e8  4405              ADD      r5,r5,r0
;;;445        pos += util_write_hex32(buf + pos, info_get_crc_interface());
0001ea  f7fffffe          BL       info_get_crc_interface
0001ee  4601              MOV      r1,r0
0001f0  1960              ADDS     r0,r4,r5
0001f2  f7fffffe          BL       util_write_hex32
0001f6  4405              ADD      r5,r5,r0
;;;446        pos += util_write_string(buf + pos, "\r\n");
0001f8  1960              ADDS     r0,r4,r5
0001fa  a12a              ADR      r1,|L8.676|
0001fc  f7fffffe          BL       util_write_string
000200  4405              ADD      r5,r5,r0
;;;447    
;;;448        // Number of remounts that have occurred
;;;449        pos += util_write_string(buf + pos, "Remount count: ");
000202  1960              ADDS     r0,r4,r5
000204  a176              ADR      r1,|L8.992|
000206  f7fffffe          BL       util_write_string
;;;450        pos += util_write_uint32(buf + pos, remount_count);
00020a  4979              LDR      r1,|L8.1008|
00020c  4405              ADD      r5,r5,r0              ;449
00020e  1960              ADDS     r0,r4,r5
000210  6849              LDR      r1,[r1,#4]  ; remount_count
000212  f7fffffe          BL       util_write_uint32
000216  4405              ADD      r5,r5,r0
;;;451        pos += util_write_string(buf + pos, "\r\n");
000218  1960              ADDS     r0,r4,r5
00021a  a122              ADR      r1,|L8.676|
00021c  f7fffffe          BL       util_write_string
000220  4428              ADD      r0,r0,r5
;;;452    
;;;453        //Target URL
;;;454        pos += util_write_string(buf + pos, "URL: @R\r\n");
000222  4420              ADD      r0,r0,r4
000224  a173              ADR      r1,|L8.1012|
000226  f7fffffe          BL       util_write_string
;;;455    
;;;456        return expand_info(data, datasize);
00022a  4639              MOV      r1,r7
00022c  4620              MOV      r0,r4
00022e  e8bd41f0          POP      {r4-r8,lr}
000232  f7ffbffe          B.W      expand_info
;;;457    }
;;;458    
                          ENDP

000236  0000              DCW      0x0000
                  |L8.568|
000238  23204441          DCB      "# DAPLink Firmware - see https://mbed.com/daplink\r\n",0
00023c  504c696e
000240  6b204669
000244  726d7761
000248  7265202d
00024c  20736565
000250  20687474
000254  70733a2f
000258  2f6d6265
00025c  642e636f
000260  6d2f6461
000264  706c696e
000268  6b0d0a00
                  |L8.620|
00026c  556e6971          DCB      "Unique ID: @U\r\n",0
000270  75652049
000274  443a2040
000278  550d0a00
                  |L8.636|
00027c  48494320          DCB      "HIC ID: @D\r\n",0
000280  49443a20
000284  40440d0a
000288  00      
000289  00                DCB      0
00028a  00                DCB      0
00028b  00                DCB      0
                  |L8.652|
00028c  4175746f          DCB      "Auto Reset: ",0
000290  20526573
000294  65743a20
000298  00      
000299  00                DCB      0
00029a  00                DCB      0
00029b  00                DCB      0
                  |L8.668|
00029c  3100              DCB      "1",0
00029e  00                DCB      0
00029f  00                DCB      0
                  |L8.672|
0002a0  3000              DCB      "0",0
0002a2  00                DCB      0
0002a3  00                DCB      0
                  |L8.676|
0002a4  0d0a00            DCB      "\r\n",0
0002a7  00                DCB      0
                  |L8.680|
0002a8  4175746f          DCB      "Automation allowed: ",0
0002ac  6d617469
0002b0  6f6e2061
0002b4  6c6c6f77
0002b8  65643a20
0002bc  00      
0002bd  00                DCB      0
0002be  00                DCB      0
0002bf  00                DCB      0
                  |L8.704|
0002c0  4f766572          DCB      "Overflow detection: ",0
0002c4  666c6f77
0002c8  20646574
0002cc  65637469
0002d0  6f6e3a20
0002d4  00      
0002d5  00                DCB      0
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L8.728|
0002d8  426f6f74          DCB      "Bootloader",0
0002dc  6c6f6164
0002e0  657200  
0002e3  00                DCB      0
                  |L8.740|
0002e4  496e7465          DCB      "Interface",0
0002e8  72666163
0002ec  6500    
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L8.752|
0002f0  4461706c          DCB      "Daplink Mode: ",0
0002f4  696e6b20
0002f8  4d6f6465
0002fc  3a2000  
0002ff  00                DCB      0
                  |L8.768|
000300  20566572          DCB      " Version: @V\r\n",0
000304  73696f6e
000308  3a204056
00030c  0d0a00  
00030f  00                DCB      0
                  |L8.784|
000310  426f6f74          DCB      "Bootloader Version: ",0
000314  6c6f6164
000318  65722056
00031c  65727369
000320  6f6e3a20
000324  00      
000325  00                DCB      0
000326  00                DCB      0
000327  00                DCB      0
                  |L8.808|
000328  496e7465          DCB      "Interface Version: ",0
00032c  72666163
000330  65205665
000334  7273696f
000338  6e3a2000
                  |L8.828|
00033c  47697420          DCB      "Git SHA: ",0
000340  5348413a
000344  2000    
000346  00                DCB      0
000347  00                DCB      0
                  |L8.840|
000348  32356362          DCB      "25cbc71260c318e15f9c459f39a8fc27641de92d",0
00034c  63373132
000350  36306333
000354  31386531
000358  35663963
00035c  34353966
000360  33396138
000364  66633237
000368  36343164
00036c  65393264
000370  00      
000371  00                DCB      0
000372  00                DCB      0
000373  00                DCB      0
                  |L8.884|
000374  4c6f6361          DCB      "Local Mods: ",0
000378  6c204d6f
00037c  64733a20
000380  00      
000381  00                DCB      0
000382  00                DCB      0
000383  00                DCB      0
                  |L8.900|
000384  55534220          DCB      "USB Interfaces: ",0
000388  496e7465
00038c  72666163
000390  65733a20
000394  00      
000395  00                DCB      0
000396  00                DCB      0
000397  00                DCB      0
                  |L8.920|
000398  4d534400          DCB      "MSD",0
                  |L8.924|
00039c  2c204344          DCB      ", CDC",0
0003a0  4300    
0003a2  00                DCB      0
0003a3  00                DCB      0
                  |L8.932|
0003a4  2c204849          DCB      ", HID",0
0003a8  4400    
0003aa  00                DCB      0
0003ab  00                DCB      0
                  |L8.940|
0003ac  2c205765          DCB      ", WebUSB",0
0003b0  62555342
0003b4  00      
0003b5  00                DCB      0
0003b6  00                DCB      0
0003b7  00                DCB      0
                  |L8.952|
0003b8  426f6f74          DCB      "Bootloader CRC: 0x",0
0003bc  6c6f6164
0003c0  65722043
0003c4  52433a20
0003c8  307800  
0003cb  00                DCB      0
                  |L8.972|
0003cc  496e7465          DCB      "Interface CRC: 0x",0
0003d0  72666163
0003d4  65204352
0003d8  433a2030
0003dc  7800    
0003de  00                DCB      0
0003df  00                DCB      0
                  |L8.992|
0003e0  52656d6f          DCB      "Remount count: ",0
0003e4  756e7420
0003e8  636f756e
0003ec  743a2000
                  |L8.1008|
                          DCD      ||.data||
                  |L8.1012|
0003f4  55524c3a          DCB      "URL: @R\r\n",0
0003f8  2040520d
0003fc  0a00    
0003fe  00                DCB      0
0003ff  00                DCB      0

                          AREA ||i.vfs_user_build_filesystem||, CODE, READONLY, ALIGN=2

                  vfs_user_build_filesystem PROC
;;;85     
;;;86     void vfs_user_build_filesystem()
000000  b51c              PUSH     {r2-r4,lr}
000002  4c2f              LDR      r4,|L9.192|
000004  7fe0              LDRB     r0,[r4,#0x1f]  ; g_board_info
;;;87     {
000006  b110              CBZ      r0,|L9.14|
000008  f104001f          ADD      r0,r4,#0x1f
00000c  e000              B        |L9.16|
                  |L9.14|
00000e  a02d              ADR      r0,|L9.196|
                  |L9.16|
;;;88         uint32_t file_size;
;;;89         vfs_file_t file_handle;
;;;90         // Setup the filesystem based on target parameters
;;;91         vfs_init(get_daplink_drive_name(), disc_size);
000010  f04f6180          MOV      r1,#0x4000000
000014  f7fffffe          BL       vfs_init
;;;92         // MBED.HTM
;;;93         file_size = get_file_size(read_file_mbed_htm);
000018  482d              LDR      r0,|L9.208|
00001a  f7fffffe          BL       get_file_size
00001e  4603              MOV      r3,r0
000020  7d20              LDRB     r0,[r4,#0x14]  ; g_board_info
000022  b110              CBZ      r0,|L9.42|
000024  4826              LDR      r0,|L9.192|
000026  3014              ADDS     r0,r0,#0x14
000028  e000              B        |L9.44|
                  |L9.42|
00002a  a02a              ADR      r0,|L9.212|
                  |L9.44|
;;;94         vfs_create_file(get_daplink_url_name(), read_file_mbed_htm, 0, file_size);
00002c  2200              MOVS     r2,#0
00002e  4928              LDR      r1,|L9.208|
000030  f7fffffe          BL       vfs_create_file
;;;95         // DETAILS.TXT
;;;96         file_size = get_file_size(read_file_details_txt);
000034  482a              LDR      r0,|L9.224|
000036  f7fffffe          BL       get_file_size
00003a  4603              MOV      r3,r0
;;;97         vfs_create_file("DETAILS TXT", read_file_details_txt, 0, file_size);
00003c  2200              MOVS     r2,#0
00003e  4928              LDR      r1,|L9.224|
000040  a028              ADR      r0,|L9.228|
000042  f7fffffe          BL       vfs_create_file
;;;98     
;;;99         // FAIL.TXT
;;;100        if (vfs_mngr_get_transfer_status() != ERROR_SUCCESS) {
000046  f7fffffe          BL       vfs_mngr_get_transfer_status
00004a  b140              CBZ      r0,|L9.94|
;;;101            file_size = get_file_size(read_file_fail_txt);
00004c  4828              LDR      r0,|L9.240|
00004e  f7fffffe          BL       get_file_size
000052  4603              MOV      r3,r0
;;;102            vfs_create_file("FAIL    TXT", read_file_fail_txt, 0, file_size);
000054  2200              MOVS     r2,#0
000056  4926              LDR      r1,|L9.240|
000058  a026              ADR      r0,|L9.244|
00005a  f7fffffe          BL       vfs_create_file
                  |L9.94|
;;;103        }
;;;104    
;;;105        // ASSERT.TXT
;;;106        if (config_ram_get_assert(assert_buf, sizeof(assert_buf), &assert_line, &assert_source)) {
00005e  4b28              LDR      r3,|L9.256|
000060  2141              MOVS     r1,#0x41
000062  1c9a              ADDS     r2,r3,#2
000064  4827              LDR      r0,|L9.260|
000066  f7fffffe          BL       config_ram_get_assert
00006a  b158              CBZ      r0,|L9.132|
;;;107            file_size = get_file_size(read_file_assert_txt);
00006c  4826              LDR      r0,|L9.264|
00006e  f7fffffe          BL       get_file_size
000072  4603              MOV      r3,r0
;;;108            file_handle = vfs_create_file(assert_file, read_file_assert_txt, 0, file_size);
000074  2200              MOVS     r2,#0
000076  4924              LDR      r1,|L9.264|
000078  4824              LDR      r0,|L9.268|
00007a  f7fffffe          BL       vfs_create_file
;;;109            vfs_file_set_attr(file_handle, (vfs_file_attr_bit_t)0); // Remove read only attribute
00007e  2100              MOVS     r1,#0
000080  f7fffffe          BL       vfs_file_set_attr
                  |L9.132|
;;;110        }
;;;111    
;;;112        // NEED_BL.TXT
;;;113        volatile uint32_t bl_start = DAPLINK_ROM_BL_START; // Silence warnings about null pointer
000084  f04f6000          MOV      r0,#0x8000000
;;;114        volatile uint32_t if_start = DAPLINK_ROM_IF_START; // Silence warnings about null pointer
000088  9001              STR      r0,[sp,#4]
00008a  4821              LDR      r0,|L9.272|
;;;115    
;;;116        if (daplink_is_interface() &&
00008c  9000              STR      r0,[sp,#0]
00008e  f7fffffe          BL       daplink_is_interface
000092  2800              CMP      r0,#0
000094  d013              BEQ      |L9.190|
;;;117                (DAPLINK_ROM_BL_SIZE > 0) &&
;;;118                (0 == memcmp((void *)bl_start, (void *)if_start, DAPLINK_MIN_WRITE_SIZE))) {
000096  e9dd1000          LDRD     r1,r0,[sp,#0]
00009a  f44f6280          MOV      r2,#0x400
00009e  f7fffffe          BL       memcmp
0000a2  2800              CMP      r0,#0
0000a4  d10b              BNE      |L9.190|
;;;119            // If the bootloader contains a copy of the interfaces vector table
;;;120            // then an error occurred when updating so warn that the bootloader is
;;;121            // missing.
;;;122            file_size = get_file_size(read_file_need_bl_txt);
0000a6  481b              LDR      r0,|L9.276|
0000a8  f7fffffe          BL       get_file_size
;;;123            vfs_create_file("NEED_BL TXT", read_file_need_bl_txt, 0, file_size);
0000ac  b002              ADD      sp,sp,#8
0000ae  4603              MOV      r3,r0                 ;122
0000b0  e8bd4010          POP      {r4,lr}
0000b4  2200              MOVS     r2,#0
0000b6  4917              LDR      r1,|L9.276|
0000b8  a017              ADR      r0,|L9.280|
0000ba  f7ffbffe          B.W      vfs_create_file
                  |L9.190|
;;;124        }
;;;125    }
0000be  bd1c              POP      {r2-r4,pc}
;;;126    
                          ENDP

                  |L9.192|
                          DCD      g_board_info
                  |L9.196|
0000c4  4441504c          DCB      "DAPLINK    ",0
0000c8  494e4b20
0000cc  20202000
                  |L9.208|
                          DCD      read_file_mbed_htm
                  |L9.212|
0000d4  4d424544          DCB      "MBED    HTM",0
0000d8  20202020
0000dc  48544d00
                  |L9.224|
                          DCD      read_file_details_txt
                  |L9.228|
0000e4  44455441          DCB      "DETAILS TXT",0
0000e8  494c5320
0000ec  54585400
                  |L9.240|
                          DCD      read_file_fail_txt
                  |L9.244|
0000f4  4641494c          DCB      "FAIL    TXT",0
0000f8  20202020
0000fc  54585400
                  |L9.256|
                          DCD      ||.data||
                  |L9.260|
                          DCD      ||.bss||+0x200
                  |L9.264|
                          DCD      read_file_assert_txt
                  |L9.268|
                          DCD      ||.constdata||+0x103
                  |L9.272|
                          DCD      0x0800c000
                  |L9.276|
                          DCD      read_file_need_bl_txt
                  |L9.280|
000118  4e454544          DCB      "NEED_BL TXT",0
00011c  5f424c20
000120  54585400

                          AREA ||i.vfs_user_disconnecting||, CODE, READONLY, ALIGN=2

                  vfs_user_disconnecting PROC
;;;195    
;;;196    void vfs_user_disconnecting()
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198        // Reset if programming was successful  //TODO - move to flash layer
;;;199        if (daplink_is_bootloader() && (ERROR_SUCCESS == vfs_mngr_get_transfer_status())) {
000002  f7fffffe          BL       daplink_is_bootloader
000006  b120              CBZ      r0,|L10.18|
000008  f7fffffe          BL       vfs_mngr_get_transfer_status
00000c  b908              CBNZ     r0,|L10.18|
;;;200            SystemReset();
00000e  f7fffffe          BL       SystemReset
                  |L10.18|
;;;201        }
;;;202    
;;;203        // If hold in bootloader has been set then reset after usb is disconnected
;;;204        if (daplink_is_interface() && (config_ram_get_hold_in_bl() || config_ram_get_disable_msd()==1)) {
000012  f7fffffe          BL       daplink_is_interface
000016  b140              CBZ      r0,|L10.42|
000018  f7fffffe          BL       config_ram_get_hold_in_bl
00001c  b918              CBNZ     r0,|L10.38|
00001e  f7fffffe          BL       config_ram_get_disable_msd
000022  2801              CMP      r0,#1
000024  d101              BNE      |L10.42|
                  |L10.38|
;;;205            SystemReset();
000026  f7fffffe          BL       SystemReset
                  |L10.42|
;;;206        }
;;;207    
;;;208        remount_count++;
00002a  4802              LDR      r0,|L10.52|
00002c  6841              LDR      r1,[r0,#4]  ; remount_count
00002e  1c49              ADDS     r1,r1,#1
000030  6041              STR      r1,[r0,#4]  ; remount_count
;;;209    }
000032  bd10              POP      {r4,pc}
;;;210    
                          ENDP

                  |L10.52|
                          DCD      ||.data||

                          AREA ||i.vfs_user_file_change_handler||, CODE, READONLY, ALIGN=2

                  vfs_user_file_change_handler PROC
;;;127    // Callback to handle changes to the root directory.  Should be used with vfs_set_file_change_callback
;;;128    void vfs_user_file_change_handler(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
000006  f7fffffe          BL       gpio_get_reset_btn_no_fwrd
;;;130        // Allow settings to be changed if automation mode is
;;;131        // enabled or if the user is holding the reset button
;;;132        bool btn_pressed = gpio_get_reset_btn();
00000a  b910              CBNZ     r0,|L11.18|
00000c  f7fffffe          BL       gpio_get_reset_btn_fwrd
000010  b108              CBZ      r0,|L11.22|
                  |L11.18|
000012  2201              MOVS     r2,#1
000014  e000              B        |L11.24|
                  |L11.22|
000016  2200              MOVS     r2,#0
                  |L11.24|
;;;133    
;;;134        if (!btn_pressed && !config_get_automation_allowed()) {
000018  b91a              CBNZ     r2,|L11.34|
00001a  f7fffffe          BL       config_get_automation_allowed
00001e  2800              CMP      r0,#0
000020  d071              BEQ      |L11.262|
                  |L11.34|
;;;135            return;
;;;136        }
;;;137    
;;;138        if (VFS_FILE_CHANGED == change) {
;;;139            // Unused
;;;140        }
;;;141    
;;;142        if (VFS_FILE_CREATED == change) {
000022  b174              CBZ      r4,|L11.66|
;;;143            if (!memcmp(filename, daplink_mode_file_name, sizeof(vfs_filename_t))) {
;;;144                if (daplink_is_interface()) {
;;;145                    config_ram_set_hold_in_bl(true);
;;;146                } else {
;;;147                    // Do nothing - bootloader will go to interface by default
;;;148                }
;;;149    
;;;150                vfs_mngr_fs_remount();
;;;151            } else if (!memcmp(filename, "AUTO_RSTCFG", sizeof(vfs_filename_t))) {
;;;152                config_set_auto_rst(true);
;;;153                vfs_mngr_fs_remount();
;;;154            } else if (!memcmp(filename, "HARD_RSTCFG", sizeof(vfs_filename_t))) {
;;;155                config_set_auto_rst(false);
;;;156                vfs_mngr_fs_remount();
;;;157            } else if (!memcmp(filename, "ASSERT  ACT", sizeof(vfs_filename_t))) {
;;;158                // Test asserts
;;;159                util_assert(0);
;;;160            } else if (!memcmp(filename, "REFRESH ACT", sizeof(vfs_filename_t))) {
;;;161                // Remount to update the drive
;;;162                vfs_mngr_fs_remount();
;;;163            } else if (!memcmp(filename, "AUTO_ON CFG", sizeof(vfs_filename_t))) {
;;;164                config_set_automation_allowed(true);
;;;165                vfs_mngr_fs_remount();
;;;166            } else if (!memcmp(filename, "AUTO_OFFCFG", sizeof(vfs_filename_t))) {
;;;167                config_set_automation_allowed(false);
;;;168                vfs_mngr_fs_remount();
;;;169            } else if (!memcmp(filename, "ERASE   ACT", sizeof(vfs_filename_t))) {
;;;170                erase_target();
;;;171                vfs_mngr_fs_remount();
;;;172            } else if (!memcmp(filename, "OVFL_ON CFG", sizeof(vfs_filename_t))) {
;;;173                config_set_overflow_detect(true);
;;;174                vfs_mngr_fs_remount();
;;;175            } else if (!memcmp(filename, "OVFL_OFFCFG", sizeof(vfs_filename_t))) {
;;;176                config_set_overflow_detect(false);
;;;177                vfs_mngr_fs_remount();
;;;178            } else if (!memcmp(filename, "MSD_ON  ACT", sizeof(vfs_filename_t))) {
;;;179                config_ram_set_disable_msd(false);
;;;180                vfs_mngr_fs_remount();
;;;181            } else if (!memcmp(filename, "MSD_OFF ACT", sizeof(vfs_filename_t))) {
;;;182                config_ram_set_disable_msd(true);
;;;183                vfs_mngr_fs_remount();
;;;184            }
;;;185        }
;;;186    
;;;187        if (VFS_FILE_DELETED == change) {
000024  2c01              CMP      r4,#1
000026  d16e              BNE      |L11.262|
;;;188            if (!memcmp(filename, assert_file, sizeof(vfs_filename_t))) {
000028  220b              MOVS     r2,#0xb
00002a  4945              LDR      r1,|L11.320|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       memcmp
000032  2800              CMP      r0,#0
000034  d167              BNE      |L11.262|
;;;189                // Clear assert and remount to update the drive
;;;190                util_assert_clear();
000036  f7fffffe          BL       util_assert_clear
                  |L11.58|
;;;191                vfs_mngr_fs_remount();
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  f7ffbffe          B.W      vfs_mngr_fs_remount
                  |L11.66|
000042  220b              MOVS     r2,#0xb               ;143
000044  493f              LDR      r1,|L11.324|
000046  4628              MOV      r0,r5                 ;143
000048  f7fffffe          BL       memcmp
00004c  2800              CMP      r0,#0                 ;143
00004e  d04e              BEQ      |L11.238|
000050  220b              MOVS     r2,#0xb               ;151
000052  a13d              ADR      r1,|L11.328|
000054  4628              MOV      r0,r5                 ;151
000056  f7fffffe          BL       memcmp
00005a  2800              CMP      r0,#0                 ;151
00005c  d04f              BEQ      |L11.254|
00005e  220b              MOVS     r2,#0xb               ;154
000060  a13c              ADR      r1,|L11.340|
000062  4628              MOV      r0,r5                 ;154
000064  f7fffffe          BL       memcmp
000068  2800              CMP      r0,#0                 ;154
00006a  d049              BEQ      |L11.256|
00006c  220b              MOVS     r2,#0xb               ;157
00006e  a13c              ADR      r1,|L11.352|
000070  4628              MOV      r0,r5                 ;157
000072  f7fffffe          BL       memcmp
000076  2800              CMP      r0,#0                 ;157
000078  d046              BEQ      |L11.264|
00007a  220b              MOVS     r2,#0xb               ;160
00007c  a13b              ADR      r1,|L11.364|
00007e  4628              MOV      r0,r5                 ;160
000080  f7fffffe          BL       memcmp
000084  2800              CMP      r0,#0                 ;160
000086  d0d8              BEQ      |L11.58|
000088  220b              MOVS     r2,#0xb               ;163
00008a  a13b              ADR      r1,|L11.376|
00008c  4628              MOV      r0,r5                 ;163
00008e  f7fffffe          BL       memcmp
000092  2800              CMP      r0,#0                 ;163
000094  d03f              BEQ      |L11.278|
000096  220b              MOVS     r2,#0xb               ;166
000098  a13a              ADR      r1,|L11.388|
00009a  4628              MOV      r0,r5                 ;166
00009c  f7fffffe          BL       memcmp
0000a0  2800              CMP      r0,#0                 ;166
0000a2  d039              BEQ      |L11.280|
0000a4  220b              MOVS     r2,#0xb               ;169
0000a6  a13a              ADR      r1,|L11.400|
0000a8  4628              MOV      r0,r5                 ;169
0000aa  f7fffffe          BL       memcmp
0000ae  2800              CMP      r0,#0                 ;169
0000b0  d035              BEQ      |L11.286|
0000b2  220b              MOVS     r2,#0xb               ;172
0000b4  a139              ADR      r1,|L11.412|
0000b6  4628              MOV      r0,r5                 ;172
0000b8  f7fffffe          BL       memcmp
0000bc  2800              CMP      r0,#0                 ;172
0000be  d03a              BEQ      |L11.310|
0000c0  220b              MOVS     r2,#0xb               ;175
0000c2  a139              ADR      r1,|L11.424|
0000c4  4628              MOV      r0,r5                 ;175
0000c6  f7fffffe          BL       memcmp
0000ca  b398              CBZ      r0,|L11.308|
0000cc  220b              MOVS     r2,#0xb               ;178
0000ce  a139              ADR      r1,|L11.436|
0000d0  4628              MOV      r0,r5                 ;178
0000d2  f7fffffe          BL       memcmp
0000d6  b138              CBZ      r0,|L11.232|
0000d8  220b              MOVS     r2,#0xb               ;181
0000da  a139              ADR      r1,|L11.448|
0000dc  4628              MOV      r0,r5                 ;181
0000de  f7fffffe          BL       memcmp
0000e2  2800              CMP      r0,#0                 ;181
0000e4  d12b              BNE      |L11.318|
0000e6  2001              MOVS     r0,#1                 ;182
                  |L11.232|
0000e8  f7fffffe          BL       config_ram_set_disable_msd
0000ec  e7a5              B        |L11.58|
                  |L11.238|
0000ee  f7fffffe          BL       daplink_is_interface
0000f2  2800              CMP      r0,#0                 ;144
0000f4  d0a1              BEQ      |L11.58|
0000f6  2001              MOVS     r0,#1                 ;145
0000f8  f7fffffe          BL       config_ram_set_hold_in_bl
0000fc  e79d              B        |L11.58|
                  |L11.254|
0000fe  2001              MOVS     r0,#1                 ;152
                  |L11.256|
000100  f7fffffe          BL       config_set_auto_rst
000104  e799              B        |L11.58|
                  |L11.262|
000106  e01a              B        |L11.318|
                  |L11.264|
000108  e8bd4070          POP      {r4-r6,lr}            ;159
00010c  229f              MOVS     r2,#0x9f              ;159
00010e  a12f              ADR      r1,|L11.460|
000110  2000              MOVS     r0,#0                 ;159
000112  f7ffbffe          B.W      _util_assert
                  |L11.278|
000116  2001              MOVS     r0,#1                 ;164
                  |L11.280|
000118  f7fffffe          BL       config_set_automation_allowed
00011c  e78d              B        |L11.58|
                  |L11.286|
00011e  4c37              LDR      r4,|L11.508|
000120  6820              LDR      r0,[r4,#0]            ;164  ; flash_intf_target
000122  6800              LDR      r0,[r0,#0]            ;164
000124  4780              BLX      r0                    ;164
000126  6820              LDR      r0,[r4,#0]            ;164  ; flash_intf_target
000128  6900              LDR      r0,[r0,#0x10]         ;164
00012a  4780              BLX      r0                    ;164
00012c  6820              LDR      r0,[r4,#0]            ;164  ; flash_intf_target
00012e  6840              LDR      r0,[r0,#4]            ;164
000130  4780              BLX      r0                    ;164
000132  e782              B        |L11.58|
                  |L11.308|
000134  e000              B        |L11.312|
                  |L11.310|
000136  2001              MOVS     r0,#1                 ;173
                  |L11.312|
000138  f7fffffe          BL       config_set_overflow_detect
00013c  e77d              B        |L11.58|
                  |L11.318|
;;;192            }
;;;193        }
;;;194    }
00013e  bd70              POP      {r4-r6,pc}
;;;195    
                          ENDP

                  |L11.320|
                          DCD      ||.constdata||+0x103
                  |L11.324|
                          DCD      daplink_mode_file_name
                  |L11.328|
000148  4155544f          DCB      "AUTO_RSTCFG",0
00014c  5f525354
000150  43464700
                  |L11.340|
000154  48415244          DCB      "HARD_RSTCFG",0
000158  5f525354
00015c  43464700
                  |L11.352|
000160  41535345          DCB      "ASSERT  ACT",0
000164  52542020
000168  41435400
                  |L11.364|
00016c  52454652          DCB      "REFRESH ACT",0
000170  45534820
000174  41435400
                  |L11.376|
000178  4155544f          DCB      "AUTO_ON CFG",0
00017c  5f4f4e20
000180  43464700
                  |L11.388|
000184  4155544f          DCB      "AUTO_OFFCFG",0
000188  5f4f4646
00018c  43464700
                  |L11.400|
000190  45524153          DCB      "ERASE   ACT",0
000194  45202020
000198  41435400
                  |L11.412|
00019c  4f56464c          DCB      "OVFL_ON CFG",0
0001a0  5f4f4e20
0001a4  43464700
                  |L11.424|
0001a8  4f56464c          DCB      "OVFL_OFFCFG",0
0001ac  5f4f4646
0001b0  43464700
                  |L11.436|
0001b4  4d53445f          DCB      "MSD_ON  ACT",0
0001b8  4f4e2020
0001bc  41435400
                  |L11.448|
0001c0  4d53445f          DCB      "MSD_OFF ACT",0
0001c4  4f464620
0001c8  41435400
                  |L11.460|
0001cc  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_user.c",0
0001d0  2e5c2e2e
0001d4  5c736f75
0001d8  7263655c
0001dc  6461706c
0001e0  696e6b5c
0001e4  64726167
0001e8  2d6e2d64
0001ec  726f705c
0001f0  7666735f
0001f4  75736572
0001f8  2e6300  
0001fb  00                DCB      0
                  |L11.508|
                          DCD      flash_intf_target

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  file_buffer
                          %        512
                  assert_buf
                          %        65

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  error_type_prefix
000000  74797065          DCB      0x74,0x79,0x70,0x65
000004  3a2000            DCB      0x3a,0x20,0x00
                  error_prefix
000007  65                DCB      0x65
000008  72726f72          DCB      0x72,0x72,0x6f,0x72
00000c  3a2000            DCB      0x3a,0x20,0x00
                  mbed_redirect_file
00000f  3c                DCB      0x3c
000010  21646f63          DCB      0x21,0x64,0x6f,0x63
000014  74797065          DCB      0x74,0x79,0x70,0x65
000018  2068746d          DCB      0x20,0x68,0x74,0x6d
00001c  6c3e0d0a          DCB      0x6c,0x3e,0x0d,0x0a
000020  3c212d2d          DCB      0x3c,0x21,0x2d,0x2d
000024  206d6265          DCB      0x20,0x6d,0x62,0x65
000028  6420506c          DCB      0x64,0x20,0x50,0x6c
00002c  6174666f          DCB      0x61,0x74,0x66,0x6f
000030  726d2057          DCB      0x72,0x6d,0x20,0x57
000034  65627369          DCB      0x65,0x62,0x73,0x69
000038  74652061          DCB      0x74,0x65,0x20,0x61
00003c  6e642041          DCB      0x6e,0x64,0x20,0x41
000040  75746865          DCB      0x75,0x74,0x68,0x65
000044  6e746963          DCB      0x6e,0x74,0x69,0x63
000048  6174696f          DCB      0x61,0x74,0x69,0x6f
00004c  6e205368          DCB      0x6e,0x20,0x53,0x68
000050  6f727463          DCB      0x6f,0x72,0x74,0x63
000054  7574202d          DCB      0x75,0x74,0x20,0x2d
000058  2d3e0d0a          DCB      0x2d,0x3e,0x0d,0x0a
00005c  3c68746d          DCB      0x3c,0x68,0x74,0x6d
000060  6c3e0d0a          DCB      0x6c,0x3e,0x0d,0x0a
000064  3c686561          DCB      0x3c,0x68,0x65,0x61
000068  643e0d0a          DCB      0x64,0x3e,0x0d,0x0a
00006c  3c6d6574          DCB      0x3c,0x6d,0x65,0x74
000070  61206368          DCB      0x61,0x20,0x63,0x68
000074  61727365          DCB      0x61,0x72,0x73,0x65
000078  743d2275          DCB      0x74,0x3d,0x22,0x75
00007c  74662d38          DCB      0x74,0x66,0x2d,0x38
000080  223e0d0a          DCB      0x22,0x3e,0x0d,0x0a
000084  3c746974          DCB      0x3c,0x74,0x69,0x74
000088  6c653e6d          DCB      0x6c,0x65,0x3e,0x6d
00008c  62656420          DCB      0x62,0x65,0x64,0x20
000090  57656273          DCB      0x57,0x65,0x62,0x73
000094  69746520          DCB      0x69,0x74,0x65,0x20
000098  53686f72          DCB      0x53,0x68,0x6f,0x72
00009c  74637574          DCB      0x74,0x63,0x75,0x74
0000a0  3c2f7469          DCB      0x3c,0x2f,0x74,0x69
0000a4  746c653e          DCB      0x74,0x6c,0x65,0x3e
0000a8  0d0a3c2f          DCB      0x0d,0x0a,0x3c,0x2f
0000ac  68656164          DCB      0x68,0x65,0x61,0x64
0000b0  3e0d0a3c          DCB      0x3e,0x0d,0x0a,0x3c
0000b4  626f6479          DCB      0x62,0x6f,0x64,0x79
0000b8  3e0d0a3c          DCB      0x3e,0x0d,0x0a,0x3c
0000bc  73637269          DCB      0x73,0x63,0x72,0x69
0000c0  70743e0d          DCB      0x70,0x74,0x3e,0x0d
0000c4  0a77696e          DCB      0x0a,0x77,0x69,0x6e
0000c8  646f772e          DCB      0x64,0x6f,0x77,0x2e
0000cc  6c6f6361          DCB      0x6c,0x6f,0x63,0x61
0000d0  74696f6e          DCB      0x74,0x69,0x6f,0x6e
0000d4  2e726570          DCB      0x2e,0x72,0x65,0x70
0000d8  6c616365          DCB      0x6c,0x61,0x63,0x65
0000dc  28224052          DCB      0x28,0x22,0x40,0x52
0000e0  22293b0d          DCB      0x22,0x29,0x3b,0x0d
0000e4  0a3c2f73          DCB      0x0a,0x3c,0x2f,0x73
0000e8  63726970          DCB      0x63,0x72,0x69,0x70
0000ec  743e0d0a          DCB      0x74,0x3e,0x0d,0x0a
0000f0  3c2f626f          DCB      0x3c,0x2f,0x62,0x6f
0000f4  64793e0d          DCB      0x64,0x79,0x3e,0x0d
0000f8  0a3c2f68          DCB      0x0a,0x3c,0x2f,0x68
0000fc  746d6c3e          DCB      0x74,0x6d,0x6c,0x3e
000100  0d0a00            DCB      0x0d,0x0a,0x00
                  assert_file
000103  41                DCB      0x41
000104  53534552          DCB      0x53,0x53,0x45,0x52
000108  54202054          DCB      0x54,0x20,0x20,0x54
00010c  58540000          DCB      0x58,0x54,0x00,0x00
                  error_type_names
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0xc
                          DCD      ||.conststring||+0x18
                          DCD      ||.conststring||+0x20
                          DCD      ||.conststring||+0x28

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  696e7465          DCB      "internal",0
000004  726e616c
000008  00      
000009  00                DCB      0
00000a  00                DCB      0
00000b  00                DCB      0
00000c  7472616e          DCB      "transient",0
000010  7369656e
000014  7400    
000016  00                DCB      0
000017  00                DCB      0
000018  75736572          DCB      "user",0
00001c  00      
00001d  00                DCB      0
00001e  00                DCB      0
00001f  00                DCB      0
000020  74617267          DCB      "target",0
000024  657400  
000027  00                DCB      0
000028  696e7465          DCB      "interface",0
00002c  72666163
000030  6500    
000032  00                DCB      0
000033  00                DCB      0
000034  4120626f          DCB      "A bootloader update was started but unable to complete."
000038  6f746c6f
00003c  61646572
000040  20757064
000044  61746520
000048  77617320
00004c  73746172
000050  74656420
000054  62757420
000058  756e6162
00005c  6c652074
000060  6f20636f
000064  6d706c65
000068  74652e  
00006b  0d0a5265          DCB      "\r\nReload the bootloader to fix this error message.\r\n"
00006f  6c6f6164
000073  20746865
000077  20626f6f
00007b  746c6f61
00007f  64657220
000083  746f2066
000087  69782074
00008b  68697320
00008f  6572726f
000093  72206d65
000097  73736167
00009b  652e0d0a
00009f  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  assert_source
000000  0000              DCB      0x00,0x00
                  assert_line
000002  0000              DCB      0x00,0x00
                  remount_count
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_user.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_vfs_user_c_5190552d____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___10_vfs_user_c_5190552d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_vfs_user_c_5190552d____REVSH|
#line 144
|__asm___10_vfs_user_c_5190552d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
