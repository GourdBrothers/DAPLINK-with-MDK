; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\flash_decoder.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\flash_decoder.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\flash_decoder.crf ..\..\..\source\daplink\drag-n-drop\flash_decoder.c]
                          THUMB

                          AREA ||i.flash_decoder_close||, CODE, READONLY, ALIGN=2

                  flash_decoder_close PROC
;;;316    
;;;317    error_t flash_decoder_close(void)
000000  b570              PUSH     {r4-r6,lr}
;;;318    {
;;;319        error_t status = ERROR_SUCCESS;
;;;320        decoder_state_t prev_state = state;
000002  4d0d              LDR      r5,|L1.56|
000004  2000              MOVS     r0,#0                 ;319
000006  782c              LDRB     r4,[r5,#0]  ; state
000008  b174              CBZ      r4,|L1.40|
;;;321        flash_decoder_printf("flash_decoder_close()\r\n");
;;;322    
;;;323        if (DECODER_STATE_CLOSED == state) {
;;;324            util_assert(0);
;;;325            return ERROR_INTERNAL;
;;;326        }
;;;327    
;;;328        state = DECODER_STATE_CLOSED;
00000a  2100              MOVS     r1,#0
00000c  7029              STRB     r1,[r5,#0]
;;;329    
;;;330        if (flash_initialized) {
00000e  78a9              LDRB     r1,[r5,#2]  ; flash_initialized
000010  b109              CBZ      r1,|L1.22|
;;;331            status = flash_manager_uninit();
000012  f7fffffe          BL       flash_manager_uninit
                  |L1.22|
;;;332            flash_decoder_printf("    flash_manager_uninit ret %i\r\n", status);
;;;333        }
;;;334    
;;;335        if ((DECODER_STATE_DONE != prev_state) &&
000016  2c02              CMP      r4,#2
000018  d005              BEQ      |L1.38|
;;;336                (flash_type != FLASH_DECODER_TYPE_TARGET) &&
00001a  7869              LDRB     r1,[r5,#1]  ; flash_type
00001c  2903              CMP      r1,#3
00001e  d002              BEQ      |L1.38|
;;;337                (status == ERROR_SUCCESS)) {
000020  2800              CMP      r0,#0
000022  d100              BNE      |L1.38|
;;;338            status = ERROR_IAP_UPDT_INCOMPLETE;
000024  2024              MOVS     r0,#0x24
                  |L1.38|
;;;339        }
;;;340    
;;;341        return status;
;;;342    }
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  f44f72a2          MOV      r2,#0x144             ;324
00002c  a103              ADR      r1,|L1.60|
00002e  2000              MOVS     r0,#0                 ;324
000030  f7fffffe          BL       _util_assert
000034  2002              MOVS     r0,#2                 ;325
000036  bd70              POP      {r4-r6,pc}
;;;343    
                          ENDP

                  |L1.56|
                          DCD      ||.data||
                  |L1.60|
00003c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\flash_decoder"
000040  2e5c2e2e
000044  5c736f75
000048  7263655c
00004c  6461706c
000050  696e6b5c
000054  64726167
000058  2d6e2d64
00005c  726f705c
000060  666c6173
000064  685f6465
000068  636f6465
00006c  72      
00006d  2e6300            DCB      ".c",0

                          AREA ||i.flash_decoder_detect_type||, CODE, READONLY, ALIGN=2

                  flash_decoder_detect_type PROC
;;;62     
;;;63     flash_decoder_type_t flash_decoder_detect_type(const uint8_t *data, uint32_t size, uint32_t addr, bool addr_valid)
000000  b5fe              PUSH     {r1-r7,lr}
;;;64     {
000002  461c              MOV      r4,r3
000004  4605              MOV      r5,r0
;;;65         daplink_info_t info;
;;;66         util_assert(size >= FLASH_DECODER_MIN_SIZE);
000006  2930              CMP      r1,#0x30
000008  d301              BCC      |L2.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L2.16|
                  |L2.14|
00000e  2000              MOVS     r0,#0
                  |L2.16|
000010  2242              MOVS     r2,#0x42
000012  a115              ADR      r1,|L2.104|
000014  f7fffffe          BL       _util_assert
;;;67         // Check if this is a daplink image
;;;68         memcpy(&info, data + DAPLINK_INFO_OFFSET, sizeof(info));
000018  220c              MOVS     r2,#0xc
00001a  f1050120          ADD      r1,r5,#0x20
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       __aeabi_memcpy
;;;69         if(!addr_valid){ //reset until we know the binary type
;;;70             flash_type_target_bin = false;
000024  4e1d              LDR      r6,|L2.156|
000026  b90c              CBNZ     r4,|L2.44|
000028  2000              MOVS     r0,#0
00002a  7130              STRB     r0,[r6,#4]
                  |L2.44|
;;;71         }
;;;72         if (DAPLINK_HIC_ID == info.hic_id) {
00002c  491c              LDR      r1,|L2.160|
00002e  9801              LDR      r0,[sp,#4]
000030  4288              CMP      r0,r1
000032  d10b              BNE      |L2.76|
;;;73             if (DAPLINK_BUILD_KEY_IF == info.build_key) {
000034  491b              LDR      r1,|L2.164|
000036  9800              LDR      r0,[sp,#0]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L2.64|
;;;74                 // Interface update
;;;75                 return FLASH_DECODER_TYPE_INTERFACE;
00003c  2002              MOVS     r0,#2
;;;76             } else if (DAPLINK_BUILD_KEY_BL == info.build_key) {
;;;77                 // Bootloader update
;;;78                 return FLASH_DECODER_TYPE_BOOTLOADER;
;;;79             } else {
;;;80                 return FLASH_DECODER_TYPE_UNKNOWN;
;;;81             }
;;;82         }
;;;83     
;;;84         // Check if a valid vector table for the target can be found
;;;85         if (validate_bin_nvic(data)) {
;;;86             if(!addr_valid){ //binary is a bin type
;;;87                 flash_type_target_bin = true;
;;;88             }
;;;89             return FLASH_DECODER_TYPE_TARGET;
;;;90         }
;;;91     
;;;92         // If an address is specified then the data can be decoded
;;;93         if (addr_valid) {
;;;94             // TODO - future improvement - make sure address is within target's flash
;;;95             return FLASH_DECODER_TYPE_TARGET;
;;;96         }
;;;97     
;;;98         return FLASH_DECODER_TYPE_UNKNOWN;
;;;99     }
00003e  bdfe              POP      {r1-r7,pc}
                  |L2.64|
000040  4918              LDR      r1,|L2.164|
000042  39fc              SUBS     r1,r1,#0xfc           ;76
000044  4288              CMP      r0,r1                 ;76
000046  d10c              BNE      |L2.98|
000048  2001              MOVS     r0,#1                 ;78
00004a  bdfe              POP      {r1-r7,pc}
                  |L2.76|
00004c  4628              MOV      r0,r5                 ;85
00004e  f7fffffe          BL       validate_bin_nvic
000052  b118              CBZ      r0,|L2.92|
000054  b91c              CBNZ     r4,|L2.94|
000056  2001              MOVS     r0,#1                 ;87
000058  7130              STRB     r0,[r6,#4]            ;87
00005a  e000              B        |L2.94|
                  |L2.92|
00005c  b10c              CBZ      r4,|L2.98|
                  |L2.94|
00005e  2003              MOVS     r0,#3                 ;95
000060  bdfe              POP      {r1-r7,pc}
                  |L2.98|
000062  2000              MOVS     r0,#0                 ;98
000064  bdfe              POP      {r1-r7,pc}
;;;100    
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
000068  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\flash_decoder"
00006c  2e5c2e2e
000070  5c736f75
000074  7263655c
000078  6461706c
00007c  696e6b5c
000080  64726167
000084  2d6e2d64
000088  726f705c
00008c  666c6173
000090  685f6465
000094  636f6465
000098  72      
000099  2e6300            DCB      ".c",0
                  |L2.156|
                          DCD      ||.data||
                  |L2.160|
                          DCD      0x97969908
                  |L2.164|
                          DCD      0x9b939e8f

                          AREA ||i.flash_decoder_get_flash||, CODE, READONLY, ALIGN=2

                  flash_decoder_get_flash PROC
;;;100    
;;;101    error_t flash_decoder_get_flash(flash_decoder_type_t type, uint32_t addr, bool addr_valid, uint32_t *start_addr, const flash_intf_t **flash_intf)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;102    {
;;;103        error_t status = ERROR_SUCCESS;
000004  f04f0400          MOV      r4,#0
000008  f8dd9038          LDR      r9,[sp,#0x38]         ;102
00000c  ea5f0803          MOVS     r8,r3                 ;102
000010  4693              MOV      r11,r2                ;102
000012  4607              MOV      r7,r0                 ;102
;;;104        uint32_t flash_start_local;
;;;105        const flash_intf_t *flash_intf_local = 0;
000014  4625              MOV      r5,r4
000016  d013              BEQ      |L3.64|
;;;106    
;;;107        if ((0 == start_addr) || (0 == flash_intf)) {
000018  ea5f0009          MOVS     r0,r9
00001c  d010              BEQ      |L3.64|
;;;108            util_assert(0);
;;;109            return ERROR_INTERNAL;
;;;110        }
;;;111    
;;;112        *start_addr = 0;
00001e  2000              MOVS     r0,#0
;;;113        *flash_intf = 0;
000020  f8c80000          STR      r0,[r8,#0]
;;;114        flash_start_local = 0;
000024  4606              MOV      r6,r0
;;;115        flash_intf_local = 0;
;;;116    
;;;117        if (daplink_is_bootloader()) {
000026  f8c90000          STR      r0,[r9,#0]
00002a  f7fffffe          BL       daplink_is_bootloader
;;;118            if (FLASH_DECODER_TYPE_INTERFACE == type) {
;;;119                if (addr_valid && (DAPLINK_ROM_IF_START != addr)) {
;;;120                    // Address is wrong so display error message
;;;121                    status = ERROR_FD_INTF_UPDT_ADDR_WRONG;
;;;122                } else {
;;;123                    // Setup for update
;;;124                    flash_start_local = DAPLINK_ROM_IF_START;
;;;125                    flash_intf_local = flash_intf_iap_protected;
00002e  f8dfa0cc          LDR      r10,|L3.252|
000032  b188              CBZ      r0,|L3.88|
000034  4832              LDR      r0,|L3.256|
000036  2f02              CMP      r7,#2                 ;118
000038  d004              BEQ      |L3.68|
;;;126                }
;;;127            } else if (FLASH_DECODER_TYPE_TARGET == type) {
00003a  2f03              CMP      r7,#3
00003c  d00a              BEQ      |L3.84|
00003e  e042              B        |L3.198|
                  |L3.64|
000040  226c              MOVS     r2,#0x6c              ;108
000042  e054              B        |L3.238|
                  |L3.68|
000044  f1bb0f00          CMP      r11,#0                ;119
000048  d004              BEQ      |L3.84|
00004a  9901              LDR      r1,[sp,#4]            ;119
00004c  4281              CMP      r1,r0                 ;119
00004e  d001              BEQ      |L3.84|
000050  241b              MOVS     r4,#0x1b              ;121
000052  e039              B        |L3.200|
                  |L3.84|
000054  4606              MOV      r6,r0                 ;124
000056  e012              B        |L3.126|
                  |L3.88|
;;;128                // "Target" update in this case would be a 3rd party interface application
;;;129                flash_start_local = DAPLINK_ROM_IF_START;
;;;130                flash_intf_local = flash_intf_iap_protected;
;;;131            } else {
;;;132                status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;133            }
;;;134        } else if (daplink_is_interface()) {
000058  f7fffffe          BL       daplink_is_interface
00005c  b390              CBZ      r0,|L3.196|
;;;135            if (FLASH_DECODER_TYPE_BOOTLOADER == type) {
00005e  2f01              CMP      r7,#1
000060  d002              BEQ      |L3.104|
;;;136                if (addr_valid && (DAPLINK_ROM_BL_START != addr)) {
;;;137                    // Address is wrong so display error message
;;;138                    status = ERROR_FD_BL_UPDT_ADDR_WRONG;
;;;139                } else {
;;;140                    // Setup for update
;;;141                    flash_start_local = DAPLINK_ROM_BL_START;
;;;142                    flash_intf_local = flash_intf_iap_protected;
;;;143                }
;;;144            } else if (FLASH_DECODER_TYPE_TARGET == type) {
000062  2f03              CMP      r7,#3
000064  d00e              BEQ      |L3.132|
000066  e02e              B        |L3.198|
                  |L3.104|
000068  f04f6100          MOV      r1,#0x8000000         ;136
00006c  f1bb0f00          CMP      r11,#0                ;136
000070  d004              BEQ      |L3.124|
000072  9801              LDR      r0,[sp,#4]            ;136
000074  4288              CMP      r0,r1                 ;136
000076  d001              BEQ      |L3.124|
000078  241a              MOVS     r4,#0x1a              ;138
00007a  e025              B        |L3.200|
                  |L3.124|
00007c  460e              MOV      r6,r1                 ;141
                  |L3.126|
00007e  f8da5000          LDR      r5,[r10,#0]           ;142  ; flash_intf_iap_protected
000082  e021              B        |L3.200|
                  |L3.132|
;;;145                if (g_board_info.target_cfg) {
000084  481f              LDR      r0,|L3.260|
000086  f7fffffe          BL       __aeabi_uread4
00008a  b1d8              CBZ      r0,|L3.196|
00008c  f100050c          ADD      r5,r0,#0xc
;;;146                    region_info_t * region = g_board_info.target_cfg->flash_regions;
;;;147                    for (; region->start != 0 || region->end != 0; ++region) {
000090  e006              B        |L3.160|
                  |L3.146|
;;;148                        if (kRegionIsDefault == region->flags) {
000092  f1050008          ADD      r0,r5,#8
000096  f7fffffe          BL       __aeabi_uread4
00009a  2801              CMP      r0,#1
00009c  d00d              BEQ      |L3.186|
00009e  3514              ADDS     r5,r5,#0x14
                  |L3.160|
0000a0  4628              MOV      r0,r5                 ;147
0000a2  f7fffffe          BL       __aeabi_uread4
0000a6  2800              CMP      r0,#0                 ;147
0000a8  d1f3              BNE      |L3.146|
0000aa  1d28              ADDS     r0,r5,#4              ;147
0000ac  f7fffffe          BL       __aeabi_uread4
0000b0  2800              CMP      r0,#0                 ;147
0000b2  d1ee              BNE      |L3.146|
                  |L3.180|
;;;149                            flash_start_local = region->start;
;;;150                            break;
;;;151                        }
;;;152                    }
;;;153                    flash_intf_local = flash_intf_target;
0000b4  4814              LDR      r0,|L3.264|
;;;154                } else {
0000b6  6805              LDR      r5,[r0,#0]  ; flash_intf_target
0000b8  e006              B        |L3.200|
                  |L3.186|
0000ba  4628              MOV      r0,r5                 ;149
0000bc  f7fffffe          BL       __aeabi_uread4
0000c0  4606              MOV      r6,r0                 ;149
0000c2  e7f7              B        |L3.180|
                  |L3.196|
0000c4  e7ff              B        |L3.198|
                  |L3.198|
;;;155                    status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;156                }
;;;157            } else {
;;;158                status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;159            }
;;;160        } else {
;;;161            status = ERROR_FD_UNSUPPORTED_UPDATE;
0000c6  241c              MOVS     r4,#0x1c
                  |L3.200|
;;;162        }
;;;163    
;;;164        // Don't allow bootloader updates unless automation is allowed
;;;165        if (!config_get_automation_allowed() && (FLASH_DECODER_TYPE_BOOTLOADER == type)) {
0000c8  f7fffffe          BL       config_get_automation_allowed
0000cc  b908              CBNZ     r0,|L3.210|
0000ce  2f01              CMP      r7,#1
0000d0  d004              BEQ      |L3.220|
                  |L3.210|
;;;166            status = ERROR_FD_UNSUPPORTED_UPDATE;
;;;167        }
;;;168    
;;;169        if (ERROR_SUCCESS != status) {
0000d2  b12c              CBZ      r4,|L3.224|
                  |L3.212|
;;;170            return status;
0000d4  4620              MOV      r0,r4
                  |L3.214|
;;;171        }
;;;172    
;;;173        if (0 == flash_intf_local) {
;;;174            util_assert(0);
;;;175            return ERROR_INTERNAL;
;;;176        }
;;;177    
;;;178        *start_addr = flash_start_local;
;;;179        *flash_intf = flash_intf_local;
;;;180        return status;
;;;181    }
0000d6  b004              ADD      sp,sp,#0x10
0000d8  e8bd9ff0          POP      {r4-r12,pc}
                  |L3.220|
0000dc  241c              MOVS     r4,#0x1c              ;166
0000de  e7f9              B        |L3.212|
                  |L3.224|
0000e0  b125              CBZ      r5,|L3.236|
0000e2  f8c86000          STR      r6,[r8,#0]            ;179
0000e6  f8c95000          STR      r5,[r9,#0]            ;180
0000ea  e7f3              B        |L3.212|
                  |L3.236|
0000ec  22ae              MOVS     r2,#0xae              ;174
                  |L3.238|
0000ee  a107              ADR      r1,|L3.268|
0000f0  2000              MOVS     r0,#0                 ;174
0000f2  f7fffffe          BL       _util_assert
0000f6  2002              MOVS     r0,#2                 ;175
0000f8  e7ed              B        |L3.214|
;;;182    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L3.252|
                          DCD      flash_intf_iap_protected
                  |L3.256|
                          DCD      0x0800c000
                  |L3.260|
                          DCD      g_board_info+0x10
                  |L3.264|
                          DCD      flash_intf_target
                  |L3.268|
00010c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\flash_decoder"
000110  2e5c2e2e
000114  5c736f75
000118  7263655c
00011c  6461706c
000120  696e6b5c
000124  64726167
000128  2d6e2d64
00012c  726f705c
000130  666c6173
000134  685f6465
000138  636f6465
00013c  72      
00013d  2e6300            DCB      ".c",0

                          AREA ||i.flash_decoder_is_at_end||, CODE, READONLY, ALIGN=2

                  flash_decoder_is_at_end PROC
;;;343    
;;;344    static bool flash_decoder_is_at_end(uint32_t addr, const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;345    {
;;;346        uint32_t end_addr=0;
;;;347    
;;;348        switch (flash_type) {
000004  491c              LDR      r1,|L4.120|
000006  4606              MOV      r6,r0                 ;345
000008  2500              MOVS     r5,#0                 ;346
00000a  7848              LDRB     r0,[r1,#1]  ; flash_type
00000c  4690              MOV      r8,r2                 ;345
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L4.28|
000012  2802              CMP      r0,#2
000014  d004              BEQ      |L4.32|
000016  2803              CMP      r0,#3
000018  d12c              BNE      |L4.116|
00001a  e003              B        |L4.36|
                  |L4.28|
;;;349            case FLASH_DECODER_TYPE_BOOTLOADER:
;;;350                end_addr = DAPLINK_ROM_BL_START + DAPLINK_ROM_BL_SIZE;
00001c  4d17              LDR      r5,|L4.124|
;;;351                break;
00001e  e022              B        |L4.102|
                  |L4.32|
;;;352    
;;;353            case FLASH_DECODER_TYPE_INTERFACE:
;;;354                end_addr = DAPLINK_ROM_IF_START + DAPLINK_ROM_IF_SIZE;
000020  4d17              LDR      r5,|L4.128|
;;;355                break;
000022  e020              B        |L4.102|
                  |L4.36|
;;;356            
;;;357            case FLASH_DECODER_TYPE_TARGET:
;;;358                //only if we are sure it is a bin for the target; without check unordered hex files will cause to terminate flashing
;;;359                if (flash_type_target_bin && g_board_info.target_cfg) {
000024  7908              LDRB     r0,[r1,#4]  ; flash_type_target_bin
000026  b328              CBZ      r0,|L4.116|
000028  4816              LDR      r0,|L4.132|
00002a  f7fffffe          BL       __aeabi_uread4
00002e  b308              CBZ      r0,|L4.116|
000030  f100040c          ADD      r4,r0,#0xc
;;;360                    region_info_t * region = g_board_info.target_cfg->flash_regions;
;;;361                    for (; region->start != 0 || region->end != 0; ++region) {
000034  e00c              B        |L4.80|
                  |L4.54|
;;;362                        if (addr >= region->start &&  addr<=region->end) {
000036  42b7              CMP      r7,r6
000038  d809              BHI      |L4.78|
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       __aeabi_uread4
000040  42b0              CMP      r0,r6
000042  d304              BCC      |L4.78|
;;;363                            end_addr = region->end;
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       __aeabi_uread4
00004a  4605              MOV      r5,r0
;;;364                            break;
00004c  e00a              B        |L4.100|
                  |L4.78|
00004e  3414              ADDS     r4,r4,#0x14
                  |L4.80|
000050  4620              MOV      r0,r4                 ;361
000052  f7fffffe          BL       __aeabi_uread4
000056  0007              MOVS     r7,r0                 ;361
000058  d1ed              BNE      |L4.54|
00005a  1d20              ADDS     r0,r4,#4              ;361
00005c  f7fffffe          BL       __aeabi_uread4
000060  2800              CMP      r0,#0                 ;361
000062  d1e8              BNE      |L4.54|
                  |L4.100|
;;;365                        }
;;;366                    }
;;;367                    if(end_addr == 0){ //invalid end_addr
000064  b135              CBZ      r5,|L4.116|
                  |L4.102|
;;;368                        return false;
;;;369                    }
;;;370                    
;;;371                }
;;;372                else {
;;;373                    return false;
;;;374                }
;;;375                break;
;;;376    
;;;377            default:
;;;378                return false;
;;;379        }
;;;380    
;;;381        if (addr + size >= end_addr) {
000066  eb060008          ADD      r0,r6,r8
00006a  42a8              CMP      r0,r5
00006c  d302              BCC      |L4.116|
;;;382            return true;
00006e  2001              MOVS     r0,#1
                  |L4.112|
;;;383        } else {
;;;384            return false;
;;;385        }
;;;386    }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L4.116|
000074  2000              MOVS     r0,#0                 ;384
000076  e7fb              B        |L4.112|
                          ENDP

                  |L4.120|
                          DCD      ||.data||
                  |L4.124|
                          DCD      0x0800bc00
                  |L4.128|
                          DCD      0x0801fc00
                  |L4.132|
                          DCD      g_board_info+0x10

                          AREA ||i.flash_decoder_open||, CODE, READONLY, ALIGN=2

                  flash_decoder_open PROC
;;;182    
;;;183    error_t flash_decoder_open(void)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        flash_decoder_printf("flash_decoder_open()\r\n");
;;;186    
;;;187        // Stream must not be open already
;;;188        if (state != DECODER_STATE_CLOSED) {
000002  4c0c              LDR      r4,|L5.52|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L5.22|
;;;189            util_assert(0);
000008  22bd              MOVS     r2,#0xbd
00000a  a10b              ADR      r1,|L5.56|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       _util_assert
;;;190            return ERROR_INTERNAL;
000012  2002              MOVS     r0,#2
;;;191        }
;;;192    
;;;193        memset(flash_buf, 0xff, sizeof(flash_buf));
;;;194        state = DECODER_STATE_OPEN;
;;;195        flash_type = FLASH_DECODER_TYPE_UNKNOWN;
;;;196        flash_buf_pos = 0;
;;;197        initial_addr = 0;
;;;198        current_addr = 0;
;;;199        flash_initialized = false;
;;;200        initial_addr_set = false;
;;;201        return ERROR_SUCCESS;
;;;202    }
000014  bd10              POP      {r4,pc}
                  |L5.22|
000016  22ff              MOVS     r2,#0xff              ;193
000018  2130              MOVS     r1,#0x30              ;193
00001a  4814              LDR      r0,|L5.108|
00001c  f7fffffe          BL       __aeabi_memset
000020  2001              MOVS     r0,#1                 ;194
000022  7020              STRB     r0,[r4,#0]            ;194
000024  2000              MOVS     r0,#0                 ;195
000026  7060              STRB     r0,[r4,#1]            ;195
000028  60a0              STR      r0,[r4,#8]            ;197  ; flash_buf_pos
00002a  60e0              STR      r0,[r4,#0xc]          ;198  ; initial_addr
00002c  6120              STR      r0,[r4,#0x10]         ;199  ; current_addr
00002e  70a0              STRB     r0,[r4,#2]            ;199
000030  70e0              STRB     r0,[r4,#3]            ;200
000032  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  |L5.52|
                          DCD      ||.data||
                  |L5.56|
000038  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\flash_decoder"
00003c  2e5c2e2e
000040  5c736f75
000044  7263655c
000048  6461706c
00004c  696e6b5c
000050  64726167
000054  2d6e2d64
000058  726f705c
00005c  666c6173
000060  685f6465
000064  636f6465
000068  72      
000069  2e6300            DCB      ".c",0
                  |L5.108|
                          DCD      ||.bss||

                          AREA ||i.flash_decoder_write||, CODE, READONLY, ALIGN=2

                  flash_decoder_write PROC
;;;203    
;;;204    error_t flash_decoder_write(uint32_t addr, const uint8_t *data, uint32_t size)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;205    {
;;;206        error_t status;
;;;207        flash_decoder_printf("flash_decoder_write(addr=0x%x, size=0x%x)\r\n", addr, size);
;;;208    
;;;209        if (DECODER_STATE_OPEN != state) {
000004  4f41              LDR      r7,|L6.268|
000006  4606              MOV      r6,r0                 ;205
000008  4689              MOV      r9,r1                 ;205
00000a  7838              LDRB     r0,[r7,#0]  ; state
00000c  4615              MOV      r5,r2                 ;205
00000e  2801              CMP      r0,#1
000010  d007              BEQ      |L6.34|
;;;210            util_assert(0);
000012  22d2              MOVS     r2,#0xd2
000014  a13e              ADR      r1,|L6.272|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       _util_assert
;;;211            return ERROR_INTERNAL;
00001c  2002              MOVS     r0,#2
                  |L6.30|
;;;212        }
;;;213    
;;;214        // Set the initial address the first time through
;;;215        if (!initial_addr_set) {
;;;216            initial_addr = addr;
;;;217            current_addr = initial_addr;
;;;218            flash_decoder_printf("     initial_addr=0x%x\r\n", initial_addr);
;;;219            initial_addr_set = true;
;;;220        }
;;;221    
;;;222        if (!flash_initialized) {
;;;223            uint32_t copy_size;
;;;224            bool flash_type_known = false;
;;;225            bool sequential;
;;;226            // Check if the data is sequential
;;;227            sequential = addr == current_addr;
;;;228            current_addr += size;
;;;229    
;;;230            // Buffer data until the flash type is known
;;;231            if (sequential) {
;;;232                // Copy data into buffer
;;;233                copy_size = MIN(size, sizeof(flash_buf) - flash_buf_pos);
;;;234                memcpy(&flash_buf[flash_buf_pos], data, copy_size);
;;;235                flash_buf_pos += copy_size;
;;;236                flash_decoder_printf("    buffering %i bytes\r\n", copy_size);
;;;237                // Update vars so they no longer include the buffered data
;;;238                data += copy_size;
;;;239                size -= copy_size;
;;;240                addr += copy_size;
;;;241    
;;;242                // If enough data has been buffered then determine the type
;;;243                if (flash_buf_pos >= sizeof(flash_buf)) {
;;;244                    util_assert(sizeof(flash_buf) == flash_buf_pos);
;;;245                    // Determine flash type and get info for it
;;;246                    flash_type = flash_decoder_detect_type(flash_buf, flash_buf_pos, initial_addr, true);
;;;247                    flash_decoder_printf("    Buffering complete, setting flash_type=%i\r\n", flash_type);
;;;248                    flash_type_known = true;
;;;249                }
;;;250            } else {
;;;251                flash_type = FLASH_DECODER_TYPE_TARGET;
;;;252                flash_decoder_printf("    Non sequential addr, setting flash_type=%i\r\n", flash_type);
;;;253                flash_type_known = true;
;;;254            }
;;;255    
;;;256            // If flash type is known initialize the flash manager
;;;257            if (flash_type_known) {
;;;258                const flash_intf_t *flash_intf;
;;;259                uint32_t flash_start_addr;
;;;260                status = flash_decoder_get_flash(flash_type, initial_addr, true, &flash_start_addr, &flash_intf);
;;;261    
;;;262                if (ERROR_SUCCESS != status) {
;;;263                    state = DECODER_STATE_ERROR;
;;;264                    return status;
;;;265                }
;;;266    
;;;267                flash_decoder_printf("    flash_start_addr=0x%x\r\n", flash_start_addr);
;;;268                // Initialize flash manager
;;;269                util_assert(!flash_initialized);
;;;270                status = flash_manager_init(flash_intf);
;;;271                flash_decoder_printf("    flash_manager_init ret %i\r\n", status);
;;;272    
;;;273                if (ERROR_SUCCESS != status) {
;;;274                    state = DECODER_STATE_ERROR;
;;;275                    return status;
;;;276                }
;;;277    
;;;278                flash_initialized = true;
;;;279            }
;;;280    
;;;281            // If flash has been initalized then write out buffered data
;;;282            if (flash_initialized) {
;;;283                status = flash_manager_data(initial_addr, flash_buf, flash_buf_pos);
;;;284                flash_decoder_printf("    Flushing buffer initial_addr=0x%x, flash_buf_pos=%i, flash_manager_data ret=%i\r\n",
;;;285                                     initial_addr, flash_buf_pos, status);
;;;286    
;;;287                if (ERROR_SUCCESS != status) {
;;;288                    state = DECODER_STATE_ERROR;
;;;289                    return status;
;;;290                }
;;;291            }
;;;292        }
;;;293    
;;;294        // Write data as normal if flash has been initialized
;;;295        if (flash_initialized) {
;;;296            status = flash_manager_data(addr, data, size);
;;;297            flash_decoder_printf("    Writing data, addr=0x%x, size=0x%x, flash_manager_data ret %i\r\n",
;;;298                                 addr, size, status);
;;;299    
;;;300            if (ERROR_SUCCESS != status) {
;;;301                state = DECODER_STATE_ERROR;
;;;302                return status;
;;;303            }
;;;304        }
;;;305    
;;;306        // Check if this is the end of data
;;;307        if (flash_decoder_is_at_end(addr, data, size)) {
;;;308            flash_decoder_printf("    End of transfer detected - addr 0x%08x, size 0x%08x\r\n",
;;;309                                 addr, size);
;;;310            state = DECODER_STATE_DONE;
;;;311            return ERROR_SUCCESS_DONE;
;;;312        }
;;;313    
;;;314        return ERROR_SUCCESS;
;;;315    }
00001e  e8bd8ffe          POP      {r1-r11,pc}
                  |L6.34|
000022  78f8              LDRB     r0,[r7,#3]            ;215  ; initial_addr_set
000024  f04f0a01          MOV      r10,#1                ;209
000028  b918              CBNZ     r0,|L6.50|
00002a  60fe              STR      r6,[r7,#0xc]          ;217  ; initial_addr
00002c  613e              STR      r6,[r7,#0x10]         ;219  ; current_addr
00002e  f887a003          STRB     r10,[r7,#3]           ;219
                  |L6.50|
000032  78b8              LDRB     r0,[r7,#2]            ;222  ; flash_initialized
000034  f04f0803          MOV      r8,#3                 ;251
000038  2800              CMP      r0,#0                 ;222
00003a  d153              BNE      |L6.228|
00003c  6939              LDR      r1,[r7,#0x10]         ;227  ; current_addr
00003e  428e              CMP      r6,r1                 ;227
000040  d101              BNE      |L6.70|
000042  2001              MOVS     r0,#1                 ;227
000044  e000              B        |L6.72|
                  |L6.70|
000046  2000              MOVS     r0,#0                 ;227
                  |L6.72|
000048  4429              ADD      r1,r1,r5              ;228
00004a  6139              STR      r1,[r7,#0x10]         ;231  ; current_addr
00004c  b330              CBZ      r0,|L6.156|
00004e  68b8              LDR      r0,[r7,#8]            ;233  ; flash_buf_pos
000050  f1c00430          RSB      r4,r0,#0x30           ;233
000054  42ac              CMP      r4,r5                 ;233
000056  d900              BLS      |L6.90|
000058  4614              MOV      r4,r2                 ;233
                  |L6.90|
00005a  493a              LDR      r1,|L6.324|
00005c  4622              MOV      r2,r4                 ;234
00005e  4408              ADD      r0,r0,r1              ;234
000060  4649              MOV      r1,r9                 ;234
000062  f7fffffe          BL       __aeabi_memcpy
000066  68b8              LDR      r0,[r7,#8]            ;235  ; flash_buf_pos
000068  1b2d              SUBS     r5,r5,r4              ;239
00006a  4420              ADD      r0,r0,r4              ;235
00006c  44a1              ADD      r9,r9,r4              ;238
00006e  4426              ADD      r6,r6,r4              ;240
000070  60b8              STR      r0,[r7,#8]            ;243  ; flash_buf_pos
000072  2830              CMP      r0,#0x30              ;243
000074  d32c              BCC      |L6.208|
000076  d102              BNE      |L6.126|
000078  f04f0001          MOV      r0,#1                 ;244
00007c  e001              B        |L6.130|
                  |L6.126|
00007e  f04f0000          MOV      r0,#0                 ;244
                  |L6.130|
000082  f04f02f4          MOV      r2,#0xf4              ;244
000086  a122              ADR      r1,|L6.272|
000088  f7fffffe          BL       _util_assert
00008c  e9d71202          LDRD     r1,r2,[r7,#8]         ;246
000090  2301              MOVS     r3,#1                 ;246
000092  482c              LDR      r0,|L6.324|
000094  f7fffffe          BL       flash_decoder_detect_type
000098  7078              STRB     r0,[r7,#1]            ;246
00009a  e001              B        |L6.160|
                  |L6.156|
00009c  f8878001          STRB     r8,[r7,#1]            ;251
                  |L6.160|
0000a0  a801              ADD      r0,sp,#4              ;260
0000a2  9000              STR      r0,[sp,#0]            ;260
0000a4  ab02              ADD      r3,sp,#8              ;260
0000a6  2201              MOVS     r2,#1                 ;260
0000a8  7878              LDRB     r0,[r7,#1]            ;260  ; flash_type
0000aa  68f9              LDR      r1,[r7,#0xc]          ;260  ; initial_addr
0000ac  f7fffffe          BL       flash_decoder_get_flash
0000b0  b9f0              CBNZ     r0,|L6.240|
0000b2  78b8              LDRB     r0,[r7,#2]            ;269  ; flash_initialized
0000b4  f240120d          MOV      r2,#0x10d             ;269
0000b8  f0800001          EOR      r0,r0,#1              ;269
0000bc  a114              ADR      r1,|L6.272|
0000be  f7fffffe          BL       _util_assert
0000c2  9801              LDR      r0,[sp,#4]            ;270
0000c4  f7fffffe          BL       flash_manager_init
0000c8  b990              CBNZ     r0,|L6.240|
0000ca  f887a002          STRB     r10,[r7,#2]           ;278
0000ce  e001              B        |L6.212|
                  |L6.208|
0000d0  78b8              LDRB     r0,[r7,#2]            ;282  ; flash_initialized
0000d2  b180              CBZ      r0,|L6.246|
                  |L6.212|
0000d4  e9d72002          LDRD     r2,r0,[r7,#8]         ;283
0000d8  491a              LDR      r1,|L6.324|
0000da  f7fffffe          BL       flash_manager_data
0000de  b938              CBNZ     r0,|L6.240|
0000e0  78b8              LDRB     r0,[r7,#2]            ;295  ; flash_initialized
0000e2  b140              CBZ      r0,|L6.246|
                  |L6.228|
0000e4  462a              MOV      r2,r5                 ;296
0000e6  4649              MOV      r1,r9                 ;296
0000e8  4630              MOV      r0,r6                 ;296
0000ea  f7fffffe          BL       flash_manager_data
0000ee  b110              CBZ      r0,|L6.246|
                  |L6.240|
0000f0  f8878000          STRB     r8,[r7,#0]            ;301
0000f4  e793              B        |L6.30|
                  |L6.246|
0000f6  462a              MOV      r2,r5                 ;307
0000f8  4649              MOV      r1,r9                 ;307
0000fa  4630              MOV      r0,r6                 ;307
0000fc  f7fffffe          BL       flash_decoder_is_at_end
000100  2800              CMP      r0,#0                 ;307
000102  d08c              BEQ      |L6.30|
000104  2002              MOVS     r0,#2                 ;310
000106  7038              STRB     r0,[r7,#0]            ;310
000108  2013              MOVS     r0,#0x13              ;311
00010a  e788              B        |L6.30|
;;;316    
                          ENDP

                  |L6.268|
                          DCD      ||.data||
                  |L6.272|
000110  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\flash_decoder"
000114  2e5c2e2e
000118  5c736f75
00011c  7263655c
000120  6461706c
000124  696e6b5c
000128  64726167
00012c  2d6e2d64
000130  726f705c
000134  666c6173
000138  685f6465
00013c  636f6465
000140  72      
000141  2e6300            DCB      ".c",0
                  |L6.324|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  flash_buf
                          %        48

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  flash_type
000001  00                DCB      0x00
                  flash_initialized
000002  00                DCB      0x00
                  initial_addr_set
000003  00                DCB      0x00
                  flash_type_target_bin
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  flash_buf_pos
                          DCD      0x00000000
                  initial_addr
                          DCD      0x00000000
                  current_addr
                          DCD      0x00000000
