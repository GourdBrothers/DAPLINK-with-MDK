; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\iap_flash_intf.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\iap_flash_intf.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\iap_flash_intf.crf ..\..\..\source\daplink\drag-n-drop\iap_flash_intf.c]
                          THUMB

                          AREA ||i.critical_erase_and_program||, CODE, READONLY, ALIGN=2

                  critical_erase_and_program PROC
;;;472    
;;;473    static error_t critical_erase_and_program(uint32_t addr, const uint8_t *data, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;474    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;475        uint32_t iap_status;
;;;476    
;;;477        if (size < DAPLINK_MIN_WRITE_SIZE) {
000008  f5b26f80          CMP      r2,#0x400
00000c  d207              BCS      |L1.30|
;;;478            util_assert(0);
00000e  f44f72ef          MOV      r2,#0x1de
000012  a10a              ADR      r1,|L1.60|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       _util_assert
;;;479            return ERROR_INTERNAL;
00001a  2002              MOVS     r0,#2
;;;480        }
;;;481    
;;;482        // CRITICAL SECTION BELOW HERE!
;;;483        // If something goes wrong with either
;;;484        // the erase or write then the device
;;;485        // will no longer be bootable.
;;;486        // Erase the first sector
;;;487        iap_status = flash_erase_sector(addr);
;;;488    
;;;489        if (iap_status != 0) {
;;;490            return ERROR_ERASE_ALL;
;;;491        }
;;;492    
;;;493        // Program the interface's vector table
;;;494        iap_status = flash_program_page(addr, size, (uint8_t *)data);
;;;495    
;;;496        if (iap_status != 0) {
;;;497            return ERROR_IAP_WRITE;
;;;498        }
;;;499    
;;;500        return ERROR_SUCCESS;
;;;501    }
00001c  bd70              POP      {r4-r6,pc}
                  |L1.30|
00001e  f7fffffe          BL       flash_erase_sector
000022  b108              CBZ      r0,|L1.40|
000024  2010              MOVS     r0,#0x10              ;490
                  |L1.38|
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  462a              MOV      r2,r5                 ;494
00002a  4621              MOV      r1,r4                 ;494
00002c  4630              MOV      r0,r6                 ;494
00002e  f7fffffe          BL       flash_program_page
000032  2800              CMP      r0,#0                 ;496
000034  d0f7              BEQ      |L1.38|
000036  201f              MOVS     r0,#0x1f              ;497
000038  bd70              POP      {r4-r6,pc}
;;;502    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
00003c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000040  2e5c2e2e
000044  5c736f75
000048  7263655c
00004c  6461706c
000050  696e6b5c
000054  64726167
000058  2d6e2d64
00005c  726f705c
000060  6961705f
000064  666c6173
000068  685f696e
00006c  74      
00006d  662e6300          DCB      "f.c",0
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.erase_chip||, CODE, READONLY, ALIGN=2

                  erase_chip PROC
;;;305    
;;;306    static error_t erase_chip(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;307    {
;;;308        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;309        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;310    
;;;311        if (state != STATE_OPEN) {
000004  4e15              LDR      r6,|L2.92|
000006  4d14              LDR      r5,|L2.88|
000008  f04f6400          MOV      r4,#0x8000000         ;308
00000c  7830              LDRB     r0,[r6,#0]  ; state
00000e  2801              CMP      r0,#1
000010  d006              BEQ      |L2.32|
;;;312            util_assert(0);
000012  f44f729c          MOV      r2,#0x138
000016  a112              ADR      r1,|L2.96|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       _util_assert
;;;313            return ERROR_INTERNAL;
00001e  e009              B        |L2.52|
                  |L2.32|
;;;314        }
;;;315    
;;;316        if (mass_erase_performed) {
000020  78b0              LDRB     r0,[r6,#2]  ; mass_erase_performed
000022  2702              MOVS     r7,#2                 ;313
000024  b148              CBZ      r0,|L2.58|
;;;317            // Mass erase only allowed once
;;;318            util_assert(0);
000026  f44f729f          MOV      r2,#0x13e
00002a  a10d              ADR      r1,|L2.96|
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       _util_assert
;;;319            state = STATE_ERROR;
000032  7037              STRB     r7,[r6,#0]
                  |L2.52|
;;;320            return ERROR_INTERNAL;
000034  2002              MOVS     r0,#2
                  |L2.54|
;;;321        }
;;;322    
;;;323        for (uint32_t addr = updt_start; addr < updt_end; addr += DAPLINK_SECTOR_SIZE) {
;;;324            error_t status;
;;;325            status = erase_sector(addr);
;;;326    
;;;327            if (status != ERROR_SUCCESS) {
;;;328                state = STATE_ERROR;
;;;329                return ERROR_IAP_ERASE_ALL;
;;;330            }
;;;331        }
;;;332    
;;;333        mass_erase_performed = true;
;;;334        return ERROR_SUCCESS;
;;;335    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L2.58|
00003a  4620              MOV      r0,r4                 ;325
00003c  f7fffffe          BL       erase_sector
000040  b110              CBZ      r0,|L2.72|
000042  7037              STRB     r7,[r6,#0]            ;328
000044  2021              MOVS     r0,#0x21              ;329
000046  e7f6              B        |L2.54|
                  |L2.72|
000048  f5046480          ADD      r4,r4,#0x400
00004c  42ac              CMP      r4,r5                 ;323
00004e  d3f4              BCC      |L2.58|
000050  2001              MOVS     r0,#1                 ;333
000052  70b0              STRB     r0,[r6,#2]            ;333
000054  2000              MOVS     r0,#0                 ;334
000056  e7ee              B        |L2.54|
;;;336    
                          ENDP

                  |L2.88|
                          DCD      0x0800bc00
                  |L2.92|
                          DCD      ||.data||
                  |L2.96|
000060  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000064  2e5c2e2e
000068  5c736f75
00006c  7263655c
000070  6461706c
000074  696e6b5c
000078  64726167
00007c  2d6e2d64
000080  726f705c
000084  6961705f
000088  666c6173
00008c  685f696e
000090  74      
000091  662e6300          DCB      "f.c",0
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.erase_sector||, CODE, READONLY, ALIGN=2

                  erase_sector PROC
;;;248    
;;;249    static error_t erase_sector(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
;;;251        uint32_t iap_status;
;;;252        error_t status;
;;;253        uint32_t sector_size;
;;;254    
;;;255        if (state != STATE_OPEN) {
000002  4e21              LDR      r6,|L3.136|
000004  4604              MOV      r4,r0                 ;250
000006  7830              LDRB     r0,[r6,#0]  ; state
000008  2801              CMP      r0,#1
00000a  d006              BEQ      |L3.26|
;;;256            util_assert(0);
00000c  f44f7280          MOV      r2,#0x100
000010  a11e              ADR      r1,|L3.140|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       _util_assert
;;;257            return ERROR_INTERNAL;
000018  e018              B        |L3.76|
                  |L3.26|
00001a  f44f6080          MOV      r0,#0x400
;;;258        }
;;;259    
;;;260        // Address must be on a sector boundary
;;;261        sector_size = erase_sector_size(addr);
;;;262    
;;;263        if (addr % sector_size != 0) {
00001e  fbb4f1f0          UDIV     r1,r4,r0
000022  fb004111          MLS      r1,r0,r1,r4
000026  2502              MOVS     r5,#2                 ;257
000028  b111              CBZ      r1,|L3.48|
;;;264            util_assert(0);
00002a  f44f7284          MOV      r2,#0x108
;;;265            state = STATE_ERROR;
;;;266            return ERROR_INTERNAL;
00002e  e008              B        |L3.66|
                  |L3.48|
;;;267        }
;;;268    
;;;269        // Address must be sequential - no gaps
;;;270        if (current_sector_set && (addr != current_sector + current_sector_size)) {
000030  78f1              LDRB     r1,[r6,#3]  ; current_sector_set
000032  b169              CBZ      r1,|L3.80|
000034  e9d61202          LDRD     r1,r2,[r6,#8]
000038  4411              ADD      r1,r1,r2
00003a  42a1              CMP      r1,r4
00003c  d008              BEQ      |L3.80|
;;;271            util_assert(0);
00003e  f240120f          MOV      r2,#0x10f
                  |L3.66|
000042  a112              ADR      r1,|L3.140|
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       _util_assert
;;;272            state = STATE_ERROR;
00004a  7035              STRB     r5,[r6,#0]
                  |L3.76|
;;;273            return ERROR_INTERNAL;
00004c  2002              MOVS     r0,#2
                  |L3.78|
;;;274        }
;;;275    
;;;276        if (!sector_erase_allowed(addr)) {
;;;277            state = STATE_ERROR;
;;;278            return ERROR_IAP_ERASE_SECTOR;
;;;279        }
;;;280    
;;;281        current_sector_set = true;
;;;282        current_sector = addr;
;;;283        current_sector_size = sector_size;
;;;284        status = intercept_sector_erase(addr);
;;;285    
;;;286        if (status != ERROR_IAP_NO_INTERCEPT) {
;;;287            // The operation has been intercepted so
;;;288            // return the result
;;;289            if (ERROR_SUCCESS != status) {
;;;290                state = STATE_ERROR;
;;;291            }
;;;292    
;;;293            return status;
;;;294        }
;;;295    
;;;296        iap_status = flash_erase_sector(addr);
;;;297    
;;;298        if (iap_status != 0) {
;;;299            state = STATE_ERROR;
;;;300            return ERROR_IAP_ERASE_SECTOR;
;;;301        }
;;;302    
;;;303        return ERROR_SUCCESS;
;;;304    }
00004e  bd70              POP      {r4-r6,pc}
                  |L3.80|
000050  4a1c              LDR      r2,|L3.196|
000052  491d              LDR      r1,|L3.200|
000054  4294              CMP      r4,r2
000056  d301              BCC      |L3.92|
000058  428c              CMP      r4,r1
00005a  d311              BCC      |L3.128|
                  |L3.92|
00005c  2101              MOVS     r1,#1
00005e  70f1              STRB     r1,[r6,#3]            ;281
000060  e9c64002          STRD     r4,r0,[r6,#8]         ;281
000064  4620              MOV      r0,r4                 ;284
000066  f7fffffe          BL       intercept_sector_erase
00006a  2825              CMP      r0,#0x25              ;286
00006c  d003              BEQ      |L3.118|
00006e  2800              CMP      r0,#0                 ;289
000070  d0ed              BEQ      |L3.78|
000072  7035              STRB     r5,[r6,#0]            ;290
                  |L3.116|
000074  bd70              POP      {r4-r6,pc}
                  |L3.118|
000076  4620              MOV      r0,r4                 ;296
000078  f7fffffe          BL       flash_erase_sector
00007c  2800              CMP      r0,#0                 ;298
00007e  d0f9              BEQ      |L3.116|
                  |L3.128|
000080  7035              STRB     r5,[r6,#0]            ;299
000082  2020              MOVS     r0,#0x20              ;300
000084  bd70              POP      {r4-r6,pc}
;;;305    
                          ENDP

000086  0000              DCW      0x0000
                  |L3.136|
                          DCD      ||.data||
                  |L3.140|
00008c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000090  2e5c2e2e
000094  5c736f75
000098  7263655c
00009c  6461706c
0000a0  696e6b5c
0000a4  64726167
0000a8  2d6e2d64
0000ac  726f705c
0000b0  6961705f
0000b4  666c6173
0000b8  685f696e
0000bc  74      
0000bd  662e6300          DCB      "f.c",0
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L3.196|
                          DCD      0x0800c000
                  |L3.200|
                          DCD      0x0801fc00

                          AREA ||i.erase_sector_size||, CODE, READONLY, ALIGN=1

                  erase_sector_size PROC
;;;341    
;;;342    static uint32_t erase_sector_size(uint32_t addr)
000000  f44f6080          MOV      r0,#0x400
;;;343    {
;;;344        return DAPLINK_SECTOR_SIZE;
;;;345    }
000004  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.init||, CODE, READONLY, ALIGN=2

                  init PROC
;;;92     
;;;93     static error_t init()
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95         int iap_status;
;;;96         bool update_supported = DAPLINK_ROM_UPDATE_SIZE != 0;
;;;97     
;;;98         if (state != STATE_CLOSED) {
000002  4c12              LDR      r4,|L5.76|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L5.22|
;;;99             util_assert(0);
000008  2263              MOVS     r2,#0x63
00000a  a111              ADR      r1,|L5.80|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       _util_assert
;;;100            return ERROR_INTERNAL;
000012  2002              MOVS     r0,#2
;;;101        }
;;;102    
;;;103        if (!update_supported) {
;;;104            return ERROR_IAP_UPDT_NOT_SUPPORTED;
;;;105        }
;;;106    
;;;107        iap_status = Init(0, 0, 0);
;;;108    
;;;109        if (iap_status != 0) {
;;;110            return ERROR_IAP_INIT;
;;;111        }
;;;112    
;;;113        update_complete = false;
;;;114        mass_erase_performed = false;
;;;115        current_sector_set = false;
;;;116        current_sector = 0;
;;;117        current_sector_size = 0;
;;;118        current_page_set = false;
;;;119        current_page = 0;
;;;120        current_page_write_size = 0;
;;;121        crc = 0;
;;;122        memset(sector_buf, 0, sizeof(sector_buf));
;;;123        state = STATE_OPEN;
;;;124        return ERROR_SUCCESS;
;;;125    }
000014  bd10              POP      {r4,pc}
                  |L5.22|
000016  2200              MOVS     r2,#0                 ;107
000018  4611              MOV      r1,r2                 ;107
00001a  4610              MOV      r0,r2                 ;107
00001c  f7fffffe          BL       Init
000020  b108              CBZ      r0,|L5.38|
000022  201d              MOVS     r0,#0x1d              ;110
000024  bd10              POP      {r4,pc}
                  |L5.38|
000026  2000              MOVS     r0,#0                 ;113
000028  7060              STRB     r0,[r4,#1]            ;113
00002a  70a0              STRB     r0,[r4,#2]            ;114
00002c  70e0              STRB     r0,[r4,#3]            ;115
00002e  60a0              STR      r0,[r4,#8]            ;117  ; current_sector
000030  60e0              STR      r0,[r4,#0xc]          ;118  ; current_sector_size
000032  7120              STRB     r0,[r4,#4]            ;118
000034  6120              STR      r0,[r4,#0x10]         ;120  ; current_page
000036  6160              STR      r0,[r4,#0x14]         ;121  ; current_page_write_size
000038  61a0              STR      r0,[r4,#0x18]         ;122  ; crc
00003a  f44f6180          MOV      r1,#0x400             ;122
00003e  4812              LDR      r0,|L5.136|
000040  f7fffffe          BL       __aeabi_memclr
000044  2001              MOVS     r0,#1                 ;123
000046  7020              STRB     r0,[r4,#0]            ;123
000048  2000              MOVS     r0,#0                 ;124
00004a  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  |L5.76|
                          DCD      ||.data||
                  |L5.80|
000050  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000054  2e5c2e2e
000058  5c736f75
00005c  7263655c
000060  6461706c
000064  696e6b5c
000068  64726167
00006c  2d6e2d64
000070  726f705c
000074  6961705f
000078  666c6173
00007c  685f696e
000080  74      
000081  662e6300          DCB      "f.c",0
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L5.136|
                          DCD      ||.bss||

                          AREA ||i.intercept_page_write||, CODE, READONLY, ALIGN=2

                  intercept_page_write PROC
;;;369    
;;;370    static error_t intercept_page_write(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;371    {
;;;372        error_t status;
;;;373        uint32_t crc_size;
;;;374        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;375        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;376    
;;;377        if (state != STATE_OPEN) {
000004  f8df90c8          LDR      r9,|L6.208|
000008  4604              MOV      r4,r0                 ;371
00000a  468b              MOV      r11,r1                ;371
00000c  f8990000          LDRB     r0,[r9,#0]  ; state
000010  4d2e              LDR      r5,|L6.204|
000012  4617              MOV      r7,r2                 ;371
000014  f04f6100          MOV      r1,#0x8000000         ;374
000018  2801              CMP      r0,#1
00001a  d008              BEQ      |L6.46|
;;;378            util_assert(0);
00001c  f44f72bd          MOV      r2,#0x17a
000020  a12c              ADR      r1,|L6.212|
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       _util_assert
;;;379            return ERROR_INTERNAL;
000028  2002              MOVS     r0,#2
                  |L6.42|
;;;380        }
;;;381    
;;;382        if ((addr < updt_start) || (addr >= updt_end)) {
;;;383            return ERROR_IAP_OUT_OF_BOUNDS;
;;;384        }
;;;385    
;;;386        if (!daplink_is_interface()) {
;;;387            return ERROR_IAP_NO_INTERCEPT;
;;;388        }
;;;389    
;;;390        /* Everything below here is interface specific */
;;;391        crc_size = MIN(size, updt_end - addr - 4);
;;;392        crc = crc32_continue(crc, buf, crc_size);
;;;393    
;;;394        // Intercept the data if it is in the first sector
;;;395        if ((addr >= updt_start) && (addr < updt_start + DAPLINK_SECTOR_SIZE)) {
;;;396            uint32_t buf_offset = addr - updt_start;
;;;397            memcpy(sector_buf + buf_offset, buf, size);
;;;398            // Intercept was successful
;;;399            return ERROR_SUCCESS;
;;;400        }
;;;401    
;;;402        // Finalize update if this is the last sector
;;;403        if (updt_end == addr + size) {
;;;404            uint32_t iap_status;
;;;405            uint32_t size_left = updt_end - addr;
;;;406            uint32_t crc_in_image = (buf[size_left - 4] << 0) |
;;;407                                    (buf[size_left - 3] << 8) |
;;;408                                    (buf[size_left - 2] << 16) |
;;;409                                    (buf[size_left - 1] << 24);
;;;410    
;;;411            if (crc != crc_in_image) {
;;;412                return ERROR_BL_UPDT_BAD_CRC;
;;;413            }
;;;414    
;;;415            // Program the current buffer
;;;416            iap_status = flash_program_page(addr, size, (uint8_t *)buf);
;;;417    
;;;418            if (iap_status != 0) {
;;;419                return ERROR_IAP_WRITE;
;;;420            }
;;;421    
;;;422            status = critical_erase_and_program(DAPLINK_ROM_UPDATE_START, sector_buf, DAPLINK_SECTOR_SIZE);
;;;423    
;;;424            if (ERROR_SUCCESS == status) {
;;;425                status = ERROR_SUCCESS;
;;;426            }
;;;427    
;;;428            // The bootloader has been updated so recompute the crc
;;;429            info_crc_compute();
;;;430            update_complete = true;
;;;431            return status;
;;;432        }
;;;433    
;;;434        return ERROR_IAP_NO_INTERCEPT;
;;;435    }
00002a  e8bd9ff0          POP      {r4-r12,pc}
                  |L6.46|
00002e  468a              MOV      r10,r1                ;382
000030  4554              CMP      r4,r10                ;382
000032  d301              BCC      |L6.56|
000034  42ac              CMP      r4,r5                 ;382
000036  d301              BCC      |L6.60|
                  |L6.56|
000038  2022              MOVS     r0,#0x22              ;383
00003a  e7f6              B        |L6.42|
                  |L6.60|
00003c  f7fffffe          BL       daplink_is_interface
000040  b3a0              CBZ      r0,|L6.172|
000042  1b2e              SUBS     r6,r5,r4              ;391
000044  1f30              SUBS     r0,r6,#4              ;391
000046  42b8              CMP      r0,r7                 ;391
000048  d901              BLS      |L6.78|
00004a  463a              MOV      r2,r7                 ;391
00004c  e000              B        |L6.80|
                  |L6.78|
00004e  1f32              SUBS     r2,r6,#4              ;391
                  |L6.80|
000050  4659              MOV      r1,r11                ;392
000052  f8d90018          LDR      r0,[r9,#0x18]         ;392  ; crc
000056  f7fffffe          BL       crc32_continue
00005a  4680              MOV      r8,r0                 ;392
00005c  f8c90018          STR      r0,[r9,#0x18]         ;395  ; crc
000060  482a              LDR      r0,|L6.268|
000062  4284              CMP      r4,r0                 ;395
000064  d209              BCS      |L6.122|
000066  482a              LDR      r0,|L6.272|
000068  f1a46400          SUB      r4,r4,#0x8000000      ;397
00006c  4420              ADD      r0,r0,r4              ;397
00006e  463a              MOV      r2,r7                 ;397
000070  4659              MOV      r1,r11                ;397
000072  f7fffffe          BL       __aeabi_memcpy
000076  2000              MOVS     r0,#0                 ;399
000078  e7d7              B        |L6.42|
                  |L6.122|
00007a  19e0              ADDS     r0,r4,r7              ;403
00007c  42a8              CMP      r0,r5                 ;403
00007e  d123              BNE      |L6.200|
000080  eb0b0006          ADD      r0,r11,r6             ;406
000084  f8105c01          LDRB     r5,[r0,#-1]           ;406
000088  1f00              SUBS     r0,r0,#4              ;406
00008a  f7fffffe          BL       __aeabi_uread4
00008e  f365601f          BFI      r0,r5,#24,#8          ;406
000092  464d              MOV      r5,r9                 ;411
000094  4580              CMP      r8,r0                 ;411
000096  d001              BEQ      |L6.156|
000098  2026              MOVS     r0,#0x26              ;412
00009a  e7c6              B        |L6.42|
                  |L6.156|
00009c  465a              MOV      r2,r11                ;416
00009e  4639              MOV      r1,r7                 ;416
0000a0  4620              MOV      r0,r4                 ;416
0000a2  f7fffffe          BL       flash_program_page
0000a6  b110              CBZ      r0,|L6.174|
0000a8  201f              MOVS     r0,#0x1f              ;419
0000aa  e7be              B        |L6.42|
                  |L6.172|
0000ac  e00c              B        |L6.200|
                  |L6.174|
0000ae  f44f6280          MOV      r2,#0x400             ;422
0000b2  4917              LDR      r1,|L6.272|
0000b4  4650              MOV      r0,r10                ;422
0000b6  f7fffffe          BL       critical_erase_and_program
0000ba  4604              MOV      r4,r0                 ;422
0000bc  f7fffffe          BL       info_crc_compute
0000c0  2001              MOVS     r0,#1                 ;430
0000c2  7068              STRB     r0,[r5,#1]            ;430
0000c4  4620              MOV      r0,r4                 ;431
0000c6  e7b0              B        |L6.42|
                  |L6.200|
0000c8  2025              MOVS     r0,#0x25              ;434
0000ca  e7ae              B        |L6.42|
;;;436    
                          ENDP

                  |L6.204|
                          DCD      0x0800bc00
                  |L6.208|
                          DCD      ||.data||
                  |L6.212|
0000d4  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
0000d8  2e5c2e2e
0000dc  5c736f75
0000e0  7263655c
0000e4  6461706c
0000e8  696e6b5c
0000ec  64726167
0000f0  2d6e2d64
0000f4  726f705c
0000f8  6961705f
0000fc  666c6173
000100  685f696e
000104  74      
000105  662e6300          DCB      "f.c",0
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L6.268|
                          DCD      0x08000400
                  |L6.272|
                          DCD      ||.bss||

                          AREA ||i.intercept_sector_erase||, CODE, READONLY, ALIGN=2

                  intercept_sector_erase PROC
;;;436    
;;;437    static error_t intercept_sector_erase(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;438    {
;;;439        error_t status;
;;;440        uint32_t updt_start = DAPLINK_ROM_UPDATE_START;
;;;441        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;442    
;;;443        if (state != STATE_OPEN) {
000002  4913              LDR      r1,|L7.80|
000004  4604              MOV      r4,r0                 ;438
000006  4811              LDR      r0,|L7.76|
000008  7809              LDRB     r1,[r1,#0]  ; state
00000a  f04f6500          MOV      r5,#0x8000000         ;440
00000e  2901              CMP      r1,#1
000010  d007              BEQ      |L7.34|
;;;444            util_assert(0);
000012  f44f72de          MOV      r2,#0x1bc
000016  a10f              ADR      r1,|L7.84|
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       _util_assert
;;;445            return ERROR_INTERNAL;
00001e  2002              MOVS     r0,#2
;;;446        }
;;;447    
;;;448        if ((addr < updt_start) || (addr >= updt_end)) {
;;;449            return ERROR_IAP_OUT_OF_BOUNDS;
;;;450        }
;;;451    
;;;452        if (!daplink_is_interface()) {
;;;453            return ERROR_IAP_NO_INTERCEPT;
;;;454        }
;;;455    
;;;456        /* Everything below here is interface specific */
;;;457    
;;;458        if (DAPLINK_ROM_UPDATE_START == addr) {
;;;459            uint32_t addr = DAPLINK_ROM_UPDATE_START;
;;;460            status = critical_erase_and_program(addr, (uint8_t *)DAPLINK_ROM_IF_START, DAPLINK_MIN_WRITE_SIZE);
;;;461    
;;;462            if (ERROR_SUCCESS == status) {
;;;463                // Intercept was successful
;;;464                status = ERROR_SUCCESS;
;;;465            }
;;;466    
;;;467            return status;
;;;468        }
;;;469    
;;;470        return ERROR_IAP_NO_INTERCEPT;
;;;471    }
000020  bd70              POP      {r4-r6,pc}
                  |L7.34|
000022  42ac              CMP      r4,r5                 ;448
000024  d301              BCC      |L7.42|
000026  4284              CMP      r4,r0                 ;448
000028  d301              BCC      |L7.46|
                  |L7.42|
00002a  2022              MOVS     r0,#0x22              ;449
00002c  bd70              POP      {r4-r6,pc}
                  |L7.46|
00002e  f7fffffe          BL       daplink_is_interface
000032  b148              CBZ      r0,|L7.72|
000034  42ac              CMP      r4,r5                 ;458
000036  d107              BNE      |L7.72|
000038  4628              MOV      r0,r5                 ;459
00003a  e8bd4070          POP      {r4-r6,lr}            ;460
00003e  f44f6280          MOV      r2,#0x400             ;460
000042  4912              LDR      r1,|L7.140|
000044  f7ffbffe          B.W      critical_erase_and_program
                  |L7.72|
000048  2025              MOVS     r0,#0x25              ;470
00004a  bd70              POP      {r4-r6,pc}
;;;472    
                          ENDP

                  |L7.76|
                          DCD      0x0800bc00
                  |L7.80|
                          DCD      ||.data||
                  |L7.84|
000054  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000058  2e5c2e2e
00005c  5c736f75
000060  7263655c
000064  6461706c
000068  696e6b5c
00006c  64726167
000070  2d6e2d64
000074  726f705c
000078  6961705f
00007c  666c6173
000080  685f696e
000084  74      
000085  662e6300          DCB      "f.c",0
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L7.140|
                          DCD      0x0800c000

                          AREA ||i.program_page||, CODE, READONLY, ALIGN=2

                  program_page PROC
;;;153    
;;;154    static error_t program_page(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;155    {
;;;156        uint32_t iap_status;
;;;157        error_t status;
;;;158        uint32_t min_prog_size;
;;;159        uint32_t sector_size;
;;;160        uint32_t updt_end = DAPLINK_ROM_UPDATE_START + DAPLINK_ROM_UPDATE_SIZE;
;;;161    
;;;162        if (state != STATE_OPEN) {
000004  f8df8100          LDR      r8,|L8.264|
000008  4604              MOV      r4,r0                 ;155
00000a  f8df90f8          LDR      r9,|L8.260|
00000e  f8980000          LDRB     r0,[r8,#0]  ; state
000012  4615              MOV      r5,r2                 ;155
000014  468b              MOV      r11,r1                ;155
000016  2801              CMP      r0,#1
000018  d005              BEQ      |L8.38|
;;;163            util_assert(0);
00001a  22a3              MOVS     r2,#0xa3
00001c  a13b              ADR      r1,|L8.268|
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       _util_assert
;;;164            return ERROR_INTERNAL;
000024  e03f              B        |L8.166|
                  |L8.38|
000026  f44f6080          MOV      r0,#0x400
;;;165        }
;;;166    
;;;167        min_prog_size = program_page_min_size(addr);
;;;168        sector_size = erase_sector_size(addr);
;;;169    
;;;170        // Address must be on a write size boundary
;;;171        if (addr % min_prog_size != 0) {
00002a  fbb4f3f0          UDIV     r3,r4,r0
00002e  fb004313          MLS      r3,r0,r3,r4
000032  4601              MOV      r1,r0                 ;168
000034  2602              MOVS     r6,#2                 ;164
000036  b10b              CBZ      r3,|L8.60|
;;;172            util_assert(0);
000038  22ac              MOVS     r2,#0xac
;;;173            state = STATE_ERROR;
;;;174            return ERROR_INTERNAL;
00003a  e02e              B        |L8.154|
                  |L8.60|
;;;175        }
;;;176    
;;;177        // Programming size must be a non-zero multiple of the minimum write size
;;;178        if ((size < min_prog_size) || (size % min_prog_size != 0)) {
00003c  460a              MOV      r2,r1
00003e  4295              CMP      r5,r2
000040  d304              BCC      |L8.76|
000042  fbb5f3f0          UDIV     r3,r5,r0
000046  fb025013          MLS      r0,r2,r3,r5
00004a  b108              CBZ      r0,|L8.80|
                  |L8.76|
;;;179            util_assert(0);
00004c  22b3              MOVS     r2,#0xb3
;;;180            state = STATE_ERROR;
;;;181            return ERROR_INTERNAL;
00004e  e024              B        |L8.154|
                  |L8.80|
;;;182        }
;;;183    
;;;184        // Write must not cross a sector boundary
;;;185        if ((addr % sector_size) + size > sector_size) {
000050  fbb4f0f1          UDIV     r0,r4,r1
000054  fb024010          MLS      r0,r2,r0,r4
000058  4428              ADD      r0,r0,r5
00005a  4288              CMP      r0,r1
00005c  d901              BLS      |L8.98|
;;;186            util_assert(0);
00005e  22ba              MOVS     r2,#0xba
;;;187            state = STATE_ERROR;
;;;188            return ERROR_INTERNAL;
000060  e01b              B        |L8.154|
                  |L8.98|
;;;189        }
;;;190    
;;;191        // Write must be in an erased sector (current_sector is always erased if it is set)
;;;192        if (!mass_erase_performed) {
000062  f8980002          LDRB     r0,[r8,#2]  ; mass_erase_performed
000066  b978              CBNZ     r0,|L8.136|
;;;193            if (!current_sector_set) {
000068  f8980003          LDRB     r0,[r8,#3]  ; current_sector_set
00006c  b150              CBZ      r0,|L8.132|
;;;194                util_assert(0);
;;;195                state = STATE_ERROR;
;;;196                return ERROR_INTERNAL;
;;;197            }
;;;198    
;;;199            if ((addr < current_sector) || (addr >= current_sector + current_sector_size)) {
00006e  f8d80008          LDR      r0,[r8,#8]  ; current_sector
000072  4284              CMP      r4,r0
000074  d304              BCC      |L8.128|
000076  f8d8100c          LDR      r1,[r8,#0xc]  ; current_sector_size
00007a  4408              ADD      r0,r0,r1
00007c  42a0              CMP      r0,r4
00007e  d803              BHI      |L8.136|
                  |L8.128|
;;;200                util_assert(0);
000080  22c8              MOVS     r2,#0xc8
;;;201                state = STATE_ERROR;
;;;202                return ERROR_INTERNAL;
000082  e00a              B        |L8.154|
                  |L8.132|
000084  22c2              MOVS     r2,#0xc2              ;194
000086  e008              B        |L8.154|
                  |L8.136|
;;;203            }
;;;204        }
;;;205    
;;;206        // Address must be sequential - no gaps
;;;207        if (current_page_set && (addr != current_page + current_page_write_size)) {
000088  f8980004          LDRB     r0,[r8,#4]  ; current_page_set
00008c  b170              CBZ      r0,|L8.172|
00008e  e9d80104          LDRD     r0,r1,[r8,#0x10]
000092  4408              ADD      r0,r0,r1
000094  42a0              CMP      r0,r4
000096  d009              BEQ      |L8.172|
;;;208            util_assert(0);
000098  22d0              MOVS     r2,#0xd0
                  |L8.154|
00009a  a11c              ADR      r1,|L8.268|
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       _util_assert
;;;209            state = STATE_ERROR;
0000a2  f8886000          STRB     r6,[r8,#0]
                  |L8.166|
;;;210            return ERROR_INTERNAL;
0000a6  2002              MOVS     r0,#2
                  |L8.168|
;;;211        }
;;;212    
;;;213        if (!page_program_allowed(addr, size)) {
;;;214            state = STATE_ERROR;
;;;215            return ERROR_IAP_WRITE;
;;;216        }
;;;217    
;;;218        current_page_set = true;
;;;219        current_page = addr;
;;;220        current_page_write_size = size;
;;;221        status = intercept_page_write(addr, buf, size);
;;;222    
;;;223        if (status != ERROR_IAP_NO_INTERCEPT) {
;;;224            // The operation has been intercepted so
;;;225            // return the result
;;;226            if (ERROR_SUCCESS != status) {
;;;227                state = STATE_ERROR;
;;;228            }
;;;229    
;;;230            return status;
;;;231        }
;;;232    
;;;233        iap_status = flash_program_page(addr, size, (uint8_t *)buf);
;;;234    
;;;235        if (iap_status != 0) {
;;;236            state = STATE_ERROR;
;;;237            return ERROR_IAP_WRITE;
;;;238        }
;;;239    
;;;240        if (addr + size >= updt_end) {
;;;241            // Something has been updated so recompute the crc
;;;242            info_crc_compute();
;;;243            update_complete = true;
;;;244        }
;;;245    
;;;246        return ERROR_SUCCESS;
;;;247    }
0000a8  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.172|
0000ac  4825              LDR      r0,|L8.324|
0000ae  1967              ADDS     r7,r4,r5
0000b0  4284              CMP      r4,r0
0000b2  d202              BCS      |L8.186|
0000b4  4824              LDR      r0,|L8.328|
0000b6  4287              CMP      r7,r0
0000b8  d817              BHI      |L8.234|
                  |L8.186|
0000ba  f04f0a01          MOV      r10,#1                ;218
0000be  f888a004          STRB     r10,[r8,#4]           ;218
0000c2  462a              MOV      r2,r5                 ;221
0000c4  4659              MOV      r1,r11                ;221
0000c6  4620              MOV      r0,r4                 ;221
0000c8  e9c84504          STRD     r4,r5,[r8,#0x10]      ;221
0000cc  f7fffffe          BL       intercept_page_write
0000d0  2825              CMP      r0,#0x25              ;223
0000d2  d004              BEQ      |L8.222|
0000d4  2800              CMP      r0,#0                 ;226
0000d6  d0e7              BEQ      |L8.168|
0000d8  f8886000          STRB     r6,[r8,#0]            ;227
0000dc  e7e4              B        |L8.168|
                  |L8.222|
0000de  465a              MOV      r2,r11                ;233
0000e0  4629              MOV      r1,r5                 ;233
0000e2  4620              MOV      r0,r4                 ;233
0000e4  f7fffffe          BL       flash_program_page
0000e8  b118              CBZ      r0,|L8.242|
                  |L8.234|
0000ea  f8886000          STRB     r6,[r8,#0]            ;236
0000ee  201f              MOVS     r0,#0x1f              ;237
0000f0  e7da              B        |L8.168|
                  |L8.242|
0000f2  454f              CMP      r7,r9                 ;240
0000f4  d303              BCC      |L8.254|
0000f6  f7fffffe          BL       info_crc_compute
0000fa  f888a001          STRB     r10,[r8,#1]           ;243
                  |L8.254|
0000fe  2000              MOVS     r0,#0                 ;246
000100  e7d2              B        |L8.168|
;;;248    
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      0x0800bc00
                  |L8.264|
                          DCD      ||.data||
                  |L8.268|
00010c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000110  2e5c2e2e
000114  5c736f75
000118  7263655c
00011c  6461706c
000120  696e6b5c
000124  64726167
000128  2d6e2d64
00012c  726f705c
000130  6961705f
000134  666c6173
000138  685f696e
00013c  74      
00013d  662e6300          DCB      "f.c",0
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0
                  |L8.324|
                          DCD      0x0801fc00
                  |L8.328|
                          DCD      0x0800c000

                          AREA ||i.program_page_min_size||, CODE, READONLY, ALIGN=1

                  program_page_min_size PROC
;;;336    
;;;337    static uint32_t program_page_min_size(uint32_t addr)
000000  f44f6080          MOV      r0,#0x400
;;;338    {
;;;339        return DAPLINK_MIN_WRITE_SIZE;
;;;340    }
000004  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.target_flash_busy||, CODE, READONLY, ALIGN=2

                  target_flash_busy PROC
;;;502    
;;;503    static uint8_t target_flash_busy(void){
000000  4802              LDR      r0,|L10.12|
;;;504        return (state == STATE_OPEN);
000002  7800              LDRB     r0,[r0,#0]  ; state
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L10.10|
000008  2000              MOVS     r0,#0
                  |L10.10|
;;;505    }
00000a  4770              BX       lr
                          ENDP

                  |L10.12|
                          DCD      ||.data||

                          AREA ||i.uninit||, CODE, READONLY, ALIGN=2

                  uninit PROC
;;;126    
;;;127    static error_t uninit(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129        int iap_status;
;;;130    
;;;131        if (STATE_CLOSED == state) {
000002  4c0d              LDR      r4,|L11.56|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b130              CBZ      r0,|L11.22|
;;;132            util_assert(0);
;;;133            return ERROR_INTERNAL;
;;;134        }
;;;135    
;;;136        state = STATE_CLOSED;
000008  2000              MOVS     r0,#0
00000a  7020              STRB     r0,[r4,#0]
;;;137        iap_status = UnInit(0);
00000c  f7fffffe          BL       UnInit
;;;138    
;;;139        if (iap_status != 0) {
000010  b140              CBZ      r0,|L11.36|
;;;140            return ERROR_IAP_UNINIT;
000012  201e              MOVS     r0,#0x1e
;;;141        }
;;;142    
;;;143        if (!update_complete && !daplink_is_bootloader()) {
;;;144            // Interface - Error if the bootloader update is not complete
;;;145            // Bootloader - For 3rd party applications the end of the update
;;;146            //              is unknown so it is not an error if the transfer
;;;147            //              ends early.
;;;148            return ERROR_IAP_UPDT_INCOMPLETE;
;;;149        }
;;;150    
;;;151        return ERROR_SUCCESS;
;;;152    }
000014  bd10              POP      {r4,pc}
                  |L11.22|
000016  2284              MOVS     r2,#0x84              ;132
000018  a108              ADR      r1,|L11.60|
00001a  2000              MOVS     r0,#0                 ;132
00001c  f7fffffe          BL       _util_assert
000020  2002              MOVS     r0,#2                 ;133
000022  bd10              POP      {r4,pc}
                  |L11.36|
000024  7860              LDRB     r0,[r4,#1]            ;143  ; update_complete
000026  b910              CBNZ     r0,|L11.46|
000028  f7fffffe          BL       daplink_is_bootloader
00002c  b108              CBZ      r0,|L11.50|
                  |L11.46|
00002e  2000              MOVS     r0,#0                 ;151
000030  bd10              POP      {r4,pc}
                  |L11.50|
000032  2024              MOVS     r0,#0x24              ;148
000034  bd10              POP      {r4,pc}
;;;153    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      ||.data||
                  |L11.60|
00003c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\iap_flash_int"
000040  2e5c2e2e
000044  5c736f75
000048  7263655c
00004c  6461706c
000050  696e6b5c
000054  64726167
000058  2d6e2d64
00005c  726f705c
000060  6961705f
000064  666c6173
000068  685f696e
00006c  74      
00006d  662e6300          DCB      "f.c",0
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  sector_buf
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  flash_intf
                          DCD      init
                          DCD      uninit
                          DCD      program_page
                          DCD      erase_sector
                          DCD      erase_chip
                          DCD      program_page_min_size
                          DCD      erase_sector_size
                          DCD      target_flash_busy
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.constdata||
                  flash_intf_iap_protected
                          DCD      flash_intf

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  update_complete
000001  00                DCB      0x00
                  mass_erase_performed
000002  00                DCB      0x00
                  current_sector_set
000003  00                DCB      0x00
                  current_page_set
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  current_sector
                          DCD      0x00000000
                  current_sector_size
                          DCD      0x00000000
                  current_page
                          DCD      0x00000000
                  current_page_write_size
                          DCD      0x00000000
                  ||crc||
                          DCD      0x00000000
