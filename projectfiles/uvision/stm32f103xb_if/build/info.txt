; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\info.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\info.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\info.crf ..\..\..\source\daplink\info.c]
                          THUMB

                          AREA ||i.hex_to_ascii||, CODE, READONLY, ALIGN=1

                  hex_to_ascii PROC
;;;33     
;;;34     static char hex_to_ascii(uint8_t x)
000000  2809              CMP      r0,#9
;;;35     {
000002  d900              BLS      |L1.6|
000004  3027              ADDS     r0,r0,#0x27
                  |L1.6|
000006  3030              ADDS     r0,r0,#0x30
;;;36         return ('0' + (x>9 ? x+0x27 : x));
000008  b2c0              UXTB     r0,r0
;;;37     }
00000a  4770              BX       lr
;;;38     
                          ENDP


                          AREA ||i.info_crc_compute||, CODE, READONLY, ALIGN=2

                  info_crc_compute PROC
;;;295    
;;;296    void info_crc_compute()
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298        crc_bootloader = 0;
000002  4913              LDR      r1,|L2.80|
000004  2000              MOVS     r0,#0
000006  6008              STR      r0,[r1,#0]  ; crc_bootloader
;;;299        crc_interface = 0;
000008  4912              LDR      r1,|L2.84|
00000a  6008              STR      r0,[r1,#0]  ; crc_interface
;;;300        crc_config_admin = 0;
00000c  4912              LDR      r1,|L2.88|
00000e  6008              STR      r0,[r1,#0]  ; crc_config_admin
;;;301        crc_config_user = 0;
000010  4912              LDR      r1,|L2.92|
000012  6008              STR      r0,[r1,#0]  ; crc_config_user
;;;302    
;;;303        // Compute the CRCs of regions that exist
;;;304        if (DAPLINK_ROM_BL_SIZE > 0) {
;;;305            crc_bootloader = crc32((void *)DAPLINK_ROM_BL_START, DAPLINK_ROM_BL_SIZE - 4);
000014  f64b31fc          MOV      r1,#0xbbfc
000018  f04f6000          MOV      r0,#0x8000000
00001c  f7fffffe          BL       crc32
000020  490b              LDR      r1,|L2.80|
000022  6008              STR      r0,[r1,#0]  ; crc_bootloader
;;;306        }
;;;307    
;;;308        if (DAPLINK_ROM_IF_SIZE > 0) {
;;;309            crc_interface = crc32((void *)DAPLINK_ROM_IF_START, DAPLINK_ROM_IF_SIZE - 4);
000024  490e              LDR      r1,|L2.96|
000026  480f              LDR      r0,|L2.100|
000028  f7fffffe          BL       crc32
00002c  4909              LDR      r1,|L2.84|
00002e  6008              STR      r0,[r1,#0]  ; crc_interface
;;;310        }
;;;311    
;;;312        if (DAPLINK_ROM_CONFIG_ADMIN_SIZE > 0) {
;;;313            crc_config_admin = crc32((void *)DAPLINK_ROM_CONFIG_ADMIN_START, DAPLINK_ROM_CONFIG_ADMIN_SIZE);
000030  f44f6180          MOV      r1,#0x400
000034  480c              LDR      r0,|L2.104|
000036  f7fffffe          BL       crc32
00003a  4907              LDR      r1,|L2.88|
00003c  6008              STR      r0,[r1,#0]  ; crc_config_admin
;;;314        }
;;;315    
;;;316        if (DAPLINK_ROM_CONFIG_USER_SIZE > 0) {
;;;317            crc_config_user = crc32((void *)DAPLINK_ROM_CONFIG_USER_START, DAPLINK_ROM_CONFIG_USER_SIZE);
00003e  f44f6180          MOV      r1,#0x400
000042  480a              LDR      r0,|L2.108|
000044  f7fffffe          BL       crc32
000048  4904              LDR      r1,|L2.92|
00004a  6008              STR      r0,[r1,#0]  ; crc_config_user
;;;318        }
;;;319    }
00004c  bd10              POP      {r4,pc}
;;;320    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      crc_bootloader
                  |L2.84|
                          DCD      crc_interface
                  |L2.88|
                          DCD      crc_config_admin
                  |L2.92|
                          DCD      crc_config_user
                  |L2.96|
                          DCD      0x00013bfc
                  |L2.100|
                          DCD      0x0800c000
                  |L2.104|
                          DCD      0x0800bc00
                  |L2.108|
                          DCD      0x0801fc00

                          AREA ||i.info_get_board_id||, CODE, READONLY, ALIGN=2

                  info_get_board_id PROC
;;;70     
;;;71     const char *info_get_board_id(void)
000000  4800              LDR      r0,|L3.4|
;;;72     {
;;;73         return string_board_id;
;;;74     }
000002  4770              BX       lr
;;;75     
                          ENDP

                  |L3.4|
                          DCD      ||.data||+0x14

                          AREA ||i.info_get_bootloader_present||, CODE, READONLY, ALIGN=2

                  info_get_bootloader_present PROC
;;;225    
;;;226    bool info_get_bootloader_present(void)
000000  2001              MOVS     r0,#1
;;;227    {
;;;228        bool present = true;
;;;229    
;;;230        if (0 == DAPLINK_ROM_BL_SIZE) {
;;;231            present = false;
;;;232        }
;;;233    
;;;234        if (DAPLINK_BUILD_KEY_BL != info_bl->build_key) {
000002  06c1              LSLS     r1,r0,#27
000004  4a06              LDR      r2,|L4.32|
000006  6a09              LDR      r1,[r1,#0x20]
000008  4291              CMP      r1,r2
00000a  d000              BEQ      |L4.14|
;;;235            present = false;
00000c  2000              MOVS     r0,#0
                  |L4.14|
;;;236        }
;;;237    
;;;238        if (DAPLINK_HIC_ID != info_bl->hic_id) {
00000e  f04f6100          MOV      r1,#0x8000000
000012  4a04              LDR      r2,|L4.36|
000014  6a49              LDR      r1,[r1,#0x24]
000016  4291              CMP      r1,r2
000018  d000              BEQ      |L4.28|
;;;239            present = false;
00001a  2000              MOVS     r0,#0
                  |L4.28|
;;;240        }
;;;241    
;;;242        return present;
;;;243    }
00001c  4770              BX       lr
;;;244    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x9b939d93
                  |L4.36|
                          DCD      0x97969908

                          AREA ||i.info_get_bootloader_version||, CODE, READONLY, ALIGN=1

                  info_get_bootloader_version PROC
;;;321    // Get version info as an integer
;;;322    uint32_t info_get_bootloader_version(void)
000000  b500              PUSH     {lr}
;;;323    {
;;;324        // Don't read version if image is not present
;;;325        if (!info_get_bootloader_present()) {
000002  f7fffffe          BL       info_get_bootloader_present
000006  b908              CBNZ     r0,|L5.12|
;;;326            return 0;
000008  2000              MOVS     r0,#0
                  |L5.10|
;;;327        }
;;;328    
;;;329        return info_bl->version;
;;;330    }
00000a  bd00              POP      {pc}
                  |L5.12|
00000c  f04f6000          MOV      r0,#0x8000000         ;329
000010  6a80              LDR      r0,[r0,#0x28]         ;329
000012  e7fa              B        |L5.10|
;;;331    
                          ENDP


                          AREA ||i.info_get_config_admin_present||, CODE, READONLY, ALIGN=1

                  info_get_config_admin_present PROC
;;;263    
;;;264    bool info_get_config_admin_present(void)
000000  2000              MOVS     r0,#0
;;;265    {
;;;266        //TODO, c1728p9 - check if admin config has been loaded
;;;267        return false;
;;;268    }
000002  4770              BX       lr
;;;269    
                          ENDP


                          AREA ||i.info_get_config_user_present||, CODE, READONLY, ALIGN=1

                  info_get_config_user_present PROC
;;;269    
;;;270    bool info_get_config_user_present(void)
000000  2000              MOVS     r0,#0
;;;271    {
;;;272        //TODO, c1728p9 - check if user config has a valid key
;;;273        return false;
;;;274    }
000002  4770              BX       lr
;;;275    
                          ENDP


                          AREA ||i.info_get_crc_bootloader||, CODE, READONLY, ALIGN=2

                  info_get_crc_bootloader PROC
;;;275    
;;;276    uint32_t info_get_crc_bootloader()
000000  4801              LDR      r0,|L8.8|
;;;277    {
;;;278        return crc_bootloader;
000002  6800              LDR      r0,[r0,#0]  ; crc_bootloader
;;;279    }
000004  4770              BX       lr
;;;280    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      crc_bootloader

                          AREA ||i.info_get_crc_config_admin||, CODE, READONLY, ALIGN=2

                  info_get_crc_config_admin PROC
;;;285    
;;;286    uint32_t info_get_crc_config_admin()
000000  4801              LDR      r0,|L9.8|
;;;287    {
;;;288        return crc_config_admin;
000002  6800              LDR      r0,[r0,#0]  ; crc_config_admin
;;;289    }
000004  4770              BX       lr
;;;290    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      crc_config_admin

                          AREA ||i.info_get_crc_config_user||, CODE, READONLY, ALIGN=2

                  info_get_crc_config_user PROC
;;;290    
;;;291    uint32_t info_get_crc_config_user()
000000  4801              LDR      r0,|L10.8|
;;;292    {
;;;293        return crc_config_user;
000002  6800              LDR      r0,[r0,#0]  ; crc_config_user
;;;294    }
000004  4770              BX       lr
;;;295    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      crc_config_user

                          AREA ||i.info_get_crc_interface||, CODE, READONLY, ALIGN=2

                  info_get_crc_interface PROC
;;;280    
;;;281    uint32_t info_get_crc_interface()
000000  4801              LDR      r0,|L11.8|
;;;282    {
;;;283        return crc_interface;
000002  6800              LDR      r0,[r0,#0]  ; crc_interface
;;;284    }
000004  4770              BX       lr
;;;285    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      crc_interface

                          AREA ||i.info_get_hic_id||, CODE, READONLY, ALIGN=2

                  info_get_hic_id PROC
;;;85     
;;;86     const char *info_get_hic_id(void)
000000  4800              LDR      r0,|L12.4|
;;;87     {
;;;88         return string_hic_id;
;;;89     }
000002  4770              BX       lr
;;;90     const char *info_get_version(void)
                          ENDP

                  |L12.4|
                          DCD      ||.bss||+0xa0

                          AREA ||i.info_get_host_id||, CODE, READONLY, ALIGN=2

                  info_get_host_id PROC
;;;75     
;;;76     const char *info_get_host_id(void)
000000  4800              LDR      r0,|L13.4|
;;;77     {
;;;78         return string_host_id;
;;;79     }
000002  4770              BX       lr
;;;80     
                          ENDP

                  |L13.4|
                          DCD      ||.bss||+0x5e

                          AREA ||i.info_get_interface_present||, CODE, READONLY, ALIGN=2

                  info_get_interface_present PROC
;;;244    
;;;245    bool info_get_interface_present(void)
000000  2001              MOVS     r0,#1
;;;246    {
;;;247        bool present = true;
;;;248    
;;;249        if (0 == DAPLINK_ROM_IF_SIZE) {
;;;250            present = false;
;;;251        }
;;;252    
;;;253        if (DAPLINK_BUILD_KEY_IF != info_if->build_key) {
000002  4906              LDR      r1,|L14.28|
000004  4a06              LDR      r2,|L14.32|
000006  6a09              LDR      r1,[r1,#0x20]
000008  4291              CMP      r1,r2
00000a  d000              BEQ      |L14.14|
;;;254            present = false;
00000c  2000              MOVS     r0,#0
                  |L14.14|
;;;255        }
;;;256    
;;;257        if (DAPLINK_HIC_ID != info_if->hic_id) {
00000e  4903              LDR      r1,|L14.28|
000010  4a04              LDR      r2,|L14.36|
000012  6a49              LDR      r1,[r1,#0x24]
000014  4291              CMP      r1,r2
000016  d000              BEQ      |L14.26|
;;;258            present = false;
000018  2000              MOVS     r0,#0
                  |L14.26|
;;;259        }
;;;260    
;;;261        return present;
;;;262    }
00001a  4770              BX       lr
;;;263    
                          ENDP

                  |L14.28|
                          DCD      0x0800c000
                  |L14.32|
                          DCD      0x9b939e8f
                  |L14.36|
                          DCD      0x97969908

                          AREA ||i.info_get_interface_version||, CODE, READONLY, ALIGN=2

                  info_get_interface_version PROC
;;;331    
;;;332    uint32_t info_get_interface_version(void)
000000  b500              PUSH     {lr}
;;;333    {
;;;334        // Don't read version if image is not present
;;;335        if (!info_get_interface_present()) {
000002  f7fffffe          BL       info_get_interface_present
000006  b908              CBNZ     r0,|L15.12|
;;;336            return 0;
000008  2000              MOVS     r0,#0
                  |L15.10|
;;;337        }
;;;338    
;;;339        return info_if->version;
;;;340    }
00000a  bd00              POP      {pc}
                  |L15.12|
00000c  4801              LDR      r0,|L15.20|
00000e  6a80              LDR      r0,[r0,#0x28]         ;339
000010  e7fb              B        |L15.10|
;;;341    
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x0800c000

                          AREA ||i.info_get_mac||, CODE, READONLY, ALIGN=2

                  info_get_mac PROC
;;;93     }
;;;94     const char *info_get_mac(void)
000000  4800              LDR      r0,|L16.4|
;;;95     {
;;;96         return string_mac;
;;;97     }
000002  4770              BX       lr
;;;98     
                          ENDP

                  |L16.4|
                          DCD      ||.bss||+0x51

                          AREA ||i.info_get_target_id||, CODE, READONLY, ALIGN=2

                  info_get_target_id PROC
;;;80     
;;;81     const char *info_get_target_id(void)
000000  4800              LDR      r0,|L17.4|
;;;82     {
;;;83         return string_target_id;
;;;84     }
000002  4770              BX       lr
;;;85     
                          ENDP

                  |L17.4|
                          DCD      ||.bss||+0x7f

                          AREA ||i.info_get_unique_id||, CODE, READONLY, ALIGN=2

                  info_get_unique_id PROC
;;;65     
;;;66     const char *info_get_unique_id(void)
000000  4800              LDR      r0,|L18.4|
;;;67     {
;;;68         return string_unique_id;
;;;69     }
000002  4770              BX       lr
;;;70     
                          ENDP

                  |L18.4|
                          DCD      ||.bss||+0x20

                          AREA ||i.info_get_unique_id_string_descriptor||, CODE, READONLY, ALIGN=2

                  info_get_unique_id_string_descriptor PROC
;;;98     
;;;99     const char *info_get_unique_id_string_descriptor(void)
000000  4800              LDR      r0,|L19.4|
;;;100    {
;;;101        return usb_desc_unique_id;
;;;102    }
000002  4770              BX       lr
;;;103    
                          ENDP

                  |L19.4|
                          DCD      ||.bss||+0xa9

                          AREA ||i.info_get_version||, CODE, READONLY, ALIGN=2

                  info_get_version PROC
;;;89     }
;;;90     const char *info_get_version(void)
000000  4800              LDR      r0,|L20.4|
;;;91     {
;;;92         return string_version;
;;;93     }
000002  4770              BX       lr
;;;94     const char *info_get_mac(void)
                          ENDP

                  |L20.4|
                          DCD      ||.data||+0x1e

                          AREA ||i.info_init||, CODE, READONLY, ALIGN=2

                  info_init PROC
;;;203    
;;;204    void info_init(void)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206        info_crc_compute();
000002  f7fffffe          BL       info_crc_compute
;;;207        read_unique_id(host_id);
000006  4805              LDR      r0,|L21.28|
000008  f7fffffe          BL       read_unique_id
;;;208        setup_basics();
00000c  f7fffffe          BL       setup_basics
;;;209        setup_unique_id();
000010  f7fffffe          BL       setup_unique_id
;;;210        setup_string_descriptor();
000014  f7fffffe          BL       setup_string_descriptor
;;;211    }
000018  bd10              POP      {r4,pc}
;;;212    
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      host_id

                          AREA ||i.info_set_uuid_target||, CODE, READONLY, ALIGN=2

                  info_set_uuid_target PROC
;;;212    
;;;213    void info_set_uuid_target(uint32_t *uuid_data)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {
000002  4604              MOV      r4,r0
;;;215        uint32_t idx = 0;
000004  2500              MOVS     r5,#0
;;;216        // Save the target ID
;;;217        memcpy(target_id, uuid_data, 16);
000006  e894004e          LDM      r4,{r1-r3,r6}
00000a  480e              LDR      r0,|L22.68|
00000c  c04e              STM      r0!,{r1-r3,r6}
;;;218        // patch for MAC use. Make sure MSB bits are set correctly
;;;219        uuid_data[2] |= (0x2 << 8);
00000e  68a0              LDR      r0,[r4,#8]
000010  f4407000          ORR      r0,r0,#0x200
000014  60a0              STR      r0,[r4,#8]
;;;220        uuid_data[2] &= ~(0x1 << 8);
000016  68a0              LDR      r0,[r4,#8]
000018  f4207080          BIC      r0,r0,#0x100
00001c  60a0              STR      r0,[r4,#8]
;;;221        idx += util_write_hex16(string_mac + idx, uuid_data[2] & 0xFFFF);
00001e  8922              LDRH     r2,[r4,#8]
000020  b291              UXTH     r1,r2
000022  4a09              LDR      r2,|L22.72|
000024  1950              ADDS     r0,r2,r5
000026  f7fffffe          BL       util_write_hex16
00002a  4405              ADD      r5,r5,r0
;;;222        idx += util_write_hex32(string_mac + idx, uuid_data[3]);
00002c  4a06              LDR      r2,|L22.72|
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1950              ADDS     r0,r2,r5
000032  f7fffffe          BL       util_write_hex32
000036  4405              ADD      r5,r5,r0
;;;223        string_mac[idx++] = 0;
000038  4903              LDR      r1,|L22.72|
00003a  2200              MOVS     r2,#0
00003c  4628              MOV      r0,r5
00003e  1c6d              ADDS     r5,r5,#1
000040  540a              STRB     r2,[r1,r0]
;;;224    }
000042  bd70              POP      {r4-r6,pc}
;;;225    
                          ENDP

                  |L22.68|
                          DCD      target_id
                  |L22.72|
                          DCD      string_mac

                          AREA ||i.setup_basics||, CODE, READONLY, ALIGN=2

                  setup_basics PROC
;;;110    #pragma O0
;;;111    static void setup_basics(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;112    #elif (!defined(__GNUC__))
;;;113    /* #pragma GCC push_options */
;;;114    /* #pragma GCC optimize("O0") */
;;;115    static void __attribute__((optimize("O0"))) setup_basics(void)
;;;116    #else
;;;117    #error "Unknown compiler"
;;;118    #endif
;;;119    
;;;120    {
;;;121        uint8_t i = 0, idx = 0;
000004  2500              MOVS     r5,#0
000006  2400              MOVS     r4,#0
;;;122        uint16_t family_id = get_family_id();
000008  f7fffffe          BL       get_family_id
00000c  4606              MOV      r6,r0
;;;123        memset(string_board_id, 0, sizeof(string_board_id));
00000e  2105              MOVS     r1,#5
000010  4857              LDR      r0,|L23.368|
000012  f7fffffe          BL       __aeabi_memclr4
;;;124        memset(string_host_id, 0, sizeof(string_host_id));
000016  2121              MOVS     r1,#0x21
000018  4856              LDR      r0,|L23.372|
00001a  f7fffffe          BL       __aeabi_memclr
;;;125        memset(string_target_id, 0, sizeof(string_target_id));
00001e  2121              MOVS     r1,#0x21
000020  4855              LDR      r0,|L23.376|
000022  f7fffffe          BL       __aeabi_memclr
;;;126        memset(string_hic_id, 0, sizeof(string_hic_id));
000026  2109              MOVS     r1,#9
000028  4854              LDR      r0,|L23.380|
00002a  f7fffffe          BL       __aeabi_memclr4
;;;127        memset(string_board_id, 0, sizeof(string_board_id));
00002e  2105              MOVS     r1,#5
000030  484f              LDR      r0,|L23.368|
000032  f7fffffe          BL       __aeabi_memclr4
;;;128        // Host ID
;;;129        idx = 0;
000036  bf00              NOP      
;;;130    
;;;131        for (i = 0; i < 4; i++) {
000038  bf00              NOP      
00003a  e00a              B        |L23.82|
                  |L23.60|
;;;132            idx += util_write_hex32(string_host_id + idx, host_id[i]);
00003c  4a50              LDR      r2,|L23.384|
00003e  f8521025          LDR      r1,[r2,r5,LSL #2]
000042  4a4c              LDR      r2,|L23.372|
000044  1910              ADDS     r0,r2,r4
000046  f7fffffe          BL       util_write_hex32
00004a  4420              ADD      r0,r0,r4
00004c  b2c4              UXTB     r4,r0
00004e  1c68              ADDS     r0,r5,#1              ;131
000050  b2c5              UXTB     r5,r0                 ;131
                  |L23.82|
000052  2d04              CMP      r5,#4                 ;131
000054  dbf2              BLT      |L23.60|
;;;133        }
;;;134    
;;;135        string_host_id[idx++] = 0;
000056  2200              MOVS     r2,#0
000058  4620              MOV      r0,r4
00005a  1c61              ADDS     r1,r4,#1
00005c  b2cc              UXTB     r4,r1
00005e  4945              LDR      r1,|L23.372|
000060  540a              STRB     r2,[r1,r0]
;;;136        // Target ID
;;;137        idx = 0;
000062  2400              MOVS     r4,#0
;;;138    
;;;139        for (i = 0; i < 4; i++) {
000064  2500              MOVS     r5,#0
000066  e00a              B        |L23.126|
                  |L23.104|
;;;140            idx += util_write_hex32(string_target_id + idx, target_id[i]);
000068  4a46              LDR      r2,|L23.388|
00006a  f8521025          LDR      r1,[r2,r5,LSL #2]
00006e  4a42              LDR      r2,|L23.376|
000070  1910              ADDS     r0,r2,r4
000072  f7fffffe          BL       util_write_hex32
000076  4420              ADD      r0,r0,r4
000078  b2c4              UXTB     r4,r0
00007a  1c68              ADDS     r0,r5,#1              ;139
00007c  b2c5              UXTB     r5,r0                 ;139
                  |L23.126|
00007e  2d04              CMP      r5,#4                 ;139
000080  dbf2              BLT      |L23.104|
;;;141        }
;;;142    
;;;143        string_target_id[idx++] = 0;
000082  2200              MOVS     r2,#0
000084  4621              MOV      r1,r4
000086  1c60              ADDS     r0,r4,#1
000088  b2c4              UXTB     r4,r0
00008a  483b              LDR      r0,|L23.376|
00008c  5442              STRB     r2,[r0,r1]
;;;144        // HIC ID
;;;145        idx = 0;
00008e  2400              MOVS     r4,#0
;;;146        idx += util_write_hex32(string_hic_id + idx, hic_id);
000090  493a              LDR      r1,|L23.380|
000092  1908              ADDS     r0,r1,r4
000094  493c              LDR      r1,|L23.392|
000096  6809              LDR      r1,[r1,#0]  ; hic_id
000098  f7fffffe          BL       util_write_hex32
00009c  4420              ADD      r0,r0,r4
00009e  b2c4              UXTB     r4,r0
;;;147        string_hic_id[idx++] = 0;
0000a0  4620              MOV      r0,r4
0000a2  1c61              ADDS     r1,r4,#1
0000a4  b2cc              UXTB     r4,r1
0000a6  4935              LDR      r1,|L23.380|
0000a8  2200              MOVS     r2,#0
0000aa  540a              STRB     r2,[r1,r0]
;;;148        // Board ID
;;;149        memcpy(string_board_id, get_board_id(), 4);
0000ac  f7fffffe          BL       get_board_id
0000b0  4607              MOV      r7,r0
0000b2  2204              MOVS     r2,#4
0000b4  4639              MOV      r1,r7
0000b6  482e              LDR      r0,|L23.368|
0000b8  f7fffffe          BL       __aeabi_memcpy
;;;150        string_board_id[4] = 0;
0000bc  492c              LDR      r1,|L23.368|
0000be  2000              MOVS     r0,#0
0000c0  7108              STRB     r0,[r1,#4]
;;;151        idx = 0;
0000c2  2400              MOVS     r4,#0
;;;152        //Family ID
;;;153        string_family_id[idx++] = hex_to_ascii(((family_id >> 12) & 0xF));    
0000c4  0b30              LSRS     r0,r6,#12
0000c6  f7fffffe          BL       hex_to_ascii
0000ca  4601              MOV      r1,r0
0000cc  482f              LDR      r0,|L23.396|
0000ce  4622              MOV      r2,r4
0000d0  1c64              ADDS     r4,r4,#1
0000d2  5481              STRB     r1,[r0,r2]
;;;154        string_family_id[idx++] = hex_to_ascii(((family_id >> 8) & 0xF));
0000d4  f3c62003          UBFX     r0,r6,#8,#4
0000d8  f7fffffe          BL       hex_to_ascii
0000dc  4601              MOV      r1,r0
0000de  482b              LDR      r0,|L23.396|
0000e0  4622              MOV      r2,r4
0000e2  1c64              ADDS     r4,r4,#1
0000e4  5481              STRB     r1,[r0,r2]
;;;155    #if !(defined(DAPLINK_BL)) &&  defined(DRAG_N_DROP_SUPPORT)   //need to change the unique id when the msd is disabled 
;;;156        #if defined(MSC_ENDPOINT)
;;;157        if (config_ram_get_disable_msd() == 1 || flash_algo_valid()==0){
0000e6  f7fffffe          BL       config_ram_get_disable_msd
0000ea  2801              CMP      r0,#1
0000ec  d002              BEQ      |L23.244|
0000ee  f7fffffe          BL       flash_algo_valid
0000f2  b960              CBNZ     r0,|L23.270|
                  |L23.244|
;;;158            string_family_id[idx++] = hex_to_ascii((((family_id >> 4) | 0x08) & 0xF)); 
0000f4  2108              MOVS     r1,#8
0000f6  ea411126          ORR      r1,r1,r6,ASR #4
0000fa  f001000f          AND      r0,r1,#0xf
0000fe  f7fffffe          BL       hex_to_ascii
000102  4621              MOV      r1,r4
000104  1c62              ADDS     r2,r4,#1
000106  b2d4              UXTB     r4,r2
000108  4a20              LDR      r2,|L23.396|
00010a  5450              STRB     r0,[r2,r1]
00010c  e008              B        |L23.288|
                  |L23.270|
;;;159        } else {
;;;160            string_family_id[idx++] = hex_to_ascii(((family_id >> 4) & 0xF));
00010e  f3c61003          UBFX     r0,r6,#4,#4
000112  f7fffffe          BL       hex_to_ascii
000116  4621              MOV      r1,r4
000118  1c62              ADDS     r2,r4,#1
00011a  b2d4              UXTB     r4,r2
00011c  4a1b              LDR      r2,|L23.396|
00011e  5450              STRB     r0,[r2,r1]
                  |L23.288|
;;;161        }
;;;162        #else //no msd support always have the most significant bit set for family id 2nd byte
;;;163            string_family_id[idx++] = hex_to_ascii((((family_id >> 4) | 0x08) & 0xF)); 
;;;164        #endif
;;;165    #else
;;;166        string_family_id[idx++] = hex_to_ascii(((family_id >> 4) & 0xF));
;;;167    #endif
;;;168        string_family_id[idx++] = hex_to_ascii(((family_id) & 0xF));    
000120  f006000f          AND      r0,r6,#0xf
000124  f7fffffe          BL       hex_to_ascii
000128  4621              MOV      r1,r4
00012a  1c62              ADDS     r2,r4,#1
00012c  b2d4              UXTB     r4,r2
00012e  4a17              LDR      r2,|L23.396|
000130  5450              STRB     r0,[r2,r1]
;;;169        string_family_id[idx++] = 0;
000132  2200              MOVS     r2,#0
000134  4620              MOV      r0,r4
000136  1c61              ADDS     r1,r4,#1
000138  b2cc              UXTB     r4,r1
00013a  4914              LDR      r1,|L23.396|
00013c  540a              STRB     r2,[r1,r0]
;;;170        // Version
;;;171        idx = 0;
00013e  2400              MOVS     r4,#0
;;;172        string_version[idx++] = '0' + (DAPLINK_VERSION / 1000) % 10;
000140  4813              LDR      r0,|L23.400|
000142  2230              MOVS     r2,#0x30
000144  4621              MOV      r1,r4
000146  1c64              ADDS     r4,r4,#1
000148  5442              STRB     r2,[r0,r1]
;;;173        string_version[idx++] = '0' + (DAPLINK_VERSION / 100) % 10;
00014a  2232              MOVS     r2,#0x32
00014c  4621              MOV      r1,r4
00014e  1c64              ADDS     r4,r4,#1
000150  5442              STRB     r2,[r0,r1]
;;;174        string_version[idx++] = '0' + (DAPLINK_VERSION / 10) % 10;
000152  2235              MOVS     r2,#0x35
000154  4621              MOV      r1,r4
000156  1c64              ADDS     r4,r4,#1
000158  5442              STRB     r2,[r0,r1]
;;;175        string_version[idx++] = '0' + (DAPLINK_VERSION / 1) % 10;
00015a  2234              MOVS     r2,#0x34
00015c  4621              MOV      r1,r4
00015e  1c64              ADDS     r4,r4,#1
000160  5442              STRB     r2,[r0,r1]
;;;176        string_version[idx++] = 0;
000162  2200              MOVS     r2,#0
000164  4621              MOV      r1,r4
000166  1c64              ADDS     r4,r4,#1
000168  5442              STRB     r2,[r0,r1]
;;;177    }
00016a  e8bd81f0          POP      {r4-r8,pc}
;;;178    
                          ENDP

00016e  0000              DCW      0x0000
                  |L23.368|
                          DCD      string_board_id
                  |L23.372|
                          DCD      string_host_id
                  |L23.376|
                          DCD      string_target_id
                  |L23.380|
                          DCD      string_hic_id
                  |L23.384|
                          DCD      host_id
                  |L23.388|
                          DCD      target_id
                  |L23.392|
                          DCD      hic_id
                  |L23.396|
                          DCD      string_family_id
                  |L23.400|
                          DCD      string_version

                          AREA ||i.setup_string_descriptor||, CODE, READONLY, ALIGN=2

                  setup_string_descriptor PROC
;;;187    
;;;188    static void setup_string_descriptor()
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
;;;190        uint8_t i = 0, idx = 0, len = 0;
000002  2500              MOVS     r5,#0
000004  2400              MOVS     r4,#0
000006  2600              MOVS     r6,#0
;;;191        len = strlen((const char *)string_unique_id);
000008  4811              LDR      r0,|L24.80|
00000a  f7fffffe          BL       strlen
00000e  b2c6              UXTB     r6,r0
;;;192        // bLength
;;;193        usb_desc_unique_id[idx++] = len * 2 + 2;
000010  2002              MOVS     r0,#2
000012  eb000046          ADD      r0,r0,r6,LSL #1
000016  b2c2              UXTB     r2,r0
000018  480e              LDR      r0,|L24.84|
00001a  4621              MOV      r1,r4
00001c  1c64              ADDS     r4,r4,#1
00001e  5442              STRB     r2,[r0,r1]
;;;194        // bDescriptorType
;;;195        usb_desc_unique_id[idx++] = 3;
000020  2203              MOVS     r2,#3
000022  4621              MOV      r1,r4
000024  1c64              ADDS     r4,r4,#1
000026  5442              STRB     r2,[r0,r1]
;;;196    
;;;197        // bString
;;;198        for (i = 0; i < len; i++) {
000028  bf00              NOP      
00002a  e00e              B        |L24.74|
                  |L24.44|
;;;199            usb_desc_unique_id[idx++] = string_unique_id[i];
00002c  4808              LDR      r0,|L24.80|
00002e  1c61              ADDS     r1,r4,#1
000030  5d42              LDRB     r2,[r0,r5]
000032  4620              MOV      r0,r4
000034  b2cc              UXTB     r4,r1
000036  4907              LDR      r1,|L24.84|
000038  540a              STRB     r2,[r1,r0]
;;;200            usb_desc_unique_id[idx++] = 0;
00003a  2200              MOVS     r2,#0
00003c  4620              MOV      r0,r4
00003e  1c61              ADDS     r1,r4,#1
000040  b2cc              UXTB     r4,r1
000042  4904              LDR      r1,|L24.84|
000044  540a              STRB     r2,[r1,r0]
000046  1c68              ADDS     r0,r5,#1              ;198
000048  b2c5              UXTB     r5,r0                 ;198
                  |L24.74|
00004a  42b5              CMP      r5,r6                 ;198
00004c  dbee              BLT      |L24.44|
;;;201        }
;;;202    }
00004e  bd70              POP      {r4-r6,pc}
;;;203    
                          ENDP

                  |L24.80|
                          DCD      string_unique_id
                  |L24.84|
                          DCD      usb_desc_unique_id

                          AREA ||i.setup_unique_id||, CODE, READONLY, ALIGN=2

                  setup_unique_id PROC
;;;178    
;;;179    static void setup_unique_id()
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181        memset(string_unique_id, 0, sizeof(string_unique_id));
000002  2131              MOVS     r1,#0x31
000004  4809              LDR      r0,|L25.44|
000006  f7fffffe          BL       __aeabi_memclr4
;;;182        strcat(string_unique_id, string_board_id);
00000a  4909              LDR      r1,|L25.48|
00000c  4807              LDR      r0,|L25.44|
00000e  f7fffffe          BL       strcat
;;;183        strcat(string_unique_id, string_family_id);
000012  4908              LDR      r1,|L25.52|
000014  4805              LDR      r0,|L25.44|
000016  f7fffffe          BL       strcat
;;;184        strcat(string_unique_id, string_host_id);
00001a  4907              LDR      r1,|L25.56|
00001c  4803              LDR      r0,|L25.44|
00001e  f7fffffe          BL       strcat
;;;185        strcat(string_unique_id, string_hic_id);
000022  4906              LDR      r1,|L25.60|
000024  4801              LDR      r0,|L25.44|
000026  f7fffffe          BL       strcat
;;;186    }
00002a  bd10              POP      {r4,pc}
;;;187    
                          ENDP

                  |L25.44|
                          DCD      string_unique_id
                  |L25.48|
                          DCD      string_board_id
                  |L25.52|
                          DCD      string_family_id
                  |L25.56|
                          DCD      string_host_id
                  |L25.60|
                          DCD      string_hic_id

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  host_id
                          %        16
                  target_id
                          %        16
                  string_unique_id
                          %        49
                  string_mac
                          %        13
                  string_host_id
                          %        33
                  string_target_id
                          %        33
                  string_hic_id
                          %        9
                  usb_desc_unique_id
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  hic_id
                          DCD      0x97969908
                  crc_bootloader
                          DCD      0x00000000
                  crc_interface
                          DCD      0x00000000
                  crc_config_admin
                          DCD      0x00000000
                  crc_config_user
                          DCD      0x00000000
                  string_board_id
                          DCD      0x00000000
000018  00                DCB      0x00
                  string_family_id
000019  000000            DCB      0x00,0x00,0x00
00001c  0000              DCB      0x00,0x00
                  string_version
00001e  0000              DCB      0x00,0x00
000020  000000            DCB      0x00,0x00,0x00
