; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\target_flash.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\target_flash.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\target_flash.crf ..\..\..\source\daplink\interface\target_flash.c]
                          THUMB

                          AREA ||i.flash_func_start||, CODE, READONLY, ALIGN=2

                  flash_func_start PROC
;;;102    
;;;103    static error_t flash_func_start(flash_func_t func)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;104    {
;;;105        program_target_t * flash = current_flash_algo;
000004  4f16              LDR      r7,|L1.96|
000006  4605              MOV      r5,r0                 ;104
;;;106    
;;;107        if (last_flash_func != func)
000008  787e              LDRB     r6,[r7,#1]  ; last_flash_func
00000a  687c              LDR      r4,[r7,#4]  ; current_flash_algo
00000c  42ae              CMP      r6,r5
00000e  d020              BEQ      |L1.82|
000010  f04f0800          MOV      r8,#0                 ;104
;;;108        {
;;;109            // Finish the currently active function.
;;;110            if (FLASH_FUNC_NOP != last_flash_func &&
000014  b176              CBZ      r6,|L1.52|
000016  1d20              ADDS     r0,r4,#4
;;;111                0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->uninit, last_flash_func, 0, 0, 0)) {
000018  f7fffffe          BL       __aeabi_uread4
00001c  4601              MOV      r1,r0
00001e  f8cd8000          STR      r8,[sp,#0]
000022  2300              MOVS     r3,#0
000024  4632              MOV      r2,r6
000026  f1040018          ADD      r0,r4,#0x18
00002a  f8cd8004          STR      r8,[sp,#4]
00002e  f7fffffe          BL       swd_flash_syscall_exec
000032  b188              CBZ      r0,|L1.88|
                  |L1.52|
;;;112                return ERROR_UNINIT;
;;;113            }
;;;114    
;;;115            // Start a new function.
;;;116            if (FLASH_FUNC_NOP != func &&
000034  b165              CBZ      r5,|L1.80|
;;;117                0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->init, flash_start, 0, func, 0)) {
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       __aeabi_uread4
00003c  e9cd5800          STRD     r5,r8,[sp,#0]
000040  4601              MOV      r1,r0
000042  2300              MOVS     r3,#0
000044  f1040018          ADD      r0,r4,#0x18
000048  68fa              LDR      r2,[r7,#0xc]  ; flash_start
00004a  f7fffffe          BL       swd_flash_syscall_exec
00004e  b128              CBZ      r0,|L1.92|
                  |L1.80|
;;;118                return ERROR_INIT;
;;;119            }
;;;120    
;;;121            last_flash_func = func;
000050  707d              STRB     r5,[r7,#1]
                  |L1.82|
;;;122        }
;;;123    
;;;124        return ERROR_SUCCESS;
000052  2000              MOVS     r0,#0
                  |L1.84|
;;;125    }
000054  e8bd81fc          POP      {r2-r8,pc}
                  |L1.88|
000058  200c              MOVS     r0,#0xc               ;112
00005a  e7fb              B        |L1.84|
                  |L1.92|
00005c  200b              MOVS     r0,#0xb               ;118
00005e  e7f9              B        |L1.84|
;;;126    
                          ENDP

                  |L1.96|
                          DCD      ||.data||

                          AREA ||i.get_flash_algo||, CODE, READONLY, ALIGN=2

                  get_flash_algo PROC
;;;78     
;;;79     static program_target_t * get_flash_algo(uint32_t addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;80     {
000004  4605              MOV      r5,r0
;;;81         region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
000006  4814              LDR      r0,|L2.88|
000008  f7fffffe          BL       __aeabi_uread4
00000c  f100040c          ADD      r4,r0,#0xc
;;;82     
;;;83         for (; flash_region->start != 0 || flash_region->end != 0; ++flash_region) {
;;;84             if (addr >= flash_region->start && addr <= flash_region->end) {
;;;85                 flash_start = flash_region->start; //save the flash start
000010  4f12              LDR      r7,|L2.92|
000012  e007              B        |L2.36|
                  |L2.20|
000014  42ae              CMP      r6,r5                 ;84
000016  d804              BHI      |L2.34|
000018  1d20              ADDS     r0,r4,#4              ;84
00001a  f7fffffe          BL       __aeabi_uread4
00001e  42a8              CMP      r0,r5                 ;84
000020  d20c              BCS      |L2.60|
                  |L2.34|
000022  3414              ADDS     r4,r4,#0x14           ;84
                  |L2.36|
000024  4620              MOV      r0,r4                 ;83
000026  f7fffffe          BL       __aeabi_uread4
00002a  0006              MOVS     r6,r0                 ;83
00002c  d1f2              BNE      |L2.20|
00002e  1d20              ADDS     r0,r4,#4              ;83
000030  f7fffffe          BL       __aeabi_uread4
000034  2800              CMP      r0,#0                 ;83
000036  d1ed              BNE      |L2.20|
;;;86                 if (flash_region->flash_algo) {
;;;87                     return flash_region->flash_algo;
;;;88                 }else{
;;;89                     return NULL;
;;;90                 }
;;;91             }
;;;92         }
;;;93         
;;;94         //could not find a flash algo for the region; use default
;;;95         if (default_region) {
000038  68bc              LDR      r4,[r7,#8]  ; default_region
00003a  b14c              CBZ      r4,|L2.80|
                  |L2.60|
00003c  4620              MOV      r0,r4
;;;96             flash_start = default_region->start;
00003e  f7fffffe          BL       __aeabi_uread4
;;;97             return default_region->flash_algo;
000042  60f8              STR      r0,[r7,#0xc]  ; flash_start
000044  f1040010          ADD      r0,r4,#0x10
000048  e8bd41f0          POP      {r4-r8,lr}
00004c  f7ffbffe          B.W      __aeabi_uread4
                  |L2.80|
;;;98         } else {
;;;99             return NULL;
000050  2000              MOVS     r0,#0
;;;100        }
;;;101    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;102    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      g_board_info+0x10
                  |L2.92|
                          DCD      ||.data||

                          AREA ||i.target_flash_busy||, CODE, READONLY, ALIGN=2

                  target_flash_busy PROC
;;;384    
;;;385    static uint8_t target_flash_busy(void){
000000  4802              LDR      r0,|L3.12|
;;;386        return (state == STATE_OPEN);
000002  7800              LDRB     r0,[r0,#0]  ; state
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L3.10|
000008  2000              MOVS     r0,#0
                  |L3.10|
;;;387    }
00000a  4770              BX       lr
;;;388    #endif
                          ENDP

                  |L3.12|
                          DCD      ||.data||

                          AREA ||i.target_flash_erase_chip||, CODE, READONLY, ALIGN=2

                  target_flash_erase_chip PROC
;;;321    
;;;322    static error_t target_flash_erase_chip(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;323    {
;;;324        if (g_board_info.target_cfg){
000004  481f              LDR      r0,|L4.132|
000006  4605              MOV      r5,r0
000008  f7fffffe          BL       __aeabi_uread4
00000c  b3a8              CBZ      r0,|L4.122|
;;;325            error_t status = ERROR_SUCCESS;
00000e  2600              MOVS     r6,#0
000010  f100040c          ADD      r4,r0,#0xc
;;;326            region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
;;;327    
;;;328            for (; flash_region->start != 0 || flash_region->end != 0; ++flash_region) {
000014  e01b              B        |L4.78|
                  |L4.22|
000016  4638              MOV      r0,r7
;;;329                status = target_flash_set(flash_region->start); 
000018  f7fffffe          BL       target_flash_set
;;;330                if (status != ERROR_SUCCESS) {
00001c  2800              CMP      r0,#0
00001e  d12a              BNE      |L4.118|
;;;331                    return status;
;;;332                }
;;;333                status = flash_func_start(FLASH_FUNC_ERASE);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       flash_func_start
000026  0006              MOVS     r6,r0
;;;334                if (status != ERROR_SUCCESS) {
000028  d125              BNE      |L4.118|
;;;335                    return status;
;;;336                }
;;;337                if (0 == swd_flash_syscall_exec(&current_flash_algo->sys_call_s, current_flash_algo->erase_chip, 0, 0, 0, 0)) {
00002a  4817              LDR      r0,|L4.136|
00002c  6847              LDR      r7,[r0,#4]  ; current_flash_algo
00002e  f1070008          ADD      r0,r7,#8
000032  f7fffffe          BL       __aeabi_uread4
000036  2100              MOVS     r1,#0
000038  9100              STR      r1,[sp,#0]
00003a  460b              MOV      r3,r1
00003c  460a              MOV      r2,r1
00003e  9101              STR      r1,[sp,#4]
000040  4601              MOV      r1,r0
000042  f1070018          ADD      r0,r7,#0x18
000046  f7fffffe          BL       swd_flash_syscall_exec
00004a  b1b8              CBZ      r0,|L4.124|
00004c  3414              ADDS     r4,r4,#0x14
                  |L4.78|
00004e  4620              MOV      r0,r4                 ;328
000050  f7fffffe          BL       __aeabi_uread4
000054  0007              MOVS     r7,r0                 ;328
000056  d1de              BNE      |L4.22|
000058  1d20              ADDS     r0,r4,#4              ;328
00005a  f7fffffe          BL       __aeabi_uread4
00005e  2800              CMP      r0,#0                 ;328
000060  d1d9              BNE      |L4.22|
000062  4628              MOV      r0,r5                 ;328
;;;338                    return ERROR_ERASE_ALL;
;;;339                }
;;;340            }
;;;341    
;;;342            // Reset and re-initialize the target after the erase if required
;;;343            if (g_board_info.target_cfg->erase_reset) {
000064  f7fffffe          BL       __aeabi_uread4
000068  f89001a2          LDRB     r0,[r0,#0x1a2]
00006c  b110              CBZ      r0,|L4.116|
;;;344                status = target_flash_init();
00006e  f7fffffe          BL       target_flash_init
000072  4606              MOV      r6,r0
                  |L4.116|
;;;345            }
;;;346    
;;;347            return status;
000074  4630              MOV      r0,r6
                  |L4.118|
;;;348        } else {
;;;349            return ERROR_FAILURE;
;;;350        }
;;;351    }
000076  e8bd81fc          POP      {r2-r8,pc}
                  |L4.122|
00007a  e001              B        |L4.128|
                  |L4.124|
00007c  2010              MOVS     r0,#0x10              ;338
00007e  e7fa              B        |L4.118|
                  |L4.128|
000080  2001              MOVS     r0,#1                 ;349
000082  e7f8              B        |L4.118|
;;;352    
                          ENDP

                  |L4.132|
                          DCD      g_board_info+0x10
                  |L4.136|
                          DCD      ||.data||

                          AREA ||i.target_flash_erase_sector||, CODE, READONLY, ALIGN=2

                  target_flash_erase_sector PROC
;;;290    
;;;291    static error_t target_flash_erase_sector(uint32_t addr)
000000  b57c              PUSH     {r2-r6,lr}
;;;292    {
000002  4605              MOV      r5,r0
;;;293        if (g_board_info.target_cfg) {
000004  4815              LDR      r0,|L5.92|
000006  f7fffffe          BL       __aeabi_uread4
00000a  b328              CBZ      r0,|L5.88|
;;;294            error_t status = ERROR_SUCCESS;
;;;295            program_target_t * flash = current_flash_algo;
00000c  4814              LDR      r0,|L5.96|
;;;296    
;;;297            if (!flash) {
00000e  6844              LDR      r4,[r0,#4]  ; current_flash_algo
000010  b144              CBZ      r4,|L5.36|
;;;298                return ERROR_INTERNAL;
;;;299            }
;;;300            
;;;301            // Check to make sure the address is on a sector boundary
;;;302            if ((addr % target_flash_erase_sector_size(addr)) != 0) {
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       target_flash_erase_sector_size
000018  fbb5f1f0          UDIV     r1,r5,r0
00001c  fb005011          MLS      r0,r0,r1,r5
000020  b9c0              CBNZ     r0,|L5.84|
000022  e001              B        |L5.40|
                  |L5.36|
000024  2002              MOVS     r0,#2                 ;298
                  |L5.38|
;;;303                return ERROR_ERASE_SECTOR;
;;;304            }
;;;305    
;;;306            status = flash_func_start(FLASH_FUNC_ERASE);
;;;307    
;;;308            if (status != ERROR_SUCCESS) {
;;;309                return status;
;;;310            }
;;;311            
;;;312            if (0 == swd_flash_syscall_exec(&flash->sys_call_s, flash->erase_sector, addr, 0, 0, 0)) {
;;;313                return ERROR_ERASE_SECTOR;
;;;314            }
;;;315    
;;;316            return ERROR_SUCCESS;
;;;317        } else {
;;;318            return ERROR_FAILURE;
;;;319        }
;;;320    }
000026  bd7c              POP      {r2-r6,pc}
                  |L5.40|
000028  2001              MOVS     r0,#1                 ;306
00002a  f7fffffe          BL       flash_func_start
00002e  2800              CMP      r0,#0                 ;308
000030  d1f9              BNE      |L5.38|
000032  f104000c          ADD      r0,r4,#0xc            ;312
000036  f7fffffe          BL       __aeabi_uread4
00003a  2100              MOVS     r1,#0                 ;312
00003c  9100              STR      r1,[sp,#0]            ;312
00003e  460b              MOV      r3,r1                 ;312
000040  9101              STR      r1,[sp,#4]            ;312
000042  4601              MOV      r1,r0                 ;312
000044  462a              MOV      r2,r5                 ;312
000046  f1040018          ADD      r0,r4,#0x18           ;312
00004a  f7fffffe          BL       swd_flash_syscall_exec
00004e  b108              CBZ      r0,|L5.84|
000050  2000              MOVS     r0,#0                 ;316
000052  bd7c              POP      {r2-r6,pc}
                  |L5.84|
000054  200f              MOVS     r0,#0xf               ;313
000056  bd7c              POP      {r2-r6,pc}
                  |L5.88|
000058  2001              MOVS     r0,#1                 ;318
00005a  bd7c              POP      {r2-r6,pc}
;;;321    
                          ENDP

                  |L5.92|
                          DCD      g_board_info+0x10
                  |L5.96|
                          DCD      ||.data||

                          AREA ||i.target_flash_erase_sector_size||, CODE, READONLY, ALIGN=2

                  target_flash_erase_sector_size PROC
;;;365    
;;;366    static uint32_t target_flash_erase_sector_size(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
000002  4605              MOV      r5,r0
;;;368        if (g_board_info.target_cfg){
000004  4814              LDR      r0,|L6.88|
000006  f7fffffe          BL       __aeabi_uread4
00000a  1e06              SUBS     r6,r0,#0
00000c  d023              BEQ      |L6.86|
;;;369            if(g_board_info.target_cfg->sector_info_length > 0) { 
00000e  f1060008          ADD      r0,r6,#8
000012  f7fffffe          BL       __aeabi_uread4
000016  b1b8              CBZ      r0,|L6.72|
;;;370                int sector_index = g_board_info.target_cfg->sector_info_length - 1;
000018  1e44              SUBS     r4,r0,#1
;;;371                for (; sector_index >= 0; sector_index--) {
00001a  d415              BMI      |L6.72|
                  |L6.28|
;;;372                    if (addr >= g_board_info.target_cfg->sectors_info[sector_index].start) {
00001c  1d30              ADDS     r0,r6,#4
00001e  f7fffffe          BL       __aeabi_uread4
000022  eb0000c4          ADD      r0,r0,r4,LSL #3
000026  f7fffffe          BL       __aeabi_uread4
00002a  42a8              CMP      r0,r5
00002c  d80a              BHI      |L6.68|
;;;373                        return g_board_info.target_cfg->sectors_info[sector_index].size;
00002e  1d30              ADDS     r0,r6,#4
000030  f7fffffe          BL       __aeabi_uread4
000034  2104              MOVS     r1,#4
000036  eb0101c4          ADD      r1,r1,r4,LSL #3
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  4408              ADD      r0,r0,r1
000040  f7ffbffe          B.W      __aeabi_uread4
                  |L6.68|
000044  1e64              SUBS     r4,r4,#1
000046  d5e9              BPL      |L6.28|
                  |L6.72|
;;;374                    }
;;;375                }
;;;376            }
;;;377            //sector information should be in sector_info
;;;378            util_assert(0);
000048  f44f72bd          MOV      r2,#0x17a
00004c  a103              ADR      r1,|L6.92|
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       _util_assert
;;;379            return 0;
000054  2000              MOVS     r0,#0
                  |L6.86|
;;;380        } else {
;;;381            return 0;
;;;382        }
;;;383    }
000056  bd70              POP      {r4-r6,pc}
;;;384    
                          ENDP

                  |L6.88|
                          DCD      g_board_info+0x10
                  |L6.92|
00005c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\interface\\target_flash.c",0
000060  2e5c2e2e
000064  5c736f75
000068  7263655c
00006c  6461706c
000070  696e6b5c
000074  696e7465
000078  72666163
00007c  655c7461
000080  72676574
000084  5f666c61
000088  73682e63
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.target_flash_init||, CODE, READONLY, ALIGN=2

                  target_flash_init PROC
;;;149    
;;;150    static error_t target_flash_init()
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
;;;152        if (g_board_info.target_cfg) {
000002  4817              LDR      r0,|L7.96|
000004  4604              MOV      r4,r0
000006  f7fffffe          BL       __aeabi_uread4
00000a  b330              CBZ      r0,|L7.90|
;;;153            last_flash_func = FLASH_FUNC_NOP;
00000c  4d15              LDR      r5,|L7.100|
00000e  2000              MOVS     r0,#0
000010  7068              STRB     r0,[r5,#1]
;;;154            
;;;155            current_flash_algo = NULL;
;;;156            
;;;157            if (0 == target_set_state(RESET_PROGRAM)) {
000012  6068              STR      r0,[r5,#4]  ; current_flash_algo
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       target_set_state
00001a  b128              CBZ      r0,|L7.40|
00001c  4620              MOV      r0,r4
;;;158                return ERROR_RESET;
;;;159            }
;;;160            
;;;161            //get default region
;;;162            region_info_t * flash_region = g_board_info.target_cfg->flash_regions;
00001e  f7fffffe          BL       __aeabi_uread4
000022  f100040c          ADD      r4,r0,#0xc
;;;163            for (; flash_region->start != 0 || flash_region->end != 0; ++flash_region) {
000026  e00a              B        |L7.62|
                  |L7.40|
000028  2007              MOVS     r0,#7                 ;158
;;;164                if (flash_region->flags & kRegionIsDefault) {
;;;165                    default_region = flash_region;
;;;166                    break;
;;;167                }
;;;168            }
;;;169    
;;;170            state = STATE_OPEN;
;;;171            return ERROR_SUCCESS;
;;;172        } else {
;;;173            return ERROR_FAILURE;
;;;174        }
;;;175        
;;;176    }
00002a  bd70              POP      {r4-r6,pc}
                  |L7.44|
00002c  f1040008          ADD      r0,r4,#8              ;164
000030  f7fffffe          BL       __aeabi_uread4
000034  07c0              LSLS     r0,r0,#31             ;164
000036  d001              BEQ      |L7.60|
000038  60ac              STR      r4,[r5,#8]            ;166  ; default_region
00003a  e00a              B        |L7.82|
                  |L7.60|
00003c  3414              ADDS     r4,r4,#0x14           ;166
                  |L7.62|
00003e  4620              MOV      r0,r4                 ;163
000040  f7fffffe          BL       __aeabi_uread4
000044  2800              CMP      r0,#0                 ;163
000046  d1f1              BNE      |L7.44|
000048  1d20              ADDS     r0,r4,#4              ;163
00004a  f7fffffe          BL       __aeabi_uread4
00004e  2800              CMP      r0,#0                 ;163
000050  d1ec              BNE      |L7.44|
                  |L7.82|
000052  2001              MOVS     r0,#1                 ;170
000054  7028              STRB     r0,[r5,#0]            ;170
000056  2000              MOVS     r0,#0                 ;171
000058  bd70              POP      {r4-r6,pc}
                  |L7.90|
00005a  2001              MOVS     r0,#1                 ;173
00005c  bd70              POP      {r4-r6,pc}
;;;177    
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      g_board_info+0x10
                  |L7.100|
                          DCD      ||.data||

                          AREA ||i.target_flash_program_page||, CODE, READONLY, ALIGN=2

                  target_flash_program_page PROC
;;;203    
;;;204    static error_t target_flash_program_page(uint32_t addr, const uint8_t *buf, uint32_t size)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;205    {
000004  4681              MOV      r9,r0
000006  4615              MOV      r5,r2
000008  4688              MOV      r8,r1
;;;206        if (g_board_info.target_cfg) {
00000a  4848              LDR      r0,|L8.300|
00000c  f7fffffe          BL       __aeabi_uread4
000010  2800              CMP      r0,#0
000012  d068              BEQ      |L8.230|
;;;207            error_t status = ERROR_SUCCESS;
;;;208            program_target_t * flash = current_flash_algo;
000014  4846              LDR      r0,|L8.304|
;;;209            
;;;210            if (!flash) {
000016  6847              LDR      r7,[r0,#4]  ; current_flash_algo
000018  b197              CBZ      r7,|L8.64|
;;;211                return ERROR_INTERNAL;
;;;212            }
;;;213            
;;;214            // check if security bits were set
;;;215            if (g_target_family && g_target_family->security_bits_set){
00001a  4846              LDR      r0,|L8.308|
00001c  6800              LDR      r0,[r0,#0]  ; g_target_family
00001e  b138              CBZ      r0,|L8.48|
000020  6943              LDR      r3,[r0,#0x14]
000022  b12b              CBZ      r3,|L8.48|
;;;216                if (1 == g_target_family->security_bits_set(addr, (uint8_t *)buf, size)) {
000024  462a              MOV      r2,r5
000026  4641              MOV      r1,r8
000028  4648              MOV      r0,r9
00002a  4798              BLX      r3
00002c  2801              CMP      r0,#1
00002e  d00b              BEQ      |L8.72|
                  |L8.48|
;;;217                    return ERROR_SECURITY_BITS;
;;;218                }
;;;219            }
;;;220    
;;;221            status = flash_func_start(FLASH_FUNC_PROGRAM);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       flash_func_start
000036  f04f0b00          MOV      r11,#0
;;;222    
;;;223            if (status != ERROR_SUCCESS) {
00003a  2800              CMP      r0,#0
00003c  d101              BNE      |L8.66|
00003e  e04d              B        |L8.220|
                  |L8.64|
000040  2002              MOVS     r0,#2                 ;211
                  |L8.66|
;;;224                return status;
;;;225            }
;;;226            
;;;227            while (size > 0) {
;;;228                uint32_t write_size = MIN(size, flash->program_buffer_size);
;;;229    
;;;230                // Write page to buffer
;;;231                if (!swd_write_memory(flash->program_buffer, (uint8_t *)buf, write_size)) {
;;;232                    return ERROR_ALGO_DATA_SEQ;
;;;233                }
;;;234    
;;;235                // Run flash programming
;;;236                if (!swd_flash_syscall_exec(&flash->sys_call_s,
;;;237                                            flash->program_page,
;;;238                                            addr,
;;;239                                            write_size,
;;;240                                            flash->program_buffer,
;;;241                                            0)) {
;;;242                    return ERROR_WRITE;
;;;243                }
;;;244    
;;;245                if (config_get_automation_allowed()) {
;;;246                    // Verify data flashed if in automation mode
;;;247                    if (flash->verify != 0) {
;;;248                        status = flash_func_start(FLASH_FUNC_VERIFY);
;;;249                        if (status != ERROR_SUCCESS) {
;;;250                            return status;
;;;251                        }
;;;252                        if (!swd_flash_syscall_exec(&flash->sys_call_s,
;;;253                                            flash->verify,
;;;254                                            addr,
;;;255                                            write_size,
;;;256                                            flash->program_buffer,
;;;257                                            0)) {
;;;258                            return ERROR_WRITE_VERIFY;
;;;259                        }
;;;260                    } else {
;;;261                        while (write_size > 0) {
;;;262                            uint8_t rb_buf[16];
;;;263                            uint32_t verify_size = MIN(write_size, sizeof(rb_buf));
;;;264                            if (!swd_read_memory(addr, rb_buf, verify_size)) {
;;;265                                return ERROR_ALGO_DATA_SEQ;
;;;266                            }
;;;267                            if (memcmp(buf, rb_buf, verify_size) != 0) {
;;;268                                return ERROR_WRITE_VERIFY;
;;;269                            }
;;;270                            addr += verify_size;
;;;271                            buf += verify_size;
;;;272                            size -= verify_size;
;;;273                            write_size -= verify_size;
;;;274                        }
;;;275                        continue;
;;;276                    }
;;;277                }
;;;278                addr += write_size;
;;;279                buf += write_size;
;;;280                size -= write_size;
;;;281                
;;;282            }
;;;283    
;;;284            return ERROR_SUCCESS;
;;;285            
;;;286        } else {
;;;287            return ERROR_FAILURE;
;;;288        }
;;;289    }
000042  b004              ADD      sp,sp,#0x10
000044  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.72|
000048  200d              MOVS     r0,#0xd               ;217
00004a  e7fa              B        |L8.66|
                  |L8.76|
00004c  f1070034          ADD      r0,r7,#0x34           ;228
000050  f7fffffe          BL       __aeabi_uread4
000054  42a8              CMP      r0,r5                 ;228
000056  d901              BLS      |L8.92|
000058  462c              MOV      r4,r5                 ;228
00005a  e000              B        |L8.94|
                  |L8.92|
00005c  4604              MOV      r4,r0                 ;228
                  |L8.94|
00005e  f1070024          ADD      r0,r7,#0x24           ;231
000062  9002              STR      r0,[sp,#8]            ;231
000064  f7fffffe          BL       __aeabi_uread4
000068  4622              MOV      r2,r4                 ;231
00006a  4641              MOV      r1,r8                 ;231
00006c  f7fffffe          BL       swd_write_memory
000070  b3c0              CBZ      r0,|L8.228|
000072  9802              LDR      r0,[sp,#8]            ;236
000074  f7fffffe          BL       __aeabi_uread4
000078  4682              MOV      r10,r0                ;236
00007a  f1070010          ADD      r0,r7,#0x10           ;236
00007e  f7fffffe          BL       __aeabi_uread4
000082  4601              MOV      r1,r0                 ;236
000084  f1070018          ADD      r0,r7,#0x18           ;236
000088  465e              MOV      r6,r11                ;236
00008a  4623              MOV      r3,r4                 ;236
00008c  464a              MOV      r2,r9                 ;236
00008e  9003              STR      r0,[sp,#0xc]          ;236
000090  e9cdab00          STRD     r10,r11,[sp,#0]       ;236
000094  f7fffffe          BL       swd_flash_syscall_exec
000098  b330              CBZ      r0,|L8.232|
00009a  f7fffffe          BL       config_get_automation_allowed
00009e  b1d0              CBZ      r0,|L8.214|
0000a0  f1070014          ADD      r0,r7,#0x14           ;247
0000a4  9000              STR      r0,[sp,#0]            ;247
0000a6  f7fffffe          BL       __aeabi_uread4
0000aa  b390              CBZ      r0,|L8.274|
0000ac  2003              MOVS     r0,#3                 ;248
0000ae  f7fffffe          BL       flash_func_start
0000b2  2800              CMP      r0,#0                 ;249
0000b4  d1c5              BNE      |L8.66|
0000b6  9802              LDR      r0,[sp,#8]            ;252
0000b8  f7fffffe          BL       __aeabi_uread4
0000bc  4682              MOV      r10,r0                ;252
0000be  9800              LDR      r0,[sp,#0]            ;252
0000c0  f7fffffe          BL       __aeabi_uread4
0000c4  e9cda600          STRD     r10,r6,[sp,#0]        ;252
0000c8  4601              MOV      r1,r0                 ;252
0000ca  4623              MOV      r3,r4                 ;252
0000cc  464a              MOV      r2,r9                 ;252
0000ce  9803              LDR      r0,[sp,#0xc]          ;252
0000d0  f7fffffe          BL       swd_flash_syscall_exec
0000d4  b1d8              CBZ      r0,|L8.270|
                  |L8.214|
0000d6  44a1              ADD      r9,r9,r4              ;278
0000d8  44a0              ADD      r8,r8,r4              ;279
0000da  1b2d              SUBS     r5,r5,r4              ;280
                  |L8.220|
0000dc  2d00              CMP      r5,#0                 ;227
0000de  d1b5              BNE      |L8.76|
0000e0  2000              MOVS     r0,#0                 ;284
0000e2  e7ae              B        |L8.66|
                  |L8.228|
0000e4  e016              B        |L8.276|
                  |L8.230|
0000e6  e01e              B        |L8.294|
                  |L8.232|
0000e8  2011              MOVS     r0,#0x11              ;242
0000ea  e7aa              B        |L8.66|
                  |L8.236|
0000ec  2c10              CMP      r4,#0x10              ;263
0000ee  d201              BCS      |L8.244|
0000f0  4626              MOV      r6,r4                 ;263
0000f2  e000              B        |L8.246|
                  |L8.244|
0000f4  2610              MOVS     r6,#0x10              ;263
                  |L8.246|
0000f6  4632              MOV      r2,r6                 ;264
0000f8  4669              MOV      r1,sp                 ;264
0000fa  4648              MOV      r0,r9                 ;264
0000fc  f7fffffe          BL       swd_read_memory
000100  b140              CBZ      r0,|L8.276|
000102  4632              MOV      r2,r6                 ;267
000104  4669              MOV      r1,sp                 ;267
000106  4640              MOV      r0,r8                 ;267
000108  f7fffffe          BL       memcmp
00010c  b120              CBZ      r0,|L8.280|
                  |L8.270|
00010e  2012              MOVS     r0,#0x12              ;268
000110  e797              B        |L8.66|
                  |L8.274|
000112  e005              B        |L8.288|
                  |L8.276|
000114  200a              MOVS     r0,#0xa               ;265
000116  e794              B        |L8.66|
                  |L8.280|
000118  1bad              SUBS     r5,r5,r6              ;272
00011a  44b1              ADD      r9,r9,r6              ;270
00011c  44b0              ADD      r8,r8,r6              ;271
00011e  1ba4              SUBS     r4,r4,r6              ;273
                  |L8.288|
000120  2c00              CMP      r4,#0                 ;261
000122  d0db              BEQ      |L8.220|
000124  e7e2              B        |L8.236|
                  |L8.294|
000126  2001              MOVS     r0,#1                 ;287
000128  e78b              B        |L8.66|
;;;290    
                          ENDP

00012a  0000              DCW      0x0000
                  |L8.300|
                          DCD      g_board_info+0x10
                  |L8.304|
                          DCD      ||.data||
                  |L8.308|
                          DCD      g_target_family

                          AREA ||i.target_flash_program_page_min_size||, CODE, READONLY, ALIGN=2

                  target_flash_program_page_min_size PROC
;;;352    
;;;353    static uint32_t target_flash_program_page_min_size(uint32_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;354    {
000002  4605              MOV      r5,r0
;;;355        if (g_board_info.target_cfg){
000004  4808              LDR      r0,|L9.40|
000006  f7fffffe          BL       __aeabi_uread4
00000a  2800              CMP      r0,#0
00000c  d00b              BEQ      |L9.38|
;;;356            uint32_t size = 256;
00000e  f44f7480          MOV      r4,#0x100
;;;357            if (size > target_flash_erase_sector_size(addr)) {
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       target_flash_erase_sector_size
000018  42a0              CMP      r0,r4
00001a  d203              BCS      |L9.36|
;;;358                size = target_flash_erase_sector_size(addr);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       target_flash_erase_sector_size
000022  4604              MOV      r4,r0
                  |L9.36|
;;;359            }
;;;360            return size;
000024  4620              MOV      r0,r4
                  |L9.38|
;;;361        } else {
;;;362            return 0;
;;;363        }
;;;364    }
000026  bd70              POP      {r4-r6,pc}
;;;365    
                          ENDP

                  |L9.40|
                          DCD      g_board_info+0x10

                          AREA ||i.target_flash_set||, CODE, READONLY, ALIGN=2

                  target_flash_set PROC
;;;126    
;;;127    static error_t target_flash_set(uint32_t addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;128    {
;;;129        program_target_t * new_flash_algo = get_flash_algo(addr);
000004  f7fffffe          BL       get_flash_algo
000008  0004              MOVS     r4,r0
;;;130        if (new_flash_algo == NULL) {
00000a  d01f              BEQ      |L10.76|
;;;131            return ERROR_ALGO_MISSING;
;;;132        }
;;;133        if(current_flash_algo != new_flash_algo){
00000c  4d11              LDR      r5,|L10.84|
00000e  6868              LDR      r0,[r5,#4]  ; current_flash_algo
000010  42a0              CMP      r0,r4
000012  d018              BEQ      |L10.70|
;;;134            //run uninit to last func
;;;135            error_t status = flash_func_start(FLASH_FUNC_NOP);
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       flash_func_start
;;;136            if (status != ERROR_SUCCESS) {
00001a  2800              CMP      r0,#0
00001c  d114              BNE      |L10.72|
;;;137                return status;
;;;138            }
;;;139            // Download flash programming algorithm to target
;;;140            if (0 == swd_write_memory(new_flash_algo->algo_start, (uint8_t *)new_flash_algo->algo_blob, new_flash_algo->algo_size)) {
00001e  f104002c          ADD      r0,r4,#0x2c
000022  f7fffffe          BL       __aeabi_uread4
000026  4607              MOV      r7,r0
000028  f1040030          ADD      r0,r4,#0x30
00002c  f7fffffe          BL       __aeabi_uread4
000030  4606              MOV      r6,r0
000032  f1040028          ADD      r0,r4,#0x28
000036  f7fffffe          BL       __aeabi_uread4
00003a  463a              MOV      r2,r7
00003c  4631              MOV      r1,r6
00003e  f7fffffe          BL       swd_write_memory
000042  b128              CBZ      r0,|L10.80|
;;;141                return ERROR_ALGO_DL;
;;;142            }
;;;143            
;;;144            current_flash_algo = new_flash_algo;
000044  606c              STR      r4,[r5,#4]  ; current_flash_algo
                  |L10.70|
;;;145            
;;;146        }
;;;147        return ERROR_SUCCESS;
000046  2000              MOVS     r0,#0
                  |L10.72|
;;;148    }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L10.76|
00004c  2009              MOVS     r0,#9                 ;131
00004e  e7fb              B        |L10.72|
                  |L10.80|
000050  2008              MOVS     r0,#8                 ;141
000052  e7f9              B        |L10.72|
;;;149    
                          ENDP

                  |L10.84|
                          DCD      ||.data||

                          AREA ||i.target_flash_uninit||, CODE, READONLY, ALIGN=2

                  target_flash_uninit PROC
;;;177    
;;;178    static error_t target_flash_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;179    {
;;;180        if (g_board_info.target_cfg) {
000002  480e              LDR      r0,|L11.60|
000004  f7fffffe          BL       __aeabi_uread4
000008  b1b0              CBZ      r0,|L11.56|
;;;181            error_t status = flash_func_start(FLASH_FUNC_NOP);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       flash_func_start
;;;182            if (status != ERROR_SUCCESS) {
000010  2800              CMP      r0,#0
000012  d110              BNE      |L11.54|
;;;183                return status;
;;;184            }
;;;185            if (config_get_auto_rst()) {
000014  f7fffffe          BL       config_get_auto_rst
000018  b108              CBZ      r0,|L11.30|
;;;186                // Resume the target if configured to do so
;;;187                target_set_state(RESET_RUN);
00001a  2002              MOVS     r0,#2
00001c  e000              B        |L11.32|
                  |L11.30|
;;;188            } else {
;;;189                // Leave the target halted until a reset occurs
;;;190                target_set_state(RESET_PROGRAM);
00001e  2001              MOVS     r0,#1
                  |L11.32|
000020  f7fffffe          BL       target_set_state
;;;191            }
;;;192            // Check to see if anything needs to be done after programming.
;;;193            // This is usually a no-op for most targets.
;;;194            target_set_state(POST_FLASH_RESET);
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       target_set_state
;;;195          
;;;196            state = STATE_CLOSED;
00002a  4905              LDR      r1,|L11.64|
00002c  2000              MOVS     r0,#0
00002e  7008              STRB     r0,[r1,#0]
;;;197            swd_off();
000030  f7fffffe          BL       swd_off
;;;198            return ERROR_SUCCESS;
000034  2000              MOVS     r0,#0
                  |L11.54|
;;;199        } else {
;;;200            return ERROR_FAILURE;
;;;201        }
;;;202    }
000036  bd10              POP      {r4,pc}
                  |L11.56|
000038  2001              MOVS     r0,#1                 ;200
00003a  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  |L11.60|
                          DCD      g_board_info+0x10
                  |L11.64|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  flash_intf
                          DCD      target_flash_init
                          DCD      target_flash_uninit
                          DCD      target_flash_program_page
                          DCD      target_flash_erase_sector
                          DCD      target_flash_erase_chip
                          DCD      target_flash_program_page_min_size
                          DCD      target_flash_erase_sector_size
                          DCD      target_flash_busy
                          DCD      target_flash_set

                          AREA ||area_number.15||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.constdata||
                  flash_intf_target
                          DCD      flash_intf

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00                DCB      0x00
                  last_flash_func
000001  000000            DCB      0x00,0x00,0x00
                  current_flash_algo
                          DCD      0x00000000
                  default_region
                          DCD      0x00000000
                  flash_start
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\interface\\target_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_target_flash_c_89c53bb5____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___14_target_flash_c_89c53bb5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_target_flash_c_89c53bb5____REVSH|
#line 144
|__asm___14_target_flash_c_89c53bb5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
