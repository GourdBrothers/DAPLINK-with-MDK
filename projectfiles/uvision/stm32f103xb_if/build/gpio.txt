; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\gpio.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\gpio.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\gpio.crf ..\..\..\source\hic_hal\stm32\stm32f103xb\gpio.c]
                          THUMB

                          AREA ||i.GPIOGetButtonState||, CODE, READONLY, ALIGN=1

                  GPIOGetButtonState PROC
;;;220    
;;;221    uint8_t GPIOGetButtonState(void)
000000  2000              MOVS     r0,#0
;;;222    {
;;;223        return 0;
;;;224    }
000002  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.gpio_get_reset_btn_fwrd||, CODE, READONLY, ALIGN=1

                  gpio_get_reset_btn_fwrd PROC
;;;214    
;;;215    uint8_t gpio_get_reset_btn_fwrd(void)
000000  2000              MOVS     r0,#0
;;;216    {
;;;217        return 0;
;;;218    }
000002  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.gpio_get_reset_btn_no_fwrd||, CODE, READONLY, ALIGN=2

                  gpio_get_reset_btn_no_fwrd PROC
;;;209    
;;;210    uint8_t gpio_get_reset_btn_no_fwrd(void)
000000  4802              LDR      r0,|L3.12|
;;;211    {
;;;212        return (nRESET_PIN_PORT->IDR & nRESET_PIN) ? 0 : 1;
000002  6800              LDR      r0,[r0,#0]
000004  f3400000          SBFX     r0,r0,#0,#1
000008  1c40              ADDS     r0,r0,#1
;;;213    }
00000a  4770              BX       lr
;;;214    
                          ENDP

                  |L3.12|
                          DCD      0x40010c08

                          AREA ||i.gpio_init||, CODE, READONLY, ALIGN=2

                  gpio_init PROC
;;;115    
;;;116    void gpio_init(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;117    {
;;;118        GPIO_InitTypeDef GPIO_InitStructure;
;;;119        // enable clock to ports
;;;120        __HAL_RCC_GPIOA_CLK_ENABLE();
000004  4854              LDR      r0,|L4.344|
000006  b085              SUB      sp,sp,#0x14           ;117
000008  6981              LDR      r1,[r0,#0x18]
00000a  f0410104          ORR      r1,r1,#4
00000e  6181              STR      r1,[r0,#0x18]
000010  6981              LDR      r1,[r0,#0x18]
000012  f0010104          AND      r1,r1,#4
;;;121        __HAL_RCC_GPIOB_CLK_ENABLE();
000016  9104              STR      r1,[sp,#0x10]
000018  6981              LDR      r1,[r0,#0x18]
00001a  f0410108          ORR      r1,r1,#8
00001e  6181              STR      r1,[r0,#0x18]
000020  6981              LDR      r1,[r0,#0x18]
000022  f0010108          AND      r1,r1,#8
;;;122        __HAL_RCC_GPIOC_CLK_ENABLE();
000026  9104              STR      r1,[sp,#0x10]
000028  6981              LDR      r1,[r0,#0x18]
00002a  f0410110          ORR      r1,r1,#0x10
00002e  6181              STR      r1,[r0,#0x18]
000030  6981              LDR      r1,[r0,#0x18]
000032  f0010110          AND      r1,r1,#0x10
;;;123        __HAL_RCC_GPIOD_CLK_ENABLE();
000036  9104              STR      r1,[sp,#0x10]
000038  6981              LDR      r1,[r0,#0x18]
00003a  f0410120          ORR      r1,r1,#0x20
00003e  6181              STR      r1,[r0,#0x18]
000040  6981              LDR      r1,[r0,#0x18]
000042  f0010120          AND      r1,r1,#0x20
;;;124        // Enable USB connect pin
;;;125        __HAL_RCC_AFIO_CLK_ENABLE();
000046  9104              STR      r1,[sp,#0x10]
000048  6981              LDR      r1,[r0,#0x18]
00004a  f0410101          ORR      r1,r1,#1
00004e  6181              STR      r1,[r0,#0x18]
000050  6981              LDR      r1,[r0,#0x18]
000052  f0010101          AND      r1,r1,#1
;;;126        // Disable JTAG to free pins for other uses
;;;127        // Note - SWD is still enabled
;;;128        __HAL_AFIO_REMAP_SWJ_NOJTAG();
000056  9104              STR      r1,[sp,#0x10]
000058  4940              LDR      r1,|L4.348|
00005a  684a              LDR      r2,[r1,#4]
00005c  f02262e0          BIC      r2,r2,#0x7000000
000060  f0427200          ORR      r2,r2,#0x2000000
000064  604a              STR      r2,[r1,#4]
;;;129    
;;;130        USB_CONNECT_PORT_ENABLE();
000066  6981              LDR      r1,[r0,#0x18]
000068  f0410104          ORR      r1,r1,#4
00006c  6181              STR      r1,[r0,#0x18]
00006e  6980              LDR      r0,[r0,#0x18]
;;;131        USB_CONNECT_OFF();
000070  f44f4600          MOV      r6,#0x8000
000074  f0000004          AND      r0,r0,#4              ;130
000078  9004              STR      r0,[sp,#0x10]
00007a  4839              LDR      r0,|L4.352|
00007c  6006              STR      r6,[r0,#0]
;;;132        GPIO_InitStructure.Pin = USB_CONNECT_PIN;
;;;133        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;134        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
00007e  2401              MOVS     r4,#1
;;;135        HAL_GPIO_Init(USB_CONNECT_PORT, &GPIO_InitStructure);
000080  f8df90dc          LDR      r9,|L4.352|
000084  e9cd6400          STRD     r6,r4,[sp,#0]
000088  2503              MOVS     r5,#3                 ;133
00008a  f1a90914          SUB      r9,r9,#0x14
00008e  4669              MOV      r1,sp
000090  4648              MOV      r0,r9
000092  9503              STR      r5,[sp,#0xc]
000094  f7fffffe          BL       HAL_GPIO_Init
;;;136        // configure LEDs
;;;137        HAL_GPIO_WritePin(RUNNING_LED_PORT, RUNNING_LED_PIN, GPIO_PIN_SET);
000098  2201              MOVS     r2,#1
00009a  0257              LSLS     r7,r2,#9
00009c  4639              MOV      r1,r7
00009e  4648              MOV      r0,r9
0000a0  f7fffffe          BL       HAL_GPIO_WritePin
;;;138        GPIO_InitStructure.Pin = RUNNING_LED_PIN;
;;;139        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;140        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;141        HAL_GPIO_Init(RUNNING_LED_PORT, &GPIO_InitStructure);
0000a4  e9cd7400          STRD     r7,r4,[sp,#0]
0000a8  4669              MOV      r1,sp
0000aa  4648              MOV      r0,r9
0000ac  9503              STR      r5,[sp,#0xc]
0000ae  f7fffffe          BL       HAL_GPIO_Init
;;;142    
;;;143        HAL_GPIO_WritePin(CONNECTED_LED_PORT, CONNECTED_LED_PIN, GPIO_PIN_SET);
0000b2  f8df80b0          LDR      r8,|L4.356|
0000b6  2201              MOVS     r2,#1
0000b8  2140              MOVS     r1,#0x40
0000ba  4640              MOV      r0,r8
0000bc  f7fffffe          BL       HAL_GPIO_WritePin
;;;144        GPIO_InitStructure.Pin = CONNECTED_LED_PIN;
0000c0  2040              MOVS     r0,#0x40
;;;145        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;146        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;147        HAL_GPIO_Init(CONNECTED_LED_PORT, &GPIO_InitStructure);
0000c2  e9cd0400          STRD     r0,r4,[sp,#0]
0000c6  4669              MOV      r1,sp
0000c8  9503              STR      r5,[sp,#0xc]
0000ca  4640              MOV      r0,r8
0000cc  f7fffffe          BL       HAL_GPIO_Init
;;;148    
;;;149        HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, GPIO_PIN_SET);
0000d0  2201              MOVS     r2,#1
0000d2  4639              MOV      r1,r7
0000d4  4648              MOV      r0,r9
0000d6  f7fffffe          BL       HAL_GPIO_WritePin
;;;150        GPIO_InitStructure.Pin = PIN_CDC_LED;
;;;151        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;152        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;153        HAL_GPIO_Init(PIN_CDC_LED_PORT, &GPIO_InitStructure);
0000da  e9cd7400          STRD     r7,r4,[sp,#0]
0000de  4669              MOV      r1,sp
0000e0  4648              MOV      r0,r9
0000e2  9503              STR      r5,[sp,#0xc]
0000e4  f7fffffe          BL       HAL_GPIO_Init
;;;154    
;;;155        HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, GPIO_PIN_SET);
0000e8  2201              MOVS     r2,#1
0000ea  4639              MOV      r1,r7
0000ec  4648              MOV      r0,r9
0000ee  f7fffffe          BL       HAL_GPIO_WritePin
;;;156        GPIO_InitStructure.Pin = PIN_MSC_LED;
;;;157        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;158        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;159        HAL_GPIO_Init(PIN_MSC_LED_PORT, &GPIO_InitStructure);
0000f2  e9cd7400          STRD     r7,r4,[sp,#0]
0000f6  4669              MOV      r1,sp
0000f8  4648              MOV      r0,r9
0000fa  9503              STR      r5,[sp,#0xc]
0000fc  f7fffffe          BL       HAL_GPIO_Init
;;;160    
;;;161        // reset button configured as gpio open drain output with a pullup
;;;162        HAL_GPIO_WritePin(nRESET_PIN_PORT, nRESET_PIN, GPIO_PIN_SET);
000100  2201              MOVS     r2,#1
000102  4611              MOV      r1,r2
000104  4640              MOV      r0,r8
000106  f7fffffe          BL       HAL_GPIO_WritePin
;;;163        GPIO_InitStructure.Pin = nRESET_PIN;
;;;164        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_OD;
00010a  2011              MOVS     r0,#0x11
00010c  e9cd4000          STRD     r4,r0,[sp,#0]
;;;165        GPIO_InitStructure.Pull = GPIO_PULLUP;
;;;166        HAL_GPIO_Init(nRESET_PIN_PORT, &GPIO_InitStructure);
000110  4669              MOV      r1,sp
000112  4640              MOV      r0,r8
000114  9402              STR      r4,[sp,#8]
000116  f7fffffe          BL       HAL_GPIO_Init
;;;167    
;;;168        // Turn on power to the board. When the target is unpowered
;;;169        // it holds the reset line low.
;;;170        HAL_GPIO_WritePin(POWER_EN_PIN_PORT, POWER_EN_PIN, GPIO_PIN_RESET);
00011a  2200              MOVS     r2,#0
00011c  4631              MOV      r1,r6
00011e  4640              MOV      r0,r8
000120  f7fffffe          BL       HAL_GPIO_WritePin
;;;171        GPIO_InitStructure.Pin = POWER_EN_PIN;
;;;172        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;173        GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
;;;174        HAL_GPIO_Init(POWER_EN_PIN_PORT, &GPIO_InitStructure);
000124  e9cd6400          STRD     r6,r4,[sp,#0]
000128  4669              MOV      r1,sp
00012a  4640              MOV      r0,r8
00012c  9503              STR      r5,[sp,#0xc]
00012e  f7fffffe          BL       HAL_GPIO_Init
;;;175    
;;;176        // Setup the 8MHz MCO
;;;177        GPIO_InitStructure.Pin = GPIO_PIN_8;
000132  0220              LSLS     r0,r4,#8
;;;178        GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
;;;179        GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
000134  9000              STR      r0,[sp,#0]
000136  2002              MOVS     r0,#2
;;;180        HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
000138  9001              STR      r0,[sp,#4]
00013a  9503              STR      r5,[sp,#0xc]          ;179
00013c  4669              MOV      r1,sp
00013e  4648              MOV      r0,r9
000140  f7fffffe          BL       HAL_GPIO_Init
;;;181        output_clock_enable();
000144  f7fffffe          BL       output_clock_enable
;;;182    
;;;183        // Let the voltage rails stabilize.  This is especailly important
;;;184        // during software resets, since the target's 3.3v rail can take
;;;185        // 20-50ms to drain.  During this time the target could be driving
;;;186        // the reset pin low, causing the bootloader to think the reset
;;;187        // button is pressed.
;;;188        // Note: With optimization set to -O2 the value 1000000 delays for ~85ms
;;;189        busy_wait(1000000);
000148  4807              LDR      r0,|L4.360|
00014a  9004              STR      r0,[sp,#0x10]
                  |L4.332|
00014c  1e40              SUBS     r0,r0,#1
00014e  9004              STR      r0,[sp,#0x10]
000150  d1fc              BNE      |L4.332|
;;;190    }
000152  b005              ADD      sp,sp,#0x14
000154  e8bd83f0          POP      {r4-r9,pc}
;;;191    
                          ENDP

                  |L4.344|
                          DCD      0x40021000
                  |L4.348|
                          DCD      0x40010000
                  |L4.352|
                          DCD      0x40010814
                  |L4.356|
                          DCD      0x40010c00
                  |L4.360|
                          DCD      0x000f4240

                          AREA ||i.gpio_set_board_power||, CODE, READONLY, ALIGN=1

                  gpio_set_board_power PROC
;;;230    
;;;231    void gpio_set_board_power(bool powerEnabled)
000000  4770              BX       lr
;;;232    {
;;;233    }
                          ENDP


                          AREA ||i.gpio_set_cdc_led||, CODE, READONLY, ALIGN=2

                  gpio_set_cdc_led PROC
;;;197    
;;;198    void gpio_set_cdc_led(gpio_led_state_t state)
000000  b128              CBZ      r0,|L6.14|
;;;199    {
;;;200        // LED is active low
;;;201        HAL_GPIO_WritePin(PIN_CDC_LED_PORT, PIN_CDC_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
000002  2200              MOVS     r2,#0
                  |L6.4|
000004  f44f7100          MOV      r1,#0x200
000008  4802              LDR      r0,|L6.20|
00000a  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L6.14|
00000e  2201              MOVS     r2,#1
000010  e7f8              B        |L6.4|
;;;202    }
;;;203    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40010800

                          AREA ||i.gpio_set_hid_led||, CODE, READONLY, ALIGN=2

                  gpio_set_hid_led PROC
;;;191    
;;;192    void gpio_set_hid_led(gpio_led_state_t state)
000000  b128              CBZ      r0,|L7.14|
;;;193    {
;;;194        // LED is active low
;;;195        HAL_GPIO_WritePin(PIN_HID_LED_PORT, PIN_HID_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
000002  2200              MOVS     r2,#0
                  |L7.4|
000004  f44f7100          MOV      r1,#0x200
000008  4802              LDR      r0,|L7.20|
00000a  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L7.14|
00000e  2201              MOVS     r2,#1
000010  e7f8              B        |L7.4|
;;;196    }
;;;197    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40010800

                          AREA ||i.gpio_set_msc_led||, CODE, READONLY, ALIGN=2

                  gpio_set_msc_led PROC
;;;203    
;;;204    void gpio_set_msc_led(gpio_led_state_t state)
000000  b128              CBZ      r0,|L8.14|
;;;205    {
;;;206        // LED is active low
;;;207        HAL_GPIO_WritePin(PIN_MSC_LED_PORT, PIN_MSC_LED, state ? GPIO_PIN_RESET : GPIO_PIN_SET);
000002  2200              MOVS     r2,#0
                  |L8.4|
000004  f44f7100          MOV      r1,#0x200
000008  4802              LDR      r0,|L8.20|
00000a  f7ffbffe          B.W      HAL_GPIO_WritePin
                  |L8.14|
00000e  2201              MOVS     r2,#1
000010  e7f8              B        |L8.4|
;;;208    }
;;;209    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40010800

                          AREA ||i.output_clock_enable||, CODE, READONLY, ALIGN=2

                  output_clock_enable PROC
;;;54     
;;;55     static void output_clock_enable(void)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  b08e              SUB      sp,sp,#0x38
;;;57         HAL_StatusTypeDef ret;
;;;58         RCC_ClkInitTypeDef clk_init;
;;;59         TIM_OC_InitTypeDef pwm_config;
;;;60         uint32_t unused;
;;;61         uint32_t period;
;;;62         uint32_t source_clock;
;;;63     
;;;64         HAL_RCC_GetClockConfig(&clk_init, &unused);
000004  a90c              ADD      r1,sp,#0x30
000006  a807              ADD      r0,sp,#0x1c
000008  f7fffffe          BL       HAL_RCC_GetClockConfig
00000c  980b              LDR      r0,[sp,#0x2c]
00000e  f5b05f00          CMP      r0,#0x2000
000012  d005              BEQ      |L9.32|
000014  f5b05f20          CMP      r0,#0x2800
000018  d023              BEQ      |L9.98|
00001a  f5b05f40          CMP      r0,#0x3000
00001e  d022              BEQ      |L9.102|
                  |L9.32|
000020  2001              MOVS     r0,#1
                  |L9.34|
;;;65     
;;;66         /* Compute the period value to have TIMx counter clock equal to 8000000 Hz */
;;;67         source_clock = SystemCoreClock / tim1_clk_div(clk_init.APB2CLKDivider);
000022  4925              LDR      r1,|L9.184|
;;;68         period = (uint32_t)(source_clock / 8000000) - 1;
;;;69     
;;;70         /* Set TIMx instance */
;;;71         timer.Instance = TIM1;
000024  4d27              LDR      r5,|L9.196|
;;;72     
;;;73         timer.Init.Period            = period;
;;;74         timer.Init.Prescaler         = 0;
000026  2400              MOVS     r4,#0
000028  6809              LDR      r1,[r1,#0]            ;67  ; SystemCoreClock
00002a  fbb1f0f0          UDIV     r0,r1,r0              ;67
00002e  4923              LDR      r1,|L9.188|
000030  fbb0f6f1          UDIV     r6,r0,r1              ;68
000034  4822              LDR      r0,|L9.192|
000036  e9c50400          STRD     r0,r4,[r5,#0]
00003a  1e76              SUBS     r6,r6,#1
00003c  e9c56403          STRD     r6,r4,[r5,#0xc]
;;;75         timer.Init.ClockDivision     = 0;
;;;76         timer.Init.CounterMode       = TIM_COUNTERMODE_UP;
;;;77         timer.Init.RepetitionCounter = 0;//period / 2;
;;;78     
;;;79         __HAL_RCC_TIM1_CLK_ENABLE();
000040  4821              LDR      r0,|L9.200|
000042  60ac              STR      r4,[r5,#8]            ;77  ; timer
000044  616c              STR      r4,[r5,#0x14]  ; timer
000046  6981              LDR      r1,[r0,#0x18]
000048  f4416100          ORR      r1,r1,#0x800
00004c  6181              STR      r1,[r0,#0x18]
00004e  6980              LDR      r0,[r0,#0x18]
000050  f4006000          AND      r0,r0,#0x800
;;;80     
;;;81         ret = HAL_TIM_PWM_DeInit(&timer);
000054  900d              STR      r0,[sp,#0x34]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       HAL_TIM_PWM_DeInit
;;;82         if (ret != HAL_OK) {
00005c  b128              CBZ      r0,|L9.106|
;;;83             util_assert(0);
00005e  2253              MOVS     r2,#0x53
;;;84             return;
000060  e023              B        |L9.170|
                  |L9.98|
000062  2002              MOVS     r0,#2
000064  e7dd              B        |L9.34|
                  |L9.102|
000066  2004              MOVS     r0,#4
000068  e7db              B        |L9.34|
                  |L9.106|
;;;85         }
;;;86     
;;;87         ret = HAL_TIM_PWM_Init(&timer);
00006a  4816              LDR      r0,|L9.196|
00006c  f7fffffe          BL       HAL_TIM_PWM_Init
;;;88         if (ret != HAL_OK) {
000070  b108              CBZ      r0,|L9.118|
;;;89             util_assert(0);
000072  2259              MOVS     r2,#0x59
;;;90             return;
000074  e019              B        |L9.170|
                  |L9.118|
;;;91         }
;;;92     
;;;93         pwm_config.OCMode = TIM_OCMODE_PWM2;
000076  2070              MOVS     r0,#0x70
000078  e9cd0400          STRD     r0,r4,[sp,#0]
;;;94         pwm_config.Pulse = 0; // TODO - make sure this isn't used
;;;95         pwm_config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;96         pwm_config.OCNPolarity = TIM_OCPOLARITY_HIGH;
00007c  9402              STR      r4,[sp,#8]
;;;97         pwm_config.OCFastMode = TIM_OCFAST_DISABLE;
00007e  9403              STR      r4,[sp,#0xc]
;;;98         pwm_config.OCIdleState = TIM_OCIDLESTATE_RESET;
000080  9404              STR      r4,[sp,#0x10]
;;;99         pwm_config.OCNIdleState = TIM_OCIDLESTATE_RESET;
000082  9405              STR      r4,[sp,#0x14]
;;;100        ret = HAL_TIM_PWM_ConfigChannel(&timer, &pwm_config, TIM_CHANNEL_1);
000084  2200              MOVS     r2,#0
000086  4669              MOV      r1,sp
000088  480e              LDR      r0,|L9.196|
00008a  9406              STR      r4,[sp,#0x18]
00008c  f7fffffe          BL       HAL_TIM_PWM_ConfigChannel
;;;101        if (ret != HAL_OK) {
000090  b108              CBZ      r0,|L9.150|
;;;102            util_assert(0);
000092  2266              MOVS     r2,#0x66
;;;103            return;
000094  e009              B        |L9.170|
                  |L9.150|
;;;104        }
;;;105        
;;;106        __HAL_TIM_SET_COMPARE(&timer, TIM_CHANNEL_1, period / 2);
000096  6829              LDR      r1,[r5,#0]  ; timer
000098  0870              LSRS     r0,r6,#1
00009a  6348              STR      r0,[r1,#0x34]
;;;107        ret = HAL_TIM_PWM_Start(&timer, TIM_CHANNEL_1);
00009c  2100              MOVS     r1,#0
00009e  4809              LDR      r0,|L9.196|
0000a0  f7fffffe          BL       HAL_TIM_PWM_Start
;;;108        if (ret != HAL_OK) {
0000a4  2800              CMP      r0,#0
0000a6  d004              BEQ      |L9.178|
;;;109            util_assert(0);
0000a8  226d              MOVS     r2,#0x6d
                  |L9.170|
0000aa  a108              ADR      r1,|L9.204|
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       _util_assert
                  |L9.178|
;;;110            return;
;;;111        }
;;;112    
;;;113        return;
;;;114    }
0000b2  b00e              ADD      sp,sp,#0x38
0000b4  bd70              POP      {r4-r6,pc}
;;;115    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L9.184|
                          DCD      SystemCoreClock
                  |L9.188|
                          DCD      0x007a1200
                  |L9.192|
                          DCD      0x40012c00
                  |L9.196|
                          DCD      ||.bss||
                  |L9.200|
                          DCD      0x40021000
                  |L9.204|
0000cc  2e2e5c2e          DCB      "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\gpio.c"
0000d0  2e5c2e2e
0000d4  5c736f75
0000d8  7263655c
0000dc  6869635f
0000e0  68616c5c
0000e4  73746d33
0000e8  325c7374
0000ec  6d333266
0000f0  31303378
0000f4  625c6770
0000f8  696f2e63
0000fc  00                DCB      0
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0

                          AREA ||i.target_forward_reset||, CODE, READONLY, ALIGN=1

                  target_forward_reset PROC
;;;225    
;;;226    void target_forward_reset(bool assert_reset)
000000  4770              BX       lr
;;;227    {
;;;228        // Do nothing - reset is forwarded in gpio_get_sw_reset
;;;229    }
;;;230    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  timer
                          %        60

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\hic_hal\\stm32\\stm32f103xb\\gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_c8a4be98____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___6_gpio_c_c8a4be98____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_c8a4be98____REVSH|
#line 144
|__asm___6_gpio_c_c8a4be98____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
