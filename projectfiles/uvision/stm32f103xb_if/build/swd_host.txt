; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\swd_host.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\swd_host.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\swd_host.crf ..\..\..\source\daplink\interface\swd_host.c]
                          THUMB

                          AREA ||i.JTAG2SWD||, CODE, READONLY, ALIGN=1

                  JTAG2SWD PROC
;;;766    
;;;767    static uint8_t JTAG2SWD()
000000  b51c              PUSH     {r2-r4,lr}
;;;768    {
;;;769        uint32_t tmp = 0;
;;;770    
;;;771        if (!swd_reset()) {
000002  f7fffffe          BL       swd_reset
000006  2800              CMP      r0,#0
000008  d01c              BEQ      |L1.68|
00000a  209e              MOVS     r0,#0x9e
00000c  f88d0000          STRB     r0,[sp,#0]
000010  20e7              MOVS     r0,#0xe7
000012  f88d0001          STRB     r0,[sp,#1]
000016  4669              MOV      r1,sp
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       SWJ_Sequence
00001e  2401              MOVS     r4,#1
;;;772            return 0;
;;;773        }
;;;774    
;;;775        if (!swd_switch(0xE79E)) {
;;;776            return 0;
;;;777        }
;;;778    
;;;779        if (!swd_reset()) {
000020  f7fffffe          BL       swd_reset
000024  2800              CMP      r0,#0                 ;775
000026  d00d              BEQ      |L1.68|
000028  2000              MOVS     r0,#0                 ;775
00002a  f88d0000          STRB     r0,[sp,#0]            ;775
00002e  4669              MOV      r1,sp                 ;775
000030  2008              MOVS     r0,#8                 ;775
000032  f7fffffe          BL       SWJ_Sequence
000036  a901              ADD      r1,sp,#4              ;775
000038  2000              MOVS     r0,#0                 ;775
00003a  f7fffffe          BL       swd_read_dp
00003e  2801              CMP      r0,#1                 ;775
000040  d101              BNE      |L1.70|
000042  b104              CBZ      r4,|L1.70|
                  |L1.68|
;;;780            return 0;
;;;781        }
;;;782    
;;;783        if (!swd_read_idcode(&tmp)) {
;;;784            return 0;
;;;785        }
;;;786    
;;;787        return 1;
;;;788    }
000044  bd1c              POP      {r2-r4,pc}
                  |L1.70|
000046  2000              MOVS     r0,#0                 ;784
000048  bd1c              POP      {r2-r4,pc}
;;;789    
                          ENDP


                          AREA ||i.PORT_SWD_SETUP||, CODE, READONLY, ALIGN=2

                  PORT_SWD_SETUP PROC
;;;228    */
;;;229    static __inline void PORT_SWD_SETUP(void)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
;;;231        // Set SWCLK HIGH
;;;232        pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);
000002  4c10              LDR      r4,|L2.68|
000004  210d              MOVS     r1,#0xd
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       pin_out_init
;;;233        SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
00000c  4d0d              LDR      r5,|L2.68|
00000e  1460              ASRS     r0,r4,#17
000010  3510              ADDS     r5,r5,#0x10
000012  6028              STR      r0,[r5,#0]
;;;234        // Set SWDIO HIGH
;;;235        pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
000014  210e              MOVS     r1,#0xe
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pin_out_init
;;;236        SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
00001c  f44f4080          MOV      r0,#0x4000
000020  6028              STR      r0,[r5,#0]
;;;237    
;;;238        pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 1);
000022  2201              MOVS     r2,#1
000024  210c              MOVS     r1,#0xc
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       pin_in_init
00002c  6820              LDR      r0,[r4,#0]
00002e  f020000f          BIC      r0,r0,#0xf
000032  6020              STR      r0,[r4,#0]
000034  6820              LDR      r0,[r4,#0]
000036  f0400007          ORR      r0,r0,#7
00003a  6020              STR      r0,[r4,#0]
;;;239        // Set RESET HIGH
;;;240        pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);//TODO - fix reset logic
;;;241        nRESET_PIN_PORT->BSRR = nRESET_PIN;
00003c  2001              MOVS     r0,#1
00003e  6028              STR      r0,[r5,#0]
;;;242    }
000040  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x40010c00

                          AREA ||i.int2array||, CODE, READONLY, ALIGN=1

                  int2array PROC
;;;79     
;;;80     void int2array(uint8_t *res, uint32_t data, uint8_t len)
000000  b510              PUSH     {r4,lr}
;;;81     {
;;;82         uint8_t i = 0;
000002  2300              MOVS     r3,#0
000004  e005              B        |L3.18|
                  |L3.6|
;;;83     
;;;84         for (i = 0; i < len; i++) {
;;;85             res[i] = (data >> 8 * i) & 0xff;
000006  00dc              LSLS     r4,r3,#3
000008  fa21f404          LSR      r4,r1,r4
00000c  54c4              STRB     r4,[r0,r3]
00000e  1c5b              ADDS     r3,r3,#1
000010  b2db              UXTB     r3,r3                 ;84
                  |L3.18|
000012  4293              CMP      r3,r2                 ;84
000014  d3f7              BCC      |L3.6|
;;;86         }
;;;87     }
000016  bd10              POP      {r4,pc}
;;;88     
                          ENDP


                          AREA ||i.pin_in_init||, CODE, READONLY, ALIGN=1

                  pin_in_init PROC
;;;144    
;;;145    static __inline void pin_in_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit, uint8_t mode)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
;;;147        uint8_t config;
;;;148        if(mode == 1)
000002  2a01              CMP      r2,#1
000004  d012              BEQ      |L4.44|
;;;149            config = 0x08; //Up
;;;150        else if(mode == 2)
000006  2a02              CMP      r2,#2
000008  d010              BEQ      |L4.44|
;;;151            config = 0x08; //down
;;;152        else
;;;153            config = 0x00; //GPIO_Mode_AIN
00000a  2300              MOVS     r3,#0
                  |L4.12|
00000c  2401              MOVS     r4,#1                 ;146
;;;154    
;;;155        if(pin_bit >= 8)
;;;156        {
;;;157            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
;;;158            GPIOx->CRH |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit-8) << 2) );
;;;159            if(mode == 1)
;;;160                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
00000e  408c              LSLS     r4,r4,r1
000010  260f              MOVS     r6,#0xf               ;157
000012  008d              LSLS     r5,r1,#2              ;157
000014  2908              CMP      r1,#8                 ;155
000016  d311              BCC      |L4.60|
000018  3d20              SUBS     r5,r5,#0x20           ;155
00001a  6841              LDR      r1,[r0,#4]            ;157
00001c  40ae              LSLS     r6,r6,r5              ;157
00001e  43b1              BICS     r1,r1,r6              ;157
000020  6041              STR      r1,[r0,#4]            ;157
000022  6841              LDR      r1,[r0,#4]            ;158
000024  40ab              LSLS     r3,r3,r5              ;158
000026  430b              ORRS     r3,r3,r1              ;158
000028  6043              STR      r3,[r0,#4]            ;158
00002a  e00f              B        |L4.76|
                  |L4.44|
00002c  2308              MOVS     r3,#8                 ;151
00002e  e7ed              B        |L4.12|
                  |L4.48|
000030  6104              STR      r4,[r0,#0x10]
                  |L4.50|
;;;161            else if(mode == 2)
;;;162                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;163        }
;;;164        else
;;;165        {
;;;166            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;167            GPIOx->CRL |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit) << 2) );
;;;168            if(mode == 1)
;;;169                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
;;;170            else if(mode == 2)
;;;171                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;172        }
;;;173    }
000032  bd70              POP      {r4-r6,pc}
                  |L4.52|
000034  2a02              CMP      r2,#2                 ;161
000036  d1fc              BNE      |L4.50|
000038  6144              STR      r4,[r0,#0x14]         ;162
00003a  bd70              POP      {r4-r6,pc}
                  |L4.60|
00003c  6801              LDR      r1,[r0,#0]            ;166
00003e  40ae              LSLS     r6,r6,r5              ;166
000040  43b1              BICS     r1,r1,r6              ;166
000042  6001              STR      r1,[r0,#0]            ;166
000044  6801              LDR      r1,[r0,#0]            ;167
000046  40ab              LSLS     r3,r3,r5              ;167
000048  430b              ORRS     r3,r3,r1              ;167
00004a  6003              STR      r3,[r0,#0]            ;167
                  |L4.76|
00004c  2a01              CMP      r2,#1                 ;168
00004e  d1f1              BNE      |L4.52|
000050  e7ee              B        |L4.48|
;;;174    //**************************************************************************************************
                          ENDP


                          AREA ||i.pin_out_init||, CODE, READONLY, ALIGN=1

                  pin_out_init PROC
;;;116    
;;;117    static __inline void pin_out_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119        if(pin_bit >= 8)
;;;120        {
;;;121            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
000002  230f              MOVS     r3,#0xf
;;;122            GPIOx->CRH |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit-8) << 2) );
000004  2403              MOVS     r4,#3
000006  008a              LSLS     r2,r1,#2              ;121
000008  2908              CMP      r1,#8                 ;119
00000a  d309              BCC      |L5.32|
00000c  3a20              SUBS     r2,r2,#0x20           ;118
00000e  6841              LDR      r1,[r0,#4]            ;121
000010  4093              LSLS     r3,r3,r2              ;121
000012  4399              BICS     r1,r1,r3              ;121
000014  6041              STR      r1,[r0,#4]            ;121
000016  6841              LDR      r1,[r0,#4]
000018  4094              LSLS     r4,r4,r2
00001a  430c              ORRS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
;;;123        }
;;;124        else
;;;125        {
;;;126            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;127            GPIOx->CRL |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit) << 2) );
;;;128        }
;;;129    }
00001e  bd10              POP      {r4,pc}
                  |L5.32|
000020  6801              LDR      r1,[r0,#0]            ;126
000022  4093              LSLS     r3,r3,r2              ;126
000024  4399              BICS     r1,r1,r3              ;126
000026  6001              STR      r1,[r0,#0]            ;126
000028  6801              LDR      r1,[r0,#0]            ;127
00002a  4094              LSLS     r4,r4,r2              ;127
00002c  4321              ORRS     r1,r1,r4              ;127
00002e  6001              STR      r1,[r0,#0]            ;127
000030  bd10              POP      {r4,pc}
;;;130    
                          ENDP


                          AREA ||i.swd_clear_errors||, CODE, READONLY, ALIGN=1

                  swd_clear_errors PROC
;;;125    
;;;126    uint8_t swd_clear_errors(void)
000000  b510              PUSH     {r4,lr}
;;;127    {
;;;128        if (!swd_write_dp(DP_ABORT, STKCMPCLR | STKERRCLR | WDERRCLR | ORUNERRCLR)) {
000002  211e              MOVS     r1,#0x1e
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       swd_write_dp
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L6.16|
;;;129            return 0;
;;;130        }
;;;131        return 1;
00000e  2001              MOVS     r0,#1
                  |L6.16|
;;;132    }
000010  bd10              POP      {r4,pc}
;;;133    
                          ENDP


                          AREA ||i.swd_flash_syscall_exec||, CODE, READONLY, ALIGN=2

                  swd_flash_syscall_exec PROC
;;;686    
;;;687    uint8_t swd_flash_syscall_exec(const program_syscall_t *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;688    {
000004  b093              SUB      sp,sp,#0x4c
000006  460f              MOV      r7,r1
000008  e9dd891a          LDRD     r8,r9,[sp,#0x68]
00000c  4604              MOV      r4,r0
00000e  461e              MOV      r6,r3
000010  4615              MOV      r5,r2
;;;689        DEBUG_STATE state = {{0}, 0};
000012  2144              MOVS     r1,#0x44
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       __aeabi_memclr4
;;;690        // Call flash algorithm function on target and wait for result.
;;;691        state.r[0]     = arg1;                   // R0: Argument 1
;;;692        state.r[1]     = arg2;                   // R1: Argument 2
;;;693        state.r[2]     = arg3;                   // R2: Argument 3
;;;694        state.r[3]     = arg4;                   // R3: Argument 4
;;;695        state.r[9]     = sysCallParam->static_base;    // SB: Static Base
00001a  e88d0360          STM      sp,{r5,r6,r8,r9}
00001e  1d20              ADDS     r0,r4,#4
000020  f7fffffe          BL       __aeabi_uread4
;;;696        state.r[13]    = sysCallParam->stack_pointer;  // SP: Stack Pointer
000024  9009              STR      r0,[sp,#0x24]
000026  f1040008          ADD      r0,r4,#8
00002a  f7fffffe          BL       __aeabi_uread4
;;;697        state.r[14]    = sysCallParam->breakpoint;     // LR: Exit Point
00002e  900d              STR      r0,[sp,#0x34]
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       __aeabi_uread4
000036  e9cd070e          STRD     r0,r7,[sp,#0x38]
;;;698        state.r[15]    = entry;                        // PC: Entry Point
;;;699        state.xpsr     = 0x01000000;          // xPSR: T = 1, ISR = 0
00003a  f04f7080          MOV      r0,#0x1000000
;;;700    
;;;701        if (!swd_write_debug_state(&state)) {
00003e  9010              STR      r0,[sp,#0x40]
000040  4668              MOV      r0,sp
000042  f7fffffe          BL       swd_write_debug_state
000046  2800              CMP      r0,#0
000048  d019              BEQ      |L7.126|
00004a  4d11              LDR      r5,|L7.144|
00004c  4e11              LDR      r6,|L7.148|
00004e  2400              MOVS     r4,#0
                  |L7.80|
000050  a911              ADD      r1,sp,#0x44
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       swd_read_word
000058  b180              CBZ      r0,|L7.124|
00005a  9811              LDR      r0,[sp,#0x44]
00005c  0380              LSLS     r0,r0,#14
00005e  d511              BPL      |L7.132|
;;;702            return 0;
;;;703        }
;;;704    
;;;705        if (!swd_wait_until_halted()) {
;;;706            return 0;
;;;707        }
;;;708    
;;;709        if (!swd_read_core_register(0, &state.r[0])) {
000060  4669              MOV      r1,sp
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       swd_read_core_register
000068  2800              CMP      r0,#0
00006a  d008              BEQ      |L7.126|
;;;710            return 0;
;;;711        }
;;;712        
;;;713        //remove the C_MASKINTS
;;;714        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
00006c  490a              LDR      r1,|L7.152|
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       swd_write_word
000074  2800              CMP      r0,#0
000076  d002              BEQ      |L7.126|
;;;715            return 0;
;;;716        }
;;;717    
;;;718        // Flash functions return 0 if successful.
;;;719        if (state.r[0] != 0) {
000078  9800              LDR      r0,[sp,#0]
00007a  b138              CBZ      r0,|L7.140|
                  |L7.124|
;;;720            return 0;
00007c  2000              MOVS     r0,#0
                  |L7.126|
;;;721        }
;;;722    
;;;723        return 1;
;;;724    }
00007e  b013              ADD      sp,sp,#0x4c
000080  e8bd83f0          POP      {r4-r9,pc}
                  |L7.132|
000084  1c64              ADDS     r4,r4,#1
000086  42ac              CMP      r4,r5
000088  d3e2              BCC      |L7.80|
00008a  e7f7              B        |L7.124|
                  |L7.140|
00008c  2001              MOVS     r0,#1                 ;723
00008e  e7f6              B        |L7.126|
;;;725    
                          ENDP

                  |L7.144|
                          DCD      0x000f4240
                  |L7.148|
                          DCD      0xe000edf0
                  |L7.152|
                          DCD      0xa05f0003

                          AREA ||i.swd_get_apsel||, CODE, READONLY, ALIGN=1

                  swd_get_apsel PROC
;;;65     
;;;66     static uint32_t swd_get_apsel(uint32_t adr)
000000  b510              PUSH     {r4,lr}
;;;67     {
000002  4604              MOV      r4,r0
;;;68         uint32_t apsel = target_get_apsel();
000004  f7fffffe          BL       target_get_apsel
;;;69         if (!apsel)
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L8.16|
;;;70             return adr & 0xff000000;
00000c  f004407f          AND      r0,r4,#0xff000000
                  |L8.16|
;;;71         else
;;;72             return apsel;
;;;73     }
000010  bd10              POP      {r4,pc}
;;;74     
                          ENDP


                          AREA ||i.swd_init||, CODE, READONLY, ALIGN=1

                  swd_init PROC
;;;109    
;;;110    uint8_t swd_init(void)
000000  b510              PUSH     {r4,lr}
;;;111    {
;;;112        //TODO - DAP_Setup puts GPIO pins in a hi-z state which can
;;;113        //       cause problems on re-init.  This needs to be investigated
;;;114        //       and fixed.
;;;115        DAP_Setup();
000002  f7fffffe          BL       DAP_Setup
;;;116        PORT_SWD_SETUP();
000006  f7fffffe          BL       PORT_SWD_SETUP
;;;117        return 1;
00000a  2001              MOVS     r0,#1
;;;118    }
00000c  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.swd_init_debug||, CODE, READONLY, ALIGN=2

                  swd_init_debug PROC
;;;789    
;;;790    uint8_t swd_init_debug(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;791    {
;;;792        uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;793        int i = 0;
;;;794        int timeout = 100;
;;;795        // init dap state with fake values
;;;796        dap_state.select = 0xffffffff;
000006  1e41              SUBS     r1,r0,#1
000008  9000              STR      r0,[sp,#0]
00000a  4832              LDR      r0,|L10.212|
00000c  2664              MOVS     r6,#0x64              ;794
;;;797        dap_state.csw = 0xffffffff;
;;;798        
;;;799        int8_t retries = 4;
00000e  2704              MOVS     r7,#4
000010  6001              STR      r1,[r0,#0]            ;797  ; dap_state
;;;800        int8_t do_abort = 0;
000012  2400              MOVS     r4,#0
;;;801        do {
;;;802            if (do_abort) {
;;;803                //do an abort on stale target, then reset the device
;;;804                swd_write_dp(DP_ABORT, DAPABORT);
;;;805                swd_set_target_reset(1);
;;;806                osDelay(2);
;;;807                swd_set_target_reset(0);
;;;808                osDelay(2);
;;;809                do_abort = 0;
;;;810            }
;;;811            swd_init();
;;;812            // call a target dependant function
;;;813            // this function can do several stuff before really
;;;814            // initing the debug
;;;815            if (g_target_family && g_target_family->target_before_init_debug) {
000014  f8df80c0          LDR      r8,|L10.216|
000018  6041              STR      r1,[r0,#4]            ;791  ; dap_state
00001a  e011              B        |L10.64|
                  |L10.28|
00001c  b184              CBZ      r4,|L10.64|
00001e  2101              MOVS     r1,#1                 ;804
000020  2000              MOVS     r0,#0                 ;804
000022  f7fffffe          BL       swd_write_dp
000026  2001              MOVS     r0,#1                 ;805
000028  f7fffffe          BL       swd_set_target_reset
00002c  2002              MOVS     r0,#2                 ;806
00002e  f7fffffe          BL       osDelay
000032  2000              MOVS     r0,#0                 ;807
000034  f7fffffe          BL       swd_set_target_reset
000038  2002              MOVS     r0,#2                 ;808
00003a  f7fffffe          BL       osDelay
00003e  2400              MOVS     r4,#0                 ;809
                  |L10.64|
000040  f7fffffe          BL       swd_init
000044  f8d80000          LDR      r0,[r8,#0]  ; g_target_family
000048  b110              CBZ      r0,|L10.80|
00004a  6880              LDR      r0,[r0,#8]
00004c  b100              CBZ      r0,|L10.80|
;;;816                g_target_family->target_before_init_debug();
00004e  4780              BLX      r0
                  |L10.80|
;;;817            }
;;;818    
;;;819            if (!JTAG2SWD()) {
000050  f7fffffe          BL       JTAG2SWD
000054  b3a0              CBZ      r0,|L10.192|
;;;820                do_abort = 1;
;;;821                continue;
;;;822            }
;;;823    
;;;824            if (!swd_clear_errors()) {
000056  f7fffffe          BL       swd_clear_errors
00005a  b388              CBZ      r0,|L10.192|
;;;825                do_abort = 1;
;;;826                continue;
;;;827            }
;;;828    
;;;829            if (!swd_write_dp(DP_SELECT, 0)) {
00005c  2100              MOVS     r1,#0
00005e  2008              MOVS     r0,#8
000060  f7fffffe          BL       swd_write_dp
000064  b360              CBZ      r0,|L10.192|
;;;830                do_abort = 1;
;;;831                continue;
;;;832                
;;;833            }
;;;834            
;;;835            // Power up
;;;836            if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
000066  f04f41a0          MOV      r1,#0x50000000
00006a  2004              MOVS     r0,#4
00006c  f7fffffe          BL       swd_write_dp
000070  b330              CBZ      r0,|L10.192|
;;;837                do_abort = 1;
;;;838                continue;
;;;839            }
;;;840    
;;;841            for (i = 0; i < timeout; i++) {
000072  2500              MOVS     r5,#0
;;;842                if (!swd_read_dp(DP_CTRL_STAT, &tmp)) {
;;;843                    do_abort = 1;
;;;844                    break;
;;;845                }
;;;846                if ((tmp & (CDBGPWRUPACK | CSYSPWRUPACK)) == (CDBGPWRUPACK | CSYSPWRUPACK)) {
000074  f04f4920          MOV      r9,#0xa0000000
000078  e009              B        |L10.142|
                  |L10.122|
00007a  4669              MOV      r1,sp                 ;842
00007c  2004              MOVS     r0,#4                 ;842
00007e  f7fffffe          BL       swd_read_dp
000082  b1f0              CBZ      r0,|L10.194|
000084  9900              LDR      r1,[sp,#0]
000086  ea390001          BICS     r0,r9,r1
00008a  d002              BEQ      |L10.146|
00008c  1c6d              ADDS     r5,r5,#1
                  |L10.142|
00008e  42b5              CMP      r5,r6                 ;841
000090  dbf3              BLT      |L10.122|
                  |L10.146|
;;;847                    // Break from loop if powerup is complete
;;;848                    break;
;;;849                }
;;;850            }
;;;851            if ((i == timeout) || (do_abort == 1)) {
000092  42b5              CMP      r5,r6
000094  d017              BEQ      |L10.198|
000096  2c01              CMP      r4,#1
000098  d015              BEQ      |L10.198|
;;;852                // Unable to powerup DP
;;;853                do_abort = 1;
;;;854                continue;
;;;855            }
;;;856    
;;;857            if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE)) {
00009a  4910              LDR      r1,|L10.220|
00009c  2004              MOVS     r0,#4
00009e  f7fffffe          BL       swd_write_dp
0000a2  b168              CBZ      r0,|L10.192|
;;;858                do_abort = 1;
;;;859                continue;
;;;860            }
;;;861    
;;;862            // call a target dependant function:
;;;863            // some target can enter in a lock state
;;;864            // this function can unlock these targets
;;;865            if (g_target_family && g_target_family->target_unlock_sequence) {
0000a4  f8d80000          LDR      r0,[r8,#0]  ; g_target_family
0000a8  b110              CBZ      r0,|L10.176|
0000aa  6900              LDR      r0,[r0,#0x10]
0000ac  b100              CBZ      r0,|L10.176|
;;;866                g_target_family->target_unlock_sequence();
0000ae  4780              BLX      r0
                  |L10.176|
;;;867            }
;;;868    
;;;869            if (!swd_write_dp(DP_SELECT, 0)) {
0000b0  2100              MOVS     r1,#0
0000b2  2008              MOVS     r0,#8
0000b4  f7fffffe          BL       swd_write_dp
0000b8  b110              CBZ      r0,|L10.192|
;;;870                do_abort = 1;
;;;871                continue;
;;;872            }
;;;873            
;;;874            return 1;
0000ba  2001              MOVS     r0,#1
                  |L10.188|
;;;875        
;;;876        } while (--retries > 0);
;;;877        
;;;878        return 0;
;;;879    }
0000bc  e8bd83f8          POP      {r3-r9,pc}
                  |L10.192|
0000c0  e001              B        |L10.198|
                  |L10.194|
0000c2  2401              MOVS     r4,#1                 ;843
0000c4  e7e5              B        |L10.146|
                  |L10.198|
0000c6  1e7f              SUBS     r7,r7,#1              ;870
0000c8  2401              MOVS     r4,#1                 ;870
0000ca  b27f              SXTB     r7,r7                 ;876
0000cc  2f00              CMP      r7,#0                 ;876
0000ce  dca5              BGT      |L10.28|
0000d0  2000              MOVS     r0,#0                 ;878
0000d2  e7f3              B        |L10.188|
;;;880    
                          ENDP

                  |L10.212|
                          DCD      ||.data||+0x8
                  |L10.216|
                          DCD      g_target_family
                  |L10.220|
                          DCD      0x50000f00

                          AREA ||i.swd_off||, CODE, READONLY, ALIGN=2

                  swd_off PROC
;;;119    
;;;120    uint8_t swd_off(void)
000000  b510              PUSH     {r4,lr}
000002  4c09              LDR      r4,|L11.40|
000004  2200              MOVS     r2,#0
000006  210d              MOVS     r1,#0xd
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       pin_in_init
00000e  2200              MOVS     r2,#0
000010  210e              MOVS     r1,#0xe
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       pin_in_init
000018  2200              MOVS     r2,#0
00001a  210c              MOVS     r1,#0xc
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       pin_in_init
;;;121    {
;;;122        PORT_OFF();
;;;123        return 1;
000022  2001              MOVS     r0,#1
;;;124    }
000024  bd10              POP      {r4,pc}
;;;125    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      0x40010c00

                          AREA ||i.swd_read_ap||, CODE, READONLY, ALIGN=1

                  swd_read_ap PROC
;;;176    // Read access port register.
;;;177    uint8_t swd_read_ap(uint32_t adr, uint32_t *val)
000000  b538              PUSH     {r3-r5,lr}
;;;178    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;179        uint8_t tmp_in, ack;
;;;180        uint8_t tmp_out[4];
;;;181        uint32_t tmp;
;;;182        uint32_t apsel = swd_get_apsel(adr);
000006  f7fffffe          BL       swd_get_apsel
;;;183        uint32_t bank_sel = adr & APBANKSEL;
00000a  f00502f0          AND      r2,r5,#0xf0
;;;184    
;;;185        if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
00000e  ea400102          ORR      r1,r0,r2
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       swd_write_dp
000018  2800              CMP      r0,#0
00001a  d022              BEQ      |L12.98|
;;;186            return 0;
;;;187        }
;;;188    
;;;189        tmp_in = SWD_REG_AP | SWD_REG_R | SWD_REG_ADR(adr);
00001c  f005050c          AND      r5,r5,#0xc
;;;190        // first dummy read
;;;191        swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000020  1ced              ADDS     r5,r5,#3
000022  4669              MOV      r1,sp
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       swd_transfer_retry
;;;192        ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
00002a  4669              MOV      r1,sp
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       swd_transfer_retry
;;;193        *val = 0;
000032  2200              MOVS     r2,#0
;;;194        tmp = tmp_out[3];
000034  6022              STR      r2,[r4,#0]
000036  f89d1003          LDRB     r1,[sp,#3]
;;;195        *val |= (tmp << 24);
00003a  ea426101          ORR      r1,r2,r1,LSL #24
;;;196        tmp = tmp_out[2];
00003e  6021              STR      r1,[r4,#0]
000040  f89d2002          LDRB     r2,[sp,#2]
;;;197        *val |= (tmp << 16);
000044  ea414102          ORR      r1,r1,r2,LSL #16
;;;198        tmp = tmp_out[1];
000048  6021              STR      r1,[r4,#0]
00004a  f89d2001          LDRB     r2,[sp,#1]
;;;199        *val |= (tmp << 8);
00004e  ea412102          ORR      r1,r1,r2,LSL #8
;;;200        tmp = tmp_out[0];
000052  6021              STR      r1,[r4,#0]
000054  f89d2000          LDRB     r2,[sp,#0]
;;;201        *val |= (tmp << 0);
000058  4311              ORRS     r1,r1,r2
;;;202        return (ack == 0x01);
00005a  6021              STR      r1,[r4,#0]
00005c  2801              CMP      r0,#1
00005e  d000              BEQ      |L12.98|
000060  2000              MOVS     r0,#0
                  |L12.98|
;;;203    }
000062  bd38              POP      {r3-r5,pc}
;;;204    
                          ENDP


                          AREA ||i.swd_read_block||, CODE, READONLY, ALIGN=2

                  swd_read_block PROC
;;;288    // size is in bytes.
;;;289    static uint8_t swd_read_block(uint32_t address, uint8_t *data, uint32_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;290    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  b362              CBZ      r2,|L13.98|
;;;291        uint8_t tmp_in[4], req, ack;
;;;292        uint32_t size_in_words;
;;;293        uint32_t i;
;;;294    
;;;295        if (size == 0) {
;;;296            return 0;
;;;297        }
;;;298    
;;;299        size_in_words = size / 4;
000008  0896              LSRS     r6,r2,#2
;;;300    
;;;301        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
00000a  4917              LDR      r1,|L13.104|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       swd_write_ap
000012  2800              CMP      r0,#0
000014  d026              BEQ      |L13.100|
;;;302            return 0;
;;;303        }
;;;304    
;;;305        // TAR write
;;;306        req = SWD_REG_AP | SWD_REG_W | AP_TAR;
000016  2705              MOVS     r7,#5
;;;307        int2array(tmp_in, address, 4);
000018  2204              MOVS     r2,#4
00001a  4621              MOV      r1,r4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       int2array
;;;308    
;;;309        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != DAP_TRANSFER_OK) {
000022  4669              MOV      r1,sp
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       swd_transfer_retry
00002a  2801              CMP      r0,#1
00002c  d119              BNE      |L13.98|
;;;310            return 0;
;;;311        }
;;;312    
;;;313        // read data
;;;314        req = SWD_REG_AP | SWD_REG_R | AP_DRW;
00002e  270f              MOVS     r7,#0xf
;;;315    
;;;316        // initiate first read, data comes back in next read
;;;317        if (swd_transfer_retry(req, NULL) != 0x01) {
000030  2100              MOVS     r1,#0
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       swd_transfer_retry
000038  2801              CMP      r0,#1
00003a  d112              BNE      |L13.98|
;;;318            return 0;
;;;319        }
;;;320    
;;;321        for (i = 0; i < (size_in_words - 1); i++) {
00003c  2400              MOVS     r4,#0
00003e  1e76              SUBS     r6,r6,#1
000040  e007              B        |L13.82|
                  |L13.66|
;;;322            if (swd_transfer_retry(req, (uint32_t *)data) != DAP_TRANSFER_OK) {
000042  4629              MOV      r1,r5
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       swd_transfer_retry
00004a  2801              CMP      r0,#1
00004c  d109              BNE      |L13.98|
00004e  1c64              ADDS     r4,r4,#1
000050  1d2d              ADDS     r5,r5,#4
                  |L13.82|
000052  42b4              CMP      r4,r6                 ;321
000054  d3f5              BCC      |L13.66|
;;;323                return 0;
;;;324            }
;;;325    
;;;326            data += 4;
;;;327        }
;;;328    
;;;329        // read last word
;;;330        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000056  200e              MOVS     r0,#0xe
;;;331        ack = swd_transfer_retry(req, (uint32_t *)data);
000058  4629              MOV      r1,r5
00005a  f7fffffe          BL       swd_transfer_retry
;;;332        return (ack == 0x01);
00005e  2801              CMP      r0,#1
000060  d000              BEQ      |L13.100|
                  |L13.98|
000062  2000              MOVS     r0,#0
                  |L13.100|
;;;333    }
000064  bdf8              POP      {r3-r7,pc}
;;;334    
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      0x23000052

                          AREA ||i.swd_read_byte||, CODE, READONLY, ALIGN=2

                  swd_read_byte PROC
;;;427    // Read 8-bit byte from target memory.
;;;428    uint8_t swd_read_byte(uint32_t addr, uint8_t *val)
000000  b538              PUSH     {r3-r5,lr}
;;;429    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;430        uint32_t tmp;
;;;431    
;;;432        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
000006  4909              LDR      r1,|L14.44|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d00b              BEQ      |L14.42|
;;;433            return 0;
;;;434        }
;;;435    
;;;436        if (!swd_read_data(addr, &tmp)) {
000012  4669              MOV      r1,sp
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       swd_read_data
00001a  2800              CMP      r0,#0
00001c  d005              BEQ      |L14.42|
;;;437            return 0;
;;;438        }
;;;439    
;;;440        *val = (uint8_t)(tmp >> ((addr & 0x03) << 3));
00001e  07a0              LSLS     r0,r4,#30
000020  0ec1              LSRS     r1,r0,#27
000022  9800              LDR      r0,[sp,#0]
000024  40c8              LSRS     r0,r0,r1
000026  7028              STRB     r0,[r5,#0]
;;;441        return 1;
000028  2001              MOVS     r0,#1
                  |L14.42|
;;;442    }
00002a  bd38              POP      {r3-r5,pc}
;;;443    
                          ENDP

                  |L14.44|
                          DCD      0x23000050

                          AREA ||i.swd_read_core_register||, CODE, READONLY, ALIGN=2

                  swd_read_core_register PROC
;;;612    
;;;613    uint8_t swd_read_core_register(uint32_t n, uint32_t *val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;614    {
000004  460e              MOV      r6,r1
;;;615        int i = 0, timeout = 100;
;;;616    
;;;617        if (!swd_write_word(DCRSR, n)) {
000006  4601              MOV      r1,r0
000008  2400              MOVS     r4,#0                 ;615
00000a  2564              MOVS     r5,#0x64              ;615
00000c  4810              LDR      r0,|L15.80|
00000e  f7fffffe          BL       swd_write_word
000012  2800              CMP      r0,#0
000014  d010              BEQ      |L15.56|
;;;618            return 0;
;;;619        }
;;;620    
;;;621        // wait for S_REGRDY
;;;622        for (i = 0; i < timeout; i++) {
;;;623            if (!swd_read_word(DHCSR, val)) {
000016  4f0e              LDR      r7,|L15.80|
000018  1f3f              SUBS     r7,r7,#4
                  |L15.26|
00001a  4631              MOV      r1,r6
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       swd_read_word
000022  2800              CMP      r0,#0
000024  d008              BEQ      |L15.56|
;;;624                return 0;
;;;625            }
;;;626    
;;;627            if (*val & S_REGRDY) {
000026  6830              LDR      r0,[r6,#0]
000028  03c0              LSLS     r0,r0,#15
00002a  d402              BMI      |L15.50|
00002c  1c64              ADDS     r4,r4,#1
00002e  42ac              CMP      r4,r5                 ;622
000030  dbf3              BLT      |L15.26|
                  |L15.50|
;;;628                break;
;;;629            }
;;;630        }
;;;631    
;;;632        if (i == timeout) {
000032  42ac              CMP      r4,r5
000034  d102              BNE      |L15.60|
;;;633            return 0;
000036  2000              MOVS     r0,#0
                  |L15.56|
;;;634        }
;;;635    
;;;636        if (!swd_read_word(DCRDR, val)) {
;;;637            return 0;
;;;638        }
;;;639    
;;;640        return 1;
;;;641    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L15.60|
00003c  4804              LDR      r0,|L15.80|
00003e  4631              MOV      r1,r6                 ;636
000040  1d00              ADDS     r0,r0,#4              ;636
000042  f7fffffe          BL       swd_read_word
000046  2800              CMP      r0,#0                 ;636
000048  d0f6              BEQ      |L15.56|
00004a  2001              MOVS     r0,#1                 ;640
00004c  e7f4              B        |L15.56|
;;;642    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      0xe000edf4

                          AREA ||i.swd_read_data||, CODE, READONLY, ALIGN=1

                  swd_read_data PROC
;;;335    // Read target memory.
;;;336    static uint8_t swd_read_data(uint32_t addr, uint32_t *val)
000000  b51c              PUSH     {r2-r4,lr}
;;;337    {
000002  460c              MOV      r4,r1
;;;338        uint8_t tmp_in[4];
;;;339        uint8_t tmp_out[4];
;;;340        uint8_t req, ack;
;;;341        uint32_t tmp;
;;;342        // put addr in TAR register
;;;343        int2array(tmp_in, addr, 4);
000004  4601              MOV      r1,r0
000006  2204              MOVS     r2,#4
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       int2array
;;;344        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00000e  2005              MOVS     r0,#5
;;;345    
;;;346        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000010  a901              ADD      r1,sp,#4
000012  f7fffffe          BL       swd_transfer_retry
000016  2801              CMP      r0,#1
000018  d120              BNE      |L16.92|
;;;347            return 0;
;;;348        }
;;;349    
;;;350        // read data
;;;351        req = SWD_REG_AP | SWD_REG_R | (3 << 2);
00001a  200f              MOVS     r0,#0xf
;;;352    
;;;353        if (swd_transfer_retry(req, (uint32_t *)tmp_out) != 0x01) {
00001c  4669              MOV      r1,sp
00001e  f7fffffe          BL       swd_transfer_retry
000022  2801              CMP      r0,#1
000024  d11a              BNE      |L16.92|
;;;354            return 0;
;;;355        }
;;;356    
;;;357        // dummy read
;;;358        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000026  200e              MOVS     r0,#0xe
;;;359        ack = swd_transfer_retry(req, (uint32_t *)tmp_out);
000028  4669              MOV      r1,sp
00002a  f7fffffe          BL       swd_transfer_retry
;;;360        *val = 0;
00002e  2200              MOVS     r2,#0
;;;361        tmp = tmp_out[3];
000030  6022              STR      r2,[r4,#0]
000032  f89d1003          LDRB     r1,[sp,#3]
;;;362        *val |= (tmp << 24);
000036  ea426101          ORR      r1,r2,r1,LSL #24
;;;363        tmp = tmp_out[2];
00003a  6021              STR      r1,[r4,#0]
00003c  f89d2002          LDRB     r2,[sp,#2]
;;;364        *val |= (tmp << 16);
000040  ea414102          ORR      r1,r1,r2,LSL #16
;;;365        tmp = tmp_out[1];
000044  6021              STR      r1,[r4,#0]
000046  f89d2001          LDRB     r2,[sp,#1]
;;;366        *val |= (tmp << 8);
00004a  ea412102          ORR      r1,r1,r2,LSL #8
;;;367        tmp = tmp_out[0];
00004e  6021              STR      r1,[r4,#0]
000050  f89d2000          LDRB     r2,[sp,#0]
;;;368        *val |= (tmp << 0);
000054  4311              ORRS     r1,r1,r2
;;;369        return (ack == 0x01);
000056  6021              STR      r1,[r4,#0]
000058  2801              CMP      r0,#1
00005a  d000              BEQ      |L16.94|
                  |L16.92|
00005c  2000              MOVS     r0,#0
                  |L16.94|
;;;370    }
00005e  bd1c              POP      {r2-r4,pc}
;;;371    
                          ENDP


                          AREA ||i.swd_read_dp||, CODE, READONLY, ALIGN=1

                  swd_read_dp PROC
;;;134    // Read debug port register.
;;;135    uint8_t swd_read_dp(uint8_t adr, uint32_t *val)
000000  b538              PUSH     {r3-r5,lr}
;;;136    {
000002  460c              MOV      r4,r1
;;;137        uint32_t tmp_in;
;;;138        uint8_t tmp_out[4];
;;;139        uint8_t ack;
;;;140        uint32_t tmp;
;;;141        tmp_in = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(adr);
000004  f000000c          AND      r0,r0,#0xc
;;;142        ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000008  4669              MOV      r1,sp
00000a  1c80              ADDS     r0,r0,#2
00000c  f7fffffe          BL       swd_transfer_retry
;;;143        *val = 0;
000010  2200              MOVS     r2,#0
;;;144        tmp = tmp_out[3];
000012  6022              STR      r2,[r4,#0]
000014  f89d1003          LDRB     r1,[sp,#3]
;;;145        *val |= (tmp << 24);
000018  ea426101          ORR      r1,r2,r1,LSL #24
;;;146        tmp = tmp_out[2];
00001c  6021              STR      r1,[r4,#0]
00001e  f89d2002          LDRB     r2,[sp,#2]
;;;147        *val |= (tmp << 16);
000022  ea414102          ORR      r1,r1,r2,LSL #16
;;;148        tmp = tmp_out[1];
000026  6021              STR      r1,[r4,#0]
000028  f89d2001          LDRB     r2,[sp,#1]
;;;149        *val |= (tmp << 8);
00002c  ea412102          ORR      r1,r1,r2,LSL #8
;;;150        tmp = tmp_out[0];
000030  6021              STR      r1,[r4,#0]
000032  f89d2000          LDRB     r2,[sp,#0]
;;;151        *val |= (tmp << 0);
000036  4311              ORRS     r1,r1,r2
;;;152        return (ack == 0x01);
000038  6021              STR      r1,[r4,#0]
00003a  2801              CMP      r0,#1
00003c  d000              BEQ      |L17.64|
00003e  2000              MOVS     r0,#0
                  |L17.64|
;;;153    }
000040  bd38              POP      {r3-r5,pc}
;;;154    
                          ENDP


                          AREA ||i.swd_read_memory||, CODE, READONLY, ALIGN=1

                  swd_read_memory PROC
;;;463    // size is in bytes.
;;;464    uint8_t swd_read_memory(uint32_t address, uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;465    {
000004  4614              MOV      r4,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;466        uint32_t n;
;;;467    
;;;468        // Read bytes until word aligned
;;;469        while ((size > 0) && (address & 0x3)) {
;;;470            if (!swd_read_byte(address, data)) {
;;;471                return 0;
;;;472            }
;;;473    
;;;474            address++;
;;;475            data++;
;;;476            size--;
00000a  e008              B        |L18.30|
                  |L18.12|
00000c  4639              MOV      r1,r7                 ;470
00000e  4628              MOV      r0,r5                 ;470
000010  f7fffffe          BL       swd_read_byte
000014  2800              CMP      r0,#0                 ;470
000016  d027              BEQ      |L18.104|
000018  1e64              SUBS     r4,r4,#1              ;470
00001a  1c6d              ADDS     r5,r5,#1              ;470
00001c  1c7f              ADDS     r7,r7,#1              ;470
                  |L18.30|
00001e  b314              CBZ      r4,|L18.102|
000020  07a8              LSLS     r0,r5,#30             ;469
000022  d1f3              BNE      |L18.12|
000024  e011              B        |L18.74|
                  |L18.38|
;;;477        }
;;;478    
;;;479        // Read word aligned blocks
;;;480        while (size > 3) {
;;;481            // Limit to auto increment page size
;;;482            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000026  f3c50009          UBFX     r0,r5,#0,#10
00002a  f5c06680          RSB      r6,r0,#0x400
;;;483    
;;;484            if (size < n) {
00002e  42b4              CMP      r4,r6
000030  d201              BCS      |L18.54|
;;;485                n = size & 0xFFFFFFFC; // Only count complete words remaining
000032  f0240603          BIC      r6,r4,#3
                  |L18.54|
;;;486            }
;;;487    
;;;488            if (!swd_read_block(address, data, n)) {
000036  4632              MOV      r2,r6
000038  4639              MOV      r1,r7
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       swd_read_block
000040  2800              CMP      r0,#0
000042  d011              BEQ      |L18.104|
;;;489                return 0;
;;;490            }
;;;491    
;;;492            address += n;
000044  4435              ADD      r5,r5,r6
;;;493            data += n;
000046  4437              ADD      r7,r7,r6
;;;494            size -= n;
000048  1ba4              SUBS     r4,r4,r6
                  |L18.74|
00004a  2c03              CMP      r4,#3                 ;480
00004c  d8eb              BHI      |L18.38|
00004e  e008              B        |L18.98|
                  |L18.80|
;;;495        }
;;;496    
;;;497        // Read remaining bytes
;;;498        while (size > 0) {
;;;499            if (!swd_read_byte(address, data)) {
000050  4639              MOV      r1,r7
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       swd_read_byte
000058  2800              CMP      r0,#0
00005a  d005              BEQ      |L18.104|
00005c  1e64              SUBS     r4,r4,#1
00005e  1c6d              ADDS     r5,r5,#1
000060  1c7f              ADDS     r7,r7,#1
                  |L18.98|
000062  2c00              CMP      r4,#0                 ;498
000064  d1f4              BNE      |L18.80|
                  |L18.102|
;;;500                return 0;
;;;501            }
;;;502    
;;;503            address++;
;;;504            data++;
;;;505            size--;
;;;506        }
;;;507    
;;;508        return 1;
000066  2001              MOVS     r0,#1
                  |L18.104|
;;;509    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;510    
                          ENDP


                          AREA ||i.swd_read_word||, CODE, READONLY, ALIGN=2

                  swd_read_word PROC
;;;399    // Read 32-bit word from target memory.
;;;400    uint8_t swd_read_word(uint32_t addr, uint32_t *val)
000000  b570              PUSH     {r4-r6,lr}
;;;401    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;402        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
000006  4907              LDR      r1,|L19.36|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d006              BEQ      |L19.32|
;;;403            return 0;
;;;404        }
;;;405    
;;;406        if (!swd_read_data(addr, val)) {
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       swd_read_data
00001a  2800              CMP      r0,#0
00001c  d000              BEQ      |L19.32|
;;;407            return 0;
;;;408        }
;;;409    
;;;410        return 1;
00001e  2001              MOVS     r0,#1
                  |L19.32|
;;;411    }
000020  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      0x23000052

                          AREA ||i.swd_reset||, CODE, READONLY, ALIGN=1

                  swd_reset PROC
;;;726    // SWD Reset
;;;727    static uint8_t swd_reset(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;728    {
;;;729        uint8_t tmp_in[8];
;;;730        uint8_t i = 0;
000002  2000              MOVS     r0,#0
000004  466a              MOV      r2,sp                 ;729
;;;731    
;;;732        for (i = 0; i < 8; i++) {
;;;733            tmp_in[i] = 0xff;
000006  21ff              MOVS     r1,#0xff
                  |L20.8|
000008  5411              STRB     r1,[r2,r0]
00000a  1c40              ADDS     r0,r0,#1
00000c  b2c0              UXTB     r0,r0                 ;732
00000e  2808              CMP      r0,#8                 ;732
000010  d3fa              BCC      |L20.8|
;;;734        }
;;;735    
;;;736        SWJ_Sequence(51, tmp_in);
000012  4611              MOV      r1,r2
000014  2033              MOVS     r0,#0x33
000016  f7fffffe          BL       SWJ_Sequence
;;;737        return 1;
00001a  2001              MOVS     r0,#1
;;;738    }
00001c  bd1c              POP      {r2-r4,pc}
;;;739    
                          ENDP


                          AREA ||i.swd_set_reset_connect||, CODE, READONLY, ALIGN=2

                  swd_set_reset_connect PROC
;;;74     
;;;75     void swd_set_reset_connect(SWD_CONNECT_TYPE type)
000000  4901              LDR      r1,|L21.8|
;;;76     {
;;;77         reset_connect = type;
000002  7008              STRB     r0,[r1,#0]
;;;78     }
000004  4770              BX       lr
;;;79     
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      ||.data||

                          AREA ||i.swd_set_soft_reset||, CODE, READONLY, ALIGN=2

                  swd_set_soft_reset PROC
;;;104    
;;;105    void swd_set_soft_reset(uint32_t soft_reset_type)
000000  4901              LDR      r1,|L22.8|
;;;106    {
;;;107        soft_reset = soft_reset_type;
000002  6048              STR      r0,[r1,#4]  ; soft_reset
;;;108    }
000004  4770              BX       lr
;;;109    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||.data||

                          AREA ||i.swd_set_target_state_hw||, CODE, READONLY, ALIGN=2

                  swd_set_target_state_hw PROC
;;;880    
;;;881    uint8_t swd_set_target_state_hw(TARGET_RESET_STATE state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;882    {
;;;883        uint32_t val;
;;;884        int8_t ap_retries = 2;
000002  2402              MOVS     r4,#2
000004  4606              MOV      r6,r0                 ;882
;;;885        /* Calling swd_init prior to entering RUN state causes operations to fail. */
;;;886        if (state != RUN) {
000006  2806              CMP      r0,#6
000008  d001              BEQ      |L23.14|
;;;887            swd_init();
00000a  f7fffffe          BL       swd_init
                  |L23.14|
;;;888        }
;;;889    
;;;890        switch (state) {
;;;891            case RESET_HOLD:
;;;892                swd_set_target_reset(1);
;;;893                break;
;;;894    
;;;895            case RESET_RUN:
;;;896                swd_set_target_reset(1);
;;;897                osDelay(2);
;;;898                swd_set_target_reset(0);
;;;899                osDelay(2);
;;;900                swd_off();
;;;901                break;
;;;902    
;;;903            case RESET_PROGRAM:
;;;904                if (!swd_init_debug()) {
;;;905                    return 0;
;;;906                }
;;;907                
;;;908                if (reset_connect == CONNECT_UNDER_RESET) {
;;;909                    // Assert reset
;;;910                    swd_set_target_reset(1); 
;;;911                    osDelay(2);
;;;912                }
;;;913    
;;;914                // Enable debug
;;;915                while(swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN) == 0) {
;;;916                    if( --ap_retries <=0 )
;;;917                        return 0;
;;;918                    // Target is in invalid state?
;;;919                    swd_set_target_reset(1);
;;;920                    osDelay(2);
;;;921                    swd_set_target_reset(0);
;;;922                    osDelay(2);
;;;923                }
;;;924    
;;;925                // Enable halt on reset
;;;926                if (!swd_write_word(DBG_EMCR, VC_CORERESET)) {
;;;927                    return 0;
;;;928                }
;;;929                
;;;930                if (reset_connect == CONNECT_NORMAL) {
;;;931                    // Assert reset
;;;932                    swd_set_target_reset(1); 
;;;933                    osDelay(2);
;;;934                }
;;;935                
;;;936                // Deassert reset
;;;937                swd_set_target_reset(0);
;;;938                osDelay(2);
;;;939                
;;;940                do {
;;;941                    if (!swd_read_word(DBG_HCSR, &val)) {
;;;942                        return 0;
;;;943                    }
;;;944                } while ((val & S_HALT) == 0);
;;;945    
;;;946                // Disable halt on reset
;;;947                if (!swd_write_word(DBG_EMCR, 0)) {
;;;948                    return 0;
;;;949                }
;;;950    
;;;951                break;
;;;952    
;;;953            case NO_DEBUG:
;;;954                if (!swd_write_word(DBG_HCSR, DBGKEY)) {
00000e  494e              LDR      r1,|L23.328|
000010  4d4e              LDR      r5,|L23.332|
000012  1c4f              ADDS     r7,r1,#1              ;915
000014  2e08              CMP      r6,#8                 ;890
000016  d274              BCS      |L23.258|
000018  e8dff006          TBB      [pc,r6]               ;890
00001c  0415085a          DCB      0x04,0x15,0x08,0x5a
000020  5c748a91          DCB      0x5c,0x74,0x8a,0x91
000024  2001              MOVS     r0,#1                 ;892
000026  f7fffffe          BL       swd_set_target_reset
00002a  e088              B        |L23.318|
00002c  2001              MOVS     r0,#1                 ;896
00002e  f7fffffe          BL       swd_set_target_reset
000032  2002              MOVS     r0,#2                 ;897
000034  f7fffffe          BL       osDelay
000038  2000              MOVS     r0,#0                 ;898
00003a  f7fffffe          BL       swd_set_target_reset
00003e  2002              MOVS     r0,#2                 ;899
000040  f7fffffe          BL       osDelay
000044  e079              B        |L23.314|
000046  f7fffffe          BL       swd_init_debug
00004a  2800              CMP      r0,#0                 ;904
00004c  d078              BEQ      |L23.320|
00004e  4e40              LDR      r6,|L23.336|
000050  7830              LDRB     r0,[r6,#0]            ;908  ; reset_connect
000052  2801              CMP      r0,#1                 ;908
000054  d00b              BEQ      |L23.110|
000056  e00f              B        |L23.120|
                  |L23.88|
000058  1e64              SUBS     r4,r4,#1              ;908
00005a  b264              SXTB     r4,r4                 ;916
00005c  2c00              CMP      r4,#0                 ;916
00005e  dd70              BLE      |L23.322|
000060  2001              MOVS     r0,#1                 ;919
000062  f7fffffe          BL       swd_set_target_reset
000066  2002              MOVS     r0,#2                 ;920
000068  f7fffffe          BL       osDelay
00006c  2000              MOVS     r0,#0                 ;921
                  |L23.110|
00006e  f7fffffe          BL       swd_set_target_reset
000072  2002              MOVS     r0,#2                 ;911
000074  f7fffffe          BL       osDelay
                  |L23.120|
000078  4639              MOV      r1,r7                 ;915
00007a  4628              MOV      r0,r5                 ;915
00007c  f7fffffe          BL       swd_write_word
000080  2800              CMP      r0,#0                 ;915
000082  d0e9              BEQ      |L23.88|
000084  4c31              LDR      r4,|L23.332|
000086  2101              MOVS     r1,#1                 ;926
000088  340c              ADDS     r4,r4,#0xc            ;926
00008a  4620              MOV      r0,r4                 ;926
00008c  f7fffffe          BL       swd_write_word
000090  2800              CMP      r0,#0                 ;926
000092  d055              BEQ      |L23.320|
000094  7830              LDRB     r0,[r6,#0]            ;930  ; reset_connect
000096  b928              CBNZ     r0,|L23.164|
000098  2001              MOVS     r0,#1                 ;932
00009a  f7fffffe          BL       swd_set_target_reset
00009e  2002              MOVS     r0,#2                 ;933
0000a0  f7fffffe          BL       osDelay
                  |L23.164|
0000a4  2000              MOVS     r0,#0                 ;937
0000a6  f7fffffe          BL       swd_set_target_reset
0000aa  2002              MOVS     r0,#2                 ;938
0000ac  f7fffffe          BL       osDelay
                  |L23.176|
0000b0  4669              MOV      r1,sp                 ;941
0000b2  4628              MOV      r0,r5                 ;941
0000b4  f7fffffe          BL       swd_read_word
0000b8  2800              CMP      r0,#0                 ;941
0000ba  d041              BEQ      |L23.320|
0000bc  9800              LDR      r0,[sp,#0]            ;944
0000be  0380              LSLS     r0,r0,#14             ;944
0000c0  d5f6              BPL      |L23.176|
0000c2  2100              MOVS     r1,#0                 ;947
0000c4  4620              MOV      r0,r4                 ;947
                  |L23.198|
0000c6  f7fffffe          BL       swd_write_word
0000ca  2800              CMP      r0,#0
0000cc  d038              BEQ      |L23.320|
0000ce  e036              B        |L23.318|
                  |L23.208|
0000d0  4628              MOV      r0,r5
0000d2  e7f8              B        |L23.198|
;;;955                    return 0;
;;;956                }
;;;957    
;;;958                break;
;;;959    
;;;960            case DEBUG:
;;;961                if (!JTAG2SWD()) {
0000d4  f7fffffe          BL       JTAG2SWD
0000d8  2800              CMP      r0,#0
0000da  d031              BEQ      |L23.320|
;;;962                    return 0;
;;;963                }
;;;964    
;;;965                if (!swd_clear_errors()) {
0000dc  f7fffffe          BL       swd_clear_errors
0000e0  2800              CMP      r0,#0
0000e2  d02d              BEQ      |L23.320|
;;;966                    return 0;
;;;967                }
;;;968    
;;;969                // Ensure CTRL/STAT register selected in DPBANKSEL
;;;970                if (!swd_write_dp(DP_SELECT, 0)) {
0000e4  2100              MOVS     r1,#0
0000e6  2008              MOVS     r0,#8
0000e8  f7fffffe          BL       swd_write_dp
0000ec  2800              CMP      r0,#0
0000ee  d027              BEQ      |L23.320|
;;;971                    return 0;
;;;972                }
;;;973    
;;;974                // Power up
;;;975                if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
0000f0  f04f41a0          MOV      r1,#0x50000000
0000f4  2004              MOVS     r0,#4
0000f6  f7fffffe          BL       swd_write_dp
0000fa  2800              CMP      r0,#0
0000fc  d020              BEQ      |L23.320|
;;;976                    return 0;
;;;977                }
;;;978    
;;;979                // Enable debug
;;;980                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
0000fe  4639              MOV      r1,r7
000100  e7e6              B        |L23.208|
                  |L23.258|
000102  e01e              B        |L23.322|
;;;981                    return 0;
;;;982                }
;;;983    
;;;984                break;
;;;985    
;;;986            case HALT:
;;;987                if (!swd_init_debug()) {
000104  f7fffffe          BL       swd_init_debug
000108  2800              CMP      r0,#0
00010a  d019              BEQ      |L23.320|
;;;988                    return 0;
;;;989                }
;;;990    
;;;991                // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;992                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
00010c  490e              LDR      r1,|L23.328|
00010e  4628              MOV      r0,r5
000110  1cc9              ADDS     r1,r1,#3
000112  f7fffffe          BL       swd_write_word
000116  2800              CMP      r0,#0
000118  d012              BEQ      |L23.320|
                  |L23.282|
;;;993                    return 0;
;;;994                }
;;;995    
;;;996                // Wait until core is halted
;;;997                do {
;;;998                    if (!swd_read_word(DBG_HCSR, &val)) {
00011a  4669              MOV      r1,sp
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       swd_read_word
000122  2800              CMP      r0,#0
000124  d00c              BEQ      |L23.320|
;;;999                        return 0;
;;;1000                   }
;;;1001               } while ((val & S_HALT) == 0);
000126  9800              LDR      r0,[sp,#0]
000128  0380              LSLS     r0,r0,#14
00012a  d5f6              BPL      |L23.282|
00012c  e007              B        |L23.318|
00012e  e007              B        |L23.320|
;;;1002               break;
;;;1003   
;;;1004           case RUN:
;;;1005               if (!swd_write_word(DBG_HCSR, DBGKEY)) {
000130  4628              MOV      r0,r5
000132  f7fffffe          BL       swd_write_word
000136  2800              CMP      r0,#0
000138  d002              BEQ      |L23.320|
                  |L23.314|
;;;1006                   return 0;
;;;1007               }
;;;1008               swd_off();
00013a  f7fffffe          BL       swd_off
                  |L23.318|
;;;1009               break;
;;;1010   
;;;1011           case POST_FLASH_RESET:
;;;1012               // This state should be handled in target_reset.c, nothing needs to be done here.
;;;1013               break;
;;;1014   
;;;1015           default:
;;;1016               return 0;
;;;1017       }
;;;1018   
;;;1019       return 1;
00013e  2001              MOVS     r0,#1
                  |L23.320|
;;;1020   }
000140  bdf8              POP      {r3-r7,pc}
                  |L23.322|
000142  2000              MOVS     r0,#0                 ;1016
000144  bdf8              POP      {r3-r7,pc}
;;;1021   
                          ENDP

000146  0000              DCW      0x0000
                  |L23.328|
                          DCD      0xa05f0000
                  |L23.332|
                          DCD      0xe000edf0
                  |L23.336|
                          DCD      ||.data||

                          AREA ||i.swd_set_target_state_sw||, CODE, READONLY, ALIGN=2

                  swd_set_target_state_sw PROC
;;;1021   
;;;1022   uint8_t swd_set_target_state_sw(TARGET_RESET_STATE state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1023   {
;;;1024       uint32_t val;
;;;1025       int8_t ap_retries = 2;
000002  2402              MOVS     r4,#2
000004  4605              MOV      r5,r0                 ;1023
;;;1026       /* Calling swd_init prior to enterring RUN state causes operations to fail. */
;;;1027       if (state != RUN) {
000006  2806              CMP      r0,#6
000008  d001              BEQ      |L24.14|
;;;1028           swd_init();
00000a  f7fffffe          BL       swd_init
                  |L24.14|
;;;1029       }
;;;1030   
;;;1031       switch (state) {
;;;1032           case RESET_HOLD:
;;;1033               swd_set_target_reset(1);
;;;1034               break;
;;;1035   
;;;1036           case RESET_RUN:
;;;1037               swd_set_target_reset(1);
;;;1038               osDelay(2);
;;;1039               swd_set_target_reset(0);
;;;1040               osDelay(2);
;;;1041               swd_off();
;;;1042               break;
;;;1043   
;;;1044           case RESET_PROGRAM:
;;;1045               if (!swd_init_debug()) {
;;;1046                   return 0;
;;;1047               }
;;;1048   
;;;1049               // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;1050               while (swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT) == 0) {
;;;1051                   if ( --ap_retries <=0 ) {
;;;1052                       return 0;
;;;1053                   }
;;;1054                   // Target is in invalid state?
;;;1055                   swd_set_target_reset(1);
;;;1056                   osDelay(2);
;;;1057                   swd_set_target_reset(0);
;;;1058                   osDelay(2);
;;;1059               }
;;;1060   
;;;1061               // Wait until core is halted
;;;1062               do {
;;;1063                   if (!swd_read_word(DBG_HCSR, &val)) {
;;;1064                       return 0;
;;;1065                   }
;;;1066               } while ((val & S_HALT) == 0);
;;;1067   
;;;1068               // Enable halt on reset
;;;1069               if (!swd_write_word(DBG_EMCR, VC_CORERESET)) {
;;;1070                   return 0;
;;;1071               }
;;;1072   
;;;1073               // Perform a soft reset
;;;1074               if (!swd_read_word(NVIC_AIRCR, &val)) {
;;;1075                   return 0;
;;;1076               }
;;;1077   
;;;1078               if (!swd_write_word(NVIC_AIRCR, VECTKEY | (val & SCB_AIRCR_PRIGROUP_Msk) | soft_reset)) {
;;;1079                   return 0;
;;;1080               }
;;;1081   
;;;1082               osDelay(2);
;;;1083   
;;;1084               do {
;;;1085                   if (!swd_read_word(DBG_HCSR, &val)) {
;;;1086                       return 0;
;;;1087                   }
;;;1088               } while ((val & S_HALT) == 0);
;;;1089   
;;;1090               // Disable halt on reset
;;;1091               if (!swd_write_word(DBG_EMCR, 0)) {
;;;1092                   return 0;
;;;1093               }
;;;1094   
;;;1095               break;
;;;1096   
;;;1097           case NO_DEBUG:
;;;1098               if (!swd_write_word(DBG_HCSR, DBGKEY)) {
00000e  4957              LDR      r1,|L24.364|
000010  462a              MOV      r2,r5                 ;1031
000012  1cce              ADDS     r6,r1,#3              ;1050
000014  4d56              LDR      r5,|L24.368|
000016  2a08              CMP      r2,#8                 ;1031
000018  d27e              BCS      |L24.280|
00001a  e8dff002          TBB      [pc,r2]               ;1031
00001e  0415              DCB      0x04,0x15
000020  08696b85          DCB      0x08,0x69,0x6b,0x85
000024  9ba2              DCB      0x9b,0xa2
000026  2001              MOVS     r0,#1                 ;1033
000028  f7fffffe          BL       swd_set_target_reset
00002c  e099              B        |L24.354|
00002e  2001              MOVS     r0,#1                 ;1037
000030  f7fffffe          BL       swd_set_target_reset
000034  2002              MOVS     r0,#2                 ;1038
000036  f7fffffe          BL       osDelay
00003a  2000              MOVS     r0,#0                 ;1039
00003c  f7fffffe          BL       swd_set_target_reset
000040  2002              MOVS     r0,#2                 ;1040
000042  f7fffffe          BL       osDelay
000046  e08a              B        |L24.350|
000048  f7fffffe          BL       swd_init_debug
00004c  2800              CMP      r0,#0                 ;1045
00004e  d07d              BEQ      |L24.332|
000050  e00f              B        |L24.114|
                  |L24.82|
000052  1e64              SUBS     r4,r4,#1              ;1045
000054  b264              SXTB     r4,r4                 ;1051
000056  2c00              CMP      r4,#0                 ;1051
000058  dd5e              BLE      |L24.280|
00005a  2001              MOVS     r0,#1                 ;1055
00005c  f7fffffe          BL       swd_set_target_reset
000060  2002              MOVS     r0,#2                 ;1056
000062  f7fffffe          BL       osDelay
000066  2000              MOVS     r0,#0                 ;1057
000068  f7fffffe          BL       swd_set_target_reset
00006c  2002              MOVS     r0,#2                 ;1058
00006e  f7fffffe          BL       osDelay
                  |L24.114|
000072  4631              MOV      r1,r6                 ;1050
000074  4628              MOV      r0,r5                 ;1050
000076  f7fffffe          BL       swd_write_word
00007a  2800              CMP      r0,#0                 ;1050
00007c  d0e9              BEQ      |L24.82|
                  |L24.126|
00007e  4669              MOV      r1,sp                 ;1063
000080  4628              MOV      r0,r5                 ;1063
000082  f7fffffe          BL       swd_read_word
000086  2800              CMP      r0,#0                 ;1063
000088  d06c              BEQ      |L24.356|
00008a  9800              LDR      r0,[sp,#0]            ;1066
00008c  0380              LSLS     r0,r0,#14             ;1066
00008e  d5f6              BPL      |L24.126|
000090  4c37              LDR      r4,|L24.368|
000092  2101              MOVS     r1,#1                 ;1069
000094  340c              ADDS     r4,r4,#0xc            ;1069
000096  4620              MOV      r0,r4                 ;1069
000098  f7fffffe          BL       swd_write_word
00009c  2800              CMP      r0,#0                 ;1069
00009e  d061              BEQ      |L24.356|
0000a0  4e33              LDR      r6,|L24.368|
0000a2  4669              MOV      r1,sp                 ;1074
0000a4  3ee4              SUBS     r6,r6,#0xe4           ;1074
0000a6  4630              MOV      r0,r6                 ;1074
0000a8  f7fffffe          BL       swd_read_word
0000ac  2800              CMP      r0,#0                 ;1074
0000ae  d059              BEQ      |L24.356|
0000b0  9800              LDR      r0,[sp,#0]            ;1078
0000b2  f40061e0          AND      r1,r0,#0x700          ;1078
0000b6  482f              LDR      r0,|L24.372|
0000b8  6840              LDR      r0,[r0,#4]            ;1078  ; soft_reset
0000ba  4301              ORRS     r1,r1,r0              ;1078
0000bc  482e              LDR      r0,|L24.376|
0000be  4301              ORRS     r1,r1,r0              ;1078
0000c0  4630              MOV      r0,r6                 ;1078
0000c2  f7fffffe          BL       swd_write_word
0000c6  2800              CMP      r0,#0                 ;1078
0000c8  d04c              BEQ      |L24.356|
0000ca  2002              MOVS     r0,#2                 ;1082
0000cc  f7fffffe          BL       osDelay
                  |L24.208|
0000d0  4669              MOV      r1,sp                 ;1085
0000d2  4628              MOV      r0,r5                 ;1085
0000d4  f7fffffe          BL       swd_read_word
0000d8  2800              CMP      r0,#0                 ;1085
0000da  d043              BEQ      |L24.356|
0000dc  9800              LDR      r0,[sp,#0]            ;1088
0000de  0380              LSLS     r0,r0,#14             ;1088
0000e0  d5f6              BPL      |L24.208|
0000e2  2100              MOVS     r1,#0                 ;1091
0000e4  4620              MOV      r0,r4                 ;1091
                  |L24.230|
0000e6  f7fffffe          BL       swd_write_word
0000ea  2800              CMP      r0,#0
0000ec  d03a              BEQ      |L24.356|
0000ee  e038              B        |L24.354|
                  |L24.240|
0000f0  4628              MOV      r0,r5
0000f2  e7f8              B        |L24.230|
;;;1099                   return 0;
;;;1100               }
;;;1101   
;;;1102               break;
;;;1103   
;;;1104           case DEBUG:
;;;1105               if (!JTAG2SWD()) {
0000f4  f7fffffe          BL       JTAG2SWD
0000f8  2800              CMP      r0,#0
0000fa  d033              BEQ      |L24.356|
;;;1106                   return 0;
;;;1107               }
;;;1108   
;;;1109               if (!swd_clear_errors()) {
0000fc  f7fffffe          BL       swd_clear_errors
000100  2800              CMP      r0,#0
000102  d02f              BEQ      |L24.356|
;;;1110                   return 0;
;;;1111               }
;;;1112   
;;;1113               // Ensure CTRL/STAT register selected in DPBANKSEL
;;;1114               if (!swd_write_dp(DP_SELECT, 0)) {
000104  2100              MOVS     r1,#0
000106  2008              MOVS     r0,#8
000108  f7fffffe          BL       swd_write_dp
00010c  2800              CMP      r0,#0
00010e  d029              BEQ      |L24.356|
;;;1115                   return 0;
;;;1116               }
;;;1117   
;;;1118               // Power up
;;;1119               if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
000110  f04f41a0          MOV      r1,#0x50000000
000114  2004              MOVS     r0,#4
000116  e000              B        |L24.282|
                  |L24.280|
000118  e025              B        |L24.358|
                  |L24.282|
00011a  f7fffffe          BL       swd_write_dp
00011e  2800              CMP      r0,#0
000120  d020              BEQ      |L24.356|
;;;1120                   return 0;
;;;1121               }
;;;1122   
;;;1123               // Enable debug
;;;1124               if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
000122  4912              LDR      r1,|L24.364|
000124  1c49              ADDS     r1,r1,#1
000126  e7e3              B        |L24.240|
;;;1125                   return 0;
;;;1126               }
;;;1127   
;;;1128               break;
;;;1129   
;;;1130           case HALT:
;;;1131               if (!swd_init_debug()) {
000128  f7fffffe          BL       swd_init_debug
00012c  2800              CMP      r0,#0
00012e  d019              BEQ      |L24.356|
;;;1132                   return 0;
;;;1133               }
;;;1134   
;;;1135               // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;1136               if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
000130  4631              MOV      r1,r6
000132  4628              MOV      r0,r5
000134  f7fffffe          BL       swd_write_word
000138  2800              CMP      r0,#0
00013a  d013              BEQ      |L24.356|
                  |L24.316|
;;;1137                   return 0;
;;;1138               }
;;;1139   
;;;1140               // Wait until core is halted
;;;1141               do {
;;;1142                   if (!swd_read_word(DBG_HCSR, &val)) {
00013c  4669              MOV      r1,sp
00013e  4628              MOV      r0,r5
000140  f7fffffe          BL       swd_read_word
000144  2800              CMP      r0,#0
000146  d00d              BEQ      |L24.356|
;;;1143                       return 0;
;;;1144                   }
;;;1145               } while ((val & S_HALT) == 0);
000148  9800              LDR      r0,[sp,#0]
00014a  e000              B        |L24.334|
                  |L24.332|
00014c  e00a              B        |L24.356|
                  |L24.334|
00014e  0380              LSLS     r0,r0,#14
000150  d5f4              BPL      |L24.316|
000152  e006              B        |L24.354|
;;;1146               break;
;;;1147   
;;;1148           case RUN:
;;;1149               if (!swd_write_word(DBG_HCSR, DBGKEY)) {
000154  4628              MOV      r0,r5
000156  f7fffffe          BL       swd_write_word
00015a  2800              CMP      r0,#0
00015c  d002              BEQ      |L24.356|
                  |L24.350|
;;;1150                   return 0;
;;;1151               }
;;;1152               swd_off();
00015e  f7fffffe          BL       swd_off
                  |L24.354|
;;;1153               break;
;;;1154   
;;;1155           case POST_FLASH_RESET:
;;;1156               // This state should be handled in target_reset.c, nothing needs to be done here.
;;;1157               break;
;;;1158   
;;;1159           default:
;;;1160               return 0;
;;;1161       }
;;;1162   
;;;1163       return 1;
000162  2001              MOVS     r0,#1
                  |L24.356|
;;;1164   }
000164  bdf8              POP      {r3-r7,pc}
                  |L24.358|
000166  2000              MOVS     r0,#0                 ;1160
000168  bdf8              POP      {r3-r7,pc}
;;;1165   #endif
                          ENDP

00016a  0000              DCW      0x0000
                  |L24.364|
                          DCD      0xa05f0000
                  |L24.368|
                          DCD      0xe000edf0
                  |L24.372|
                          DCD      ||.data||
                  |L24.376|
                          DCD      0x05fa0000

                          AREA ||i.swd_transfer_retry||, CODE, READONLY, ALIGN=1

                  swd_transfer_retry PROC
;;;88     
;;;89     uint8_t swd_transfer_retry(uint32_t req, uint32_t *data)
000000  b570              PUSH     {r4-r6,lr}
;;;90     {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;91         uint8_t i, ack;
;;;92     
;;;93         for (i = 0; i < MAX_SWD_RETRY; i++) {
000006  2400              MOVS     r4,#0
                  |L25.8|
;;;94             ack = SWD_Transfer(req, data);
000008  4629              MOV      r1,r5
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       SWD_Transfer
;;;95     
;;;96             // if ack != WAIT
;;;97             if (ack != DAP_TRANSFER_WAIT) {
000010  2802              CMP      r0,#2
000012  d103              BNE      |L25.28|
000014  1c64              ADDS     r4,r4,#1
000016  b2e4              UXTB     r4,r4                 ;93
000018  2c64              CMP      r4,#0x64              ;93
00001a  d3f5              BCC      |L25.8|
                  |L25.28|
;;;98                 return ack;
;;;99             }
;;;100        }
;;;101    
;;;102        return ack;
;;;103    }
00001c  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP


                          AREA ||i.swd_write_ap||, CODE, READONLY, ALIGN=2

                  swd_write_ap PROC
;;;205    // Write access port register
;;;206    uint8_t swd_write_ap(uint32_t adr, uint32_t val)
000000  b538              PUSH     {r3-r5,lr}
;;;207    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;208        uint8_t data[4];
;;;209        uint8_t req, ack;
;;;210        uint32_t apsel = swd_get_apsel(adr);
000006  f7fffffe          BL       swd_get_apsel
;;;211        uint32_t bank_sel = adr & APBANKSEL;
00000a  f00402f0          AND      r2,r4,#0xf0
;;;212    
;;;213        if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
00000e  ea400102          ORR      r1,r0,r2
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       swd_write_dp
000018  2800              CMP      r0,#0
00001a  d005              BEQ      |L26.40|
;;;214            return 0;
;;;215        }
;;;216    
;;;217        switch (adr) {
00001c  b934              CBNZ     r4,|L26.44|
;;;218            case AP_CSW:
;;;219                if (dap_state.csw == val) {
00001e  480e              LDR      r0,|L26.88|
000020  6841              LDR      r1,[r0,#4]  ; dap_state
000022  42a9              CMP      r1,r5
000024  d101              BNE      |L26.42|
;;;220                    return 1;
000026  2001              MOVS     r0,#1
                  |L26.40|
;;;221                }
;;;222    
;;;223                dap_state.csw = val;
;;;224                break;
;;;225    
;;;226            default:
;;;227                break;
;;;228        }
;;;229    
;;;230        req = SWD_REG_AP | SWD_REG_W | SWD_REG_ADR(adr);
;;;231        int2array(data, val, 4);
;;;232    
;;;233        if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
;;;234            return 0;
;;;235        }
;;;236    
;;;237        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
;;;238        ack = swd_transfer_retry(req, NULL);
;;;239        return (ack == 0x01);
;;;240    }
000028  bd38              POP      {r3-r5,pc}
                  |L26.42|
00002a  6045              STR      r5,[r0,#4]            ;223  ; dap_state
                  |L26.44|
00002c  f004040c          AND      r4,r4,#0xc            ;230
000030  2204              MOVS     r2,#4                 ;231
000032  4629              MOV      r1,r5                 ;231
000034  4668              MOV      r0,sp                 ;231
000036  1c64              ADDS     r4,r4,#1              ;231
000038  f7fffffe          BL       int2array
00003c  4669              MOV      r1,sp                 ;233
00003e  4620              MOV      r0,r4                 ;233
000040  f7fffffe          BL       swd_transfer_retry
000044  2801              CMP      r0,#1                 ;233
000046  d105              BNE      |L26.84|
000048  200e              MOVS     r0,#0xe               ;237
00004a  2100              MOVS     r1,#0                 ;238
00004c  f7fffffe          BL       swd_transfer_retry
000050  2801              CMP      r0,#1                 ;239
000052  d0e9              BEQ      |L26.40|
                  |L26.84|
000054  2000              MOVS     r0,#0                 ;239
000056  bd38              POP      {r3-r5,pc}
;;;241    
                          ENDP

                  |L26.88|
                          DCD      ||.data||+0x8

                          AREA ||i.swd_write_block||, CODE, READONLY, ALIGN=2

                  swd_write_block PROC
;;;244    // size is in bytes.
;;;245    static uint8_t swd_write_block(uint32_t address, uint8_t *data, uint32_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;246    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
000006  b32a              CBZ      r2,|L27.84|
;;;247        uint8_t tmp_in[4], req;
;;;248        uint32_t size_in_words;
;;;249        uint32_t i, ack;
;;;250    
;;;251        if (size == 0) {
;;;252            return 0;
;;;253        }
;;;254    
;;;255        size_in_words = size / 4;
000008  0896              LSRS     r6,r2,#2
;;;256    
;;;257        // CSW register
;;;258        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
00000a  4913              LDR      r1,|L27.88|
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       swd_write_ap
000012  2800              CMP      r0,#0
000014  d01f              BEQ      |L27.86|
;;;259            return 0;
;;;260        }
;;;261    
;;;262        // TAR write
;;;263        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
000016  2705              MOVS     r7,#5
;;;264        int2array(tmp_in, address, 4);
000018  2204              MOVS     r2,#4
00001a  4621              MOV      r1,r4
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       int2array
;;;265    
;;;266        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000022  4669              MOV      r1,sp
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       swd_transfer_retry
00002a  2801              CMP      r0,#1
00002c  d112              BNE      |L27.84|
;;;267            return 0;
;;;268        }
;;;269    
;;;270        // DRW write
;;;271        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
00002e  270d              MOVS     r7,#0xd
;;;272    
;;;273        for (i = 0; i < size_in_words; i++) {
000030  2400              MOVS     r4,#0
000032  e007              B        |L27.68|
                  |L27.52|
;;;274            if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
000034  4629              MOV      r1,r5
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       swd_transfer_retry
00003c  2801              CMP      r0,#1
00003e  d109              BNE      |L27.84|
000040  1c64              ADDS     r4,r4,#1
000042  1d2d              ADDS     r5,r5,#4
                  |L27.68|
000044  42b4              CMP      r4,r6                 ;273
000046  d3f5              BCC      |L27.52|
;;;275                return 0;
;;;276            }
;;;277    
;;;278            data += 4;
;;;279        }
;;;280    
;;;281        // dummy read
;;;282        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000048  200e              MOVS     r0,#0xe
;;;283        ack = swd_transfer_retry(req, NULL);
00004a  2100              MOVS     r1,#0
00004c  f7fffffe          BL       swd_transfer_retry
;;;284        return (ack == 0x01);
000050  2801              CMP      r0,#1
000052  d000              BEQ      |L27.86|
                  |L27.84|
000054  2000              MOVS     r0,#0
                  |L27.86|
;;;285    }
000056  bdf8              POP      {r3-r7,pc}
;;;286    
                          ENDP

                  |L27.88|
                          DCD      0x23000052

                          AREA ||i.swd_write_byte||, CODE, READONLY, ALIGN=2

                  swd_write_byte PROC
;;;444    // Write 8-bit byte to target memory.
;;;445    uint8_t swd_write_byte(uint32_t addr, uint8_t val)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;447        uint32_t tmp;
;;;448    
;;;449        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
000006  4908              LDR      r1,|L28.40|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d009              BEQ      |L28.38|
;;;450            return 0;
;;;451        }
;;;452    
;;;453        tmp = val << ((addr & 0x03) << 3);
000012  07a8              LSLS     r0,r5,#30
000014  0ec0              LSRS     r0,r0,#27
000016  fa04f100          LSL      r1,r4,r0
;;;454    
;;;455        if (!swd_write_data(addr, tmp)) {
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       swd_write_data
000020  2800              CMP      r0,#0
000022  d000              BEQ      |L28.38|
;;;456            return 0;
;;;457        }
;;;458    
;;;459        return 1;
000024  2001              MOVS     r0,#1
                  |L28.38|
;;;460    }
000026  bd70              POP      {r4-r6,pc}
;;;461    
                          ENDP

                  |L28.40|
                          DCD      0x23000050

                          AREA ||i.swd_write_core_register||, CODE, READONLY, ALIGN=2

                  swd_write_core_register PROC
;;;642    
;;;643    uint8_t swd_write_core_register(uint32_t n, uint32_t val)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;644    {
000002  4606              MOV      r6,r0
;;;645        int i = 0, timeout = 100;
000004  2400              MOVS     r4,#0
000006  2564              MOVS     r5,#0x64
;;;646    
;;;647        if (!swd_write_word(DCRDR, val)) {
000008  480f              LDR      r0,|L29.72|
00000a  9901              LDR      r1,[sp,#4]
00000c  f7fffffe          BL       swd_write_word
000010  2800              CMP      r0,#0
000012  d013              BEQ      |L29.60|
;;;648            return 0;
;;;649        }
;;;650    
;;;651        if (!swd_write_word(DCRSR, n | REGWnR)) {
000014  480c              LDR      r0,|L29.72|
000016  f4463180          ORR      r1,r6,#0x10000
00001a  1f00              SUBS     r0,r0,#4
00001c  f7fffffe          BL       swd_write_word
000020  2800              CMP      r0,#0
000022  d00b              BEQ      |L29.60|
;;;652            return 0;
;;;653        }
;;;654    
;;;655        // wait for S_REGRDY
;;;656        for (i = 0; i < timeout; i++) {
;;;657            if (!swd_read_word(DHCSR, &val)) {
000024  4e08              LDR      r6,|L29.72|
000026  3e08              SUBS     r6,r6,#8
                  |L29.40|
000028  a901              ADD      r1,sp,#4
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       swd_read_word
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L29.60|
;;;658                return 0;
;;;659            }
;;;660    
;;;661            if (val & S_REGRDY) {
000034  9801              LDR      r0,[sp,#4]
000036  03c0              LSLS     r0,r0,#15
000038  d501              BPL      |L29.62|
;;;662                return 1;
00003a  2001              MOVS     r0,#1
                  |L29.60|
;;;663            }
;;;664        }
;;;665    
;;;666        return 0;
;;;667    }
00003c  bd7c              POP      {r2-r6,pc}
                  |L29.62|
00003e  1c64              ADDS     r4,r4,#1
000040  42ac              CMP      r4,r5                 ;656
000042  dbf1              BLT      |L29.40|
000044  2000              MOVS     r0,#0                 ;666
000046  bd7c              POP      {r2-r6,pc}
;;;668    
                          ENDP

                  |L29.72|
                          DCD      0xe000edf8

                          AREA ||i.swd_write_data||, CODE, READONLY, ALIGN=1

                  swd_write_data PROC
;;;372    // Write target memory.
;;;373    static uint8_t swd_write_data(uint32_t address, uint32_t data)
000000  b538              PUSH     {r3-r5,lr}
;;;374    {
000002  460c              MOV      r4,r1
;;;375        uint8_t tmp_in[4];
;;;376        uint8_t req, ack;
;;;377        // put addr in TAR register
;;;378        int2array(tmp_in, address, 4);
000004  4601              MOV      r1,r0
000006  2204              MOVS     r2,#4
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       int2array
;;;379        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00000e  2005              MOVS     r0,#5
;;;380    
;;;381        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000010  4669              MOV      r1,sp
000012  f7fffffe          BL       swd_transfer_retry
000016  2801              CMP      r0,#1
000018  d110              BNE      |L30.60|
;;;382            return 0;
;;;383        }
;;;384    
;;;385        // write data
;;;386        int2array(tmp_in, data, 4);
00001a  2204              MOVS     r2,#4
00001c  4621              MOV      r1,r4
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       int2array
;;;387        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
000024  200d              MOVS     r0,#0xd
;;;388    
;;;389        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000026  4669              MOV      r1,sp
000028  f7fffffe          BL       swd_transfer_retry
00002c  2801              CMP      r0,#1
00002e  d105              BNE      |L30.60|
;;;390            return 0;
;;;391        }
;;;392    
;;;393        // dummy read
;;;394        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000030  200e              MOVS     r0,#0xe
;;;395        ack = swd_transfer_retry(req, NULL);
000032  2100              MOVS     r1,#0
000034  f7fffffe          BL       swd_transfer_retry
;;;396        return (ack == 0x01) ? 1 : 0;
000038  2801              CMP      r0,#1
00003a  d000              BEQ      |L30.62|
                  |L30.60|
00003c  2000              MOVS     r0,#0
                  |L30.62|
;;;397    }
00003e  bd38              POP      {r3-r5,pc}
;;;398    
                          ENDP


                          AREA ||i.swd_write_debug_state||, CODE, READONLY, ALIGN=2

                  swd_write_debug_state PROC
;;;560    // Execute system call.
;;;561    static uint8_t swd_write_debug_state(DEBUG_STATE *state)
000000  b538              PUSH     {r3-r5,lr}
;;;562    {
000002  4605              MOV      r5,r0
;;;563        uint32_t i, status;
;;;564    
;;;565        if (!swd_write_dp(DP_SELECT, 0)) {
000004  2100              MOVS     r1,#0
000006  2008              MOVS     r0,#8
000008  f7fffffe          BL       swd_write_dp
00000c  2800              CMP      r0,#0
00000e  d03a              BEQ      |L31.134|
;;;566            return 0;
;;;567        }
;;;568    
;;;569        // R0, R1, R2, R3
;;;570        for (i = 0; i < 4; i++) {
000010  2400              MOVS     r4,#0
                  |L31.18|
;;;571            if (!swd_write_core_register(i, state->r[i])) {
000012  4620              MOV      r0,r4
000014  f8551024          LDR      r1,[r5,r4,LSL #2]
000018  f7fffffe          BL       swd_write_core_register
00001c  2800              CMP      r0,#0
00001e  d032              BEQ      |L31.134|
000020  1c64              ADDS     r4,r4,#1
000022  2c04              CMP      r4,#4                 ;570
000024  d3f5              BCC      |L31.18|
;;;572                return 0;
;;;573            }
;;;574        }
;;;575    
;;;576        // R9
;;;577        if (!swd_write_core_register(9, state->r[9])) {
000026  2009              MOVS     r0,#9
000028  6a69              LDR      r1,[r5,#0x24]
00002a  f7fffffe          BL       swd_write_core_register
00002e  2800              CMP      r0,#0
000030  d029              BEQ      |L31.134|
;;;578            return 0;
;;;579        }
;;;580    
;;;581        // R13, R14, R15
;;;582        for (i = 13; i < 16; i++) {
000032  240d              MOVS     r4,#0xd
                  |L31.52|
;;;583            if (!swd_write_core_register(i, state->r[i])) {
000034  4620              MOV      r0,r4
000036  f8551024          LDR      r1,[r5,r4,LSL #2]
00003a  f7fffffe          BL       swd_write_core_register
00003e  2800              CMP      r0,#0
000040  d021              BEQ      |L31.134|
000042  1c64              ADDS     r4,r4,#1
000044  2c10              CMP      r4,#0x10              ;582
000046  d3f5              BCC      |L31.52|
;;;584                return 0;
;;;585            }
;;;586        }
;;;587    
;;;588        // xPSR
;;;589        if (!swd_write_core_register(16, state->xpsr)) {
000048  2010              MOVS     r0,#0x10
00004a  6c29              LDR      r1,[r5,#0x40]
00004c  f7fffffe          BL       swd_write_core_register
000050  2800              CMP      r0,#0
000052  d018              BEQ      |L31.134|
;;;590            return 0;
;;;591        }
;;;592    
;;;593        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_MASKINTS | C_HALT)) {
000054  4c0e              LDR      r4,|L31.144|
000056  490d              LDR      r1,|L31.140|
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       swd_write_word
00005e  2800              CMP      r0,#0
000060  d011              BEQ      |L31.134|
;;;594            return 0;
;;;595        }
;;;596    
;;;597        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_MASKINTS)) {
000062  490a              LDR      r1,|L31.140|
000064  4620              MOV      r0,r4
000066  1e89              SUBS     r1,r1,#2
000068  f7fffffe          BL       swd_write_word
00006c  2800              CMP      r0,#0
00006e  d00a              BEQ      |L31.134|
;;;598            return 0;
;;;599        }
;;;600    
;;;601        // check status
;;;602        if (!swd_read_dp(DP_CTRL_STAT, &status)) {
000070  4669              MOV      r1,sp
000072  2004              MOVS     r0,#4
000074  f7fffffe          BL       swd_read_dp
000078  2800              CMP      r0,#0
00007a  d004              BEQ      |L31.134|
;;;603            return 0;
;;;604        }
;;;605    
;;;606        if (status & (STICKYERR | WDATAERR)) {
00007c  9800              LDR      r0,[sp,#0]
00007e  f0100fa0          TST      r0,#0xa0
000082  d001              BEQ      |L31.136|
;;;607            return 0;
000084  2000              MOVS     r0,#0
                  |L31.134|
;;;608        }
;;;609    
;;;610        return 1;
;;;611    }
000086  bd38              POP      {r3-r5,pc}
                  |L31.136|
000088  2001              MOVS     r0,#1                 ;610
00008a  bd38              POP      {r3-r5,pc}
;;;612    
                          ENDP

                  |L31.140|
                          DCD      0xa05f000b
                  |L31.144|
                          DCD      0xe000edf0

                          AREA ||i.swd_write_dp||, CODE, READONLY, ALIGN=2

                  swd_write_dp PROC
;;;155    // Write debug port register
;;;156    uint8_t swd_write_dp(uint8_t adr, uint32_t val)
000000  b5f8              PUSH     {r3-r7,lr}
;;;157    {
;;;158        uint32_t req;
;;;159        uint8_t data[4];
;;;160        uint8_t ack;
;;;161    
;;;162        //check if the right bank is already selected
;;;163        if ((adr == DP_SELECT) && (dap_state.select == val)) {
000002  4e0d              LDR      r6,|L32.56|
000004  4604              MOV      r4,r0                 ;157
000006  460d              MOV      r5,r1                 ;157
000008  2808              CMP      r0,#8
00000a  d102              BNE      |L32.18|
00000c  6830              LDR      r0,[r6,#0]  ; dap_state
00000e  42a8              CMP      r0,r5
000010  d010              BEQ      |L32.52|
                  |L32.18|
;;;164            return 1;
;;;165        }
;;;166    
;;;167        req = SWD_REG_DP | SWD_REG_W | SWD_REG_ADR(adr);
000012  f004070c          AND      r7,r4,#0xc
;;;168        int2array(data, val, 4);
000016  2204              MOVS     r2,#4
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       int2array
;;;169        ack = swd_transfer_retry(req, (uint32_t *)data);
00001e  4669              MOV      r1,sp
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       swd_transfer_retry
;;;170        if ((ack == DAP_TRANSFER_OK) && (adr == DP_SELECT)) {
000026  2801              CMP      r0,#1
000028  d001              BEQ      |L32.46|
;;;171            dap_state.select = val;
;;;172        }
;;;173        return (ack == 0x01);
00002a  2000              MOVS     r0,#0
;;;174    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L32.46|
00002e  2c08              CMP      r4,#8                 ;170
000030  d100              BNE      |L32.52|
000032  6035              STR      r5,[r6,#0]            ;171  ; dap_state
                  |L32.52|
000034  2001              MOVS     r0,#1                 ;173
000036  bdf8              POP      {r3-r7,pc}
;;;175    
                          ENDP

                  |L32.56|
                          DCD      ||.data||+0x8

                          AREA ||i.swd_write_memory||, CODE, READONLY, ALIGN=1

                  swd_write_memory PROC
;;;512    // size is in bytes.
;;;513    uint8_t swd_write_memory(uint32_t address, uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;514    {
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
000008  4606              MOV      r6,r0
;;;515        uint32_t n = 0;
;;;516    
;;;517        // Write bytes until word aligned
;;;518        while ((size > 0) && (address & 0x3)) {
;;;519            if (!swd_write_byte(address, *data)) {
;;;520                return 0;
;;;521            }
;;;522    
;;;523            address++;
;;;524            data++;
;;;525            size--;
00000a  e008              B        |L33.30|
                  |L33.12|
00000c  7829              LDRB     r1,[r5,#0]            ;519
00000e  4630              MOV      r0,r6                 ;519
000010  f7fffffe          BL       swd_write_byte
000014  2800              CMP      r0,#0                 ;519
000016  d027              BEQ      |L33.104|
000018  1e64              SUBS     r4,r4,#1              ;519
00001a  1c6d              ADDS     r5,r5,#1              ;519
00001c  1c76              ADDS     r6,r6,#1              ;519
                  |L33.30|
00001e  b314              CBZ      r4,|L33.102|
000020  07b0              LSLS     r0,r6,#30             ;518
000022  d1f3              BNE      |L33.12|
000024  e011              B        |L33.74|
                  |L33.38|
;;;526        }
;;;527    
;;;528        // Write word aligned blocks
;;;529        while (size > 3) {
;;;530            // Limit to auto increment page size
;;;531            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000026  f3c60009          UBFX     r0,r6,#0,#10
00002a  f5c06780          RSB      r7,r0,#0x400
;;;532    
;;;533            if (size < n) {
00002e  42bc              CMP      r4,r7
000030  d201              BCS      |L33.54|
;;;534                n = size & 0xFFFFFFFC; // Only count complete words remaining
000032  f0240703          BIC      r7,r4,#3
                  |L33.54|
;;;535            }
;;;536    
;;;537            if (!swd_write_block(address, data, n)) {
000036  463a              MOV      r2,r7
000038  4629              MOV      r1,r5
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       swd_write_block
000040  2800              CMP      r0,#0
000042  d011              BEQ      |L33.104|
;;;538                return 0;
;;;539            }
;;;540    
;;;541            address += n;
000044  443e              ADD      r6,r6,r7
;;;542            data += n;
000046  443d              ADD      r5,r5,r7
;;;543            size -= n;
000048  1be4              SUBS     r4,r4,r7
                  |L33.74|
00004a  2c03              CMP      r4,#3                 ;529
00004c  d8eb              BHI      |L33.38|
00004e  e008              B        |L33.98|
                  |L33.80|
;;;544        }
;;;545    
;;;546        // Write remaining bytes
;;;547        while (size > 0) {
;;;548            if (!swd_write_byte(address, *data)) {
000050  7829              LDRB     r1,[r5,#0]
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       swd_write_byte
000058  2800              CMP      r0,#0
00005a  d005              BEQ      |L33.104|
00005c  1e64              SUBS     r4,r4,#1
00005e  1c6d              ADDS     r5,r5,#1
000060  1c76              ADDS     r6,r6,#1
                  |L33.98|
000062  2c00              CMP      r4,#0                 ;547
000064  d1f4              BNE      |L33.80|
                  |L33.102|
;;;549                return 0;
;;;550            }
;;;551    
;;;552            address++;
;;;553            data++;
;;;554            size--;
;;;555        }
;;;556    
;;;557        return 1;
000066  2001              MOVS     r0,#1
                  |L33.104|
;;;558    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;559    
                          ENDP


                          AREA ||i.swd_write_word||, CODE, READONLY, ALIGN=2

                  swd_write_word PROC
;;;413    // Write 32-bit word to target memory.
;;;414    uint8_t swd_write_word(uint32_t addr, uint32_t val)
000000  b570              PUSH     {r4-r6,lr}
;;;415    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;416        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
000006  4907              LDR      r1,|L34.36|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       swd_write_ap
00000e  2800              CMP      r0,#0
000010  d006              BEQ      |L34.32|
;;;417            return 0;
;;;418        }
;;;419    
;;;420        if (!swd_write_data(addr, val)) {
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       swd_write_data
00001a  2800              CMP      r0,#0
00001c  d000              BEQ      |L34.32|
;;;421            return 0;
;;;422        }
;;;423    
;;;424        return 1;
00001e  2001              MOVS     r0,#1
                  |L34.32|
;;;425    }
000020  bd70              POP      {r4-r6,pc}
;;;426    
                          ENDP

000022  0000              DCW      0x0000
                  |L34.36|
                          DCD      0x23000052

                          AREA ||.data||, DATA, ALIGN=2

                  reset_connect
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  soft_reset
                          DCD      0x00000004
                  dap_state
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\interface\\swd_host.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_swd_host_c_a7d0a6c9____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___10_swd_host_c_a7d0a6c9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_swd_host_c_a7d0a6c9____REVSH|
#line 144
|__asm___10_swd_host_c_a7d0a6c9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
