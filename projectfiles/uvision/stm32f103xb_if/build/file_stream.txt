; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\file_stream.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\file_stream.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\file_stream.crf ..\..\..\source\daplink\drag-n-drop\file_stream.c]
                          THUMB

                          AREA ||i.close_bin||, CODE, READONLY, ALIGN=1

                  close_bin PROC
;;;281    
;;;282    static error_t close_bin(void *state)
000000  f7ffbffe          B.W      flash_decoder_close
;;;283    {
;;;284        error_t status;
;;;285        status = flash_decoder_close();
;;;286        return status;
;;;287    }
;;;288    
                          ENDP


                          AREA ||i.close_hex||, CODE, READONLY, ALIGN=1

                  close_hex PROC
;;;361    
;;;362    static error_t close_hex(void *state)
000000  f7ffbffe          B.W      flash_decoder_close
;;;363    {
;;;364        error_t status;
;;;365        status = flash_decoder_close();
;;;366        return status;
;;;367    }
                          ENDP


                          AREA ||i.detect_bin||, CODE, READONLY, ALIGN=1

                  detect_bin PROC
;;;207    
;;;208    static bool detect_bin(const uint8_t *data, uint32_t size)
000000  b510              PUSH     {r4,lr}
;;;209    {
;;;210        return FLASH_DECODER_TYPE_UNKNOWN != flash_decoder_detect_type(data, size, 0, false);
000002  2300              MOVS     r3,#0
000004  461a              MOV      r2,r3
000006  f7fffffe          BL       flash_decoder_detect_type
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L3.16|
00000e  2001              MOVS     r0,#1
                  |L3.16|
;;;211    }
000010  bd10              POP      {r4,pc}
;;;212    
                          ENDP


                          AREA ||i.detect_hex||, CODE, READONLY, ALIGN=1

                  detect_hex PROC
;;;290    
;;;291    static bool detect_hex(const uint8_t *data, uint32_t size)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293        return 1 == validate_hexfile(data);
000002  f7fffffe          BL       validate_hexfile
000006  2801              CMP      r0,#1
000008  d000              BEQ      |L4.12|
00000a  2000              MOVS     r0,#0
                  |L4.12|
;;;294    }
00000c  bd10              POP      {r4,pc}
;;;295    
                          ENDP


                          AREA ||i.open_bin||, CODE, READONLY, ALIGN=1

                  open_bin PROC
;;;212    
;;;213    static error_t open_bin(void *state)
000000  f7ffbffe          B.W      flash_decoder_open
;;;214    {
;;;215        error_t status;
;;;216        status = flash_decoder_open();
;;;217        return status;
;;;218    }
;;;219    
                          ENDP


                          AREA ||i.open_hex||, CODE, READONLY, ALIGN=1

                  open_hex PROC
;;;295    
;;;296    static error_t open_hex(void *state)
000000  b510              PUSH     {r4,lr}
;;;297    {
000002  4604              MOV      r4,r0
;;;298        error_t status;
;;;299        hex_state_t *hex_state = (hex_state_t *)state;
;;;300        memset(hex_state, 0, sizeof(*hex_state));
000004  f2401101          MOV      r1,#0x101
000008  f7fffffe          BL       __aeabi_memclr
;;;301        reset_hex_parser();
00000c  f7fffffe          BL       reset_hex_parser
;;;302        hex_state->parsing_complete = false;
000010  2000              MOVS     r0,#0
000012  7020              STRB     r0,[r4,#0]
;;;303        status = flash_decoder_open();
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      flash_decoder_open
;;;304        return status;
;;;305    }
;;;306    
                          ENDP


                          AREA ||i.stream_close||, CODE, READONLY, ALIGN=2

                  stream_close PROC
;;;186    
;;;187    error_t stream_close(void)
000000  b510              PUSH     {r4,lr}
;;;188    {
;;;189        error_t status;
;;;190    
;;;191        // Stream must not be closed already
;;;192        if (STREAM_STATE_CLOSED == state) {
000002  4c09              LDR      r4,|L7.40|
000004  7820              LDRB     r0,[r4,#0]  ; state
000006  b140              CBZ      r0,|L7.26|
;;;193            util_assert(0);
;;;194            return ERROR_INTERNAL;
;;;195        }
;;;196    
;;;197        // Check thread after checking state since the stream thread is
;;;198        // set only if stream_open has been called
;;;199        stream_thread_assert();
000008  f7fffffe          BL       stream_thread_assert
;;;200        // Close stream
;;;201        status = current_stream->close(&shared_state);
00000c  6860              LDR      r0,[r4,#4]  ; current_stream
00000e  68c1              LDR      r1,[r0,#0xc]
000010  4806              LDR      r0,|L7.44|
000012  4788              BLX      r1
;;;202        state = STREAM_STATE_CLOSED;
000014  2100              MOVS     r1,#0
000016  7021              STRB     r1,[r4,#0]
;;;203        return status;
;;;204    }
000018  bd10              POP      {r4,pc}
                  |L7.26|
00001a  22c1              MOVS     r2,#0xc1              ;193
00001c  a104              ADR      r1,|L7.48|
00001e  2000              MOVS     r0,#0                 ;193
000020  f7fffffe          BL       _util_assert
000024  2002              MOVS     r0,#2                 ;194
000026  bd10              POP      {r4,pc}
;;;205    
                          ENDP

                  |L7.40|
                          DCD      ||.data||
                  |L7.44|
                          DCD      ||.bss||
                  |L7.48|
000030  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\file_stream.c"
000034  2e5c2e2e
000038  5c736f75
00003c  7263655c
000040  6461706c
000044  696e6b5c
000048  64726167
00004c  2d6e2d64
000050  726f705c
000054  66696c65
000058  5f737472
00005c  65616d2e
000060  63      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.stream_open||, CODE, READONLY, ALIGN=2

                  stream_open PROC
;;;127    
;;;128    error_t stream_open(stream_type_t stream_type)
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
;;;130        error_t status;
;;;131    
;;;132        // Stream must not be open already
;;;133        if (state != STREAM_STATE_CLOSED) {
000002  4c13              LDR      r4,|L8.80|
000004  4605              MOV      r5,r0                 ;129
000006  7820              LDRB     r0,[r4,#0]  ; state
000008  b108              CBZ      r0,|L8.14|
;;;134            util_assert(0);
00000a  2286              MOVS     r2,#0x86
;;;135            return ERROR_INTERNAL;
00000c  e002              B        |L8.20|
                  |L8.14|
;;;136        }
;;;137    
;;;138        // Stream must be of a supported type
;;;139        if (stream_type >= STREAM_TYPE_COUNT) {
00000e  2d02              CMP      r5,#2
000010  d306              BCC      |L8.32|
;;;140            util_assert(0);
000012  228c              MOVS     r2,#0x8c
                  |L8.20|
000014  a10f              ADR      r1,|L8.84|
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       _util_assert
;;;141            return ERROR_INTERNAL;
00001c  2002              MOVS     r0,#2
                  |L8.30|
;;;142        }
;;;143    
;;;144        stream_thread_set();
;;;145        // Initialize all variables
;;;146        memset(&shared_state, 0, sizeof(shared_state));
;;;147        state = STREAM_STATE_OPEN;
;;;148        current_stream = &stream[stream_type];
;;;149        // Initialize the specified stream
;;;150        status = current_stream->open(&shared_state);
;;;151    
;;;152        if (ERROR_SUCCESS != status) {
;;;153            state = STREAM_STATE_ERROR;
;;;154        }
;;;155    
;;;156        return status;
;;;157    }
00001e  bd70              POP      {r4-r6,pc}
                  |L8.32|
000020  f7fffffe          BL       osThreadGetId
000024  60a0              STR      r0,[r4,#8]            ;146  ; stream_thread_tid
000026  f44f7182          MOV      r1,#0x104             ;146
00002a  4817              LDR      r0,|L8.136|
00002c  f7fffffe          BL       __aeabi_memclr4
000030  2001              MOVS     r0,#1                 ;147
000032  7020              STRB     r0,[r4,#0]            ;147
000034  4806              LDR      r0,|L8.80|
000036  300c              ADDS     r0,r0,#0xc            ;148
000038  eb001005          ADD      r0,r0,r5,LSL #4       ;148
00003c  6060              STR      r0,[r4,#4]            ;150  ; current_stream
00003e  6841              LDR      r1,[r0,#4]            ;150
000040  4811              LDR      r0,|L8.136|
000042  4788              BLX      r1                    ;150
000044  2800              CMP      r0,#0                 ;152
000046  d0ea              BEQ      |L8.30|
000048  2103              MOVS     r1,#3                 ;153
00004a  7021              STRB     r1,[r4,#0]            ;153
00004c  bd70              POP      {r4-r6,pc}
;;;158    
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      ||.data||
                  |L8.84|
000054  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\file_stream.c"
000058  2e5c2e2e
00005c  5c736f75
000060  7263655c
000064  6461706c
000068  696e6b5c
00006c  64726167
000070  2d6e2d64
000074  726f705c
000078  66696c65
00007c  5f737472
000080  65616d2e
000084  63      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L8.136|
                          DCD      ||.bss||

                          AREA ||i.stream_start_identify||, CODE, READONLY, ALIGN=2

                  stream_start_identify PROC
;;;101    
;;;102    stream_type_t stream_start_identify(const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;103    {
;;;104        stream_type_t i;
;;;105    
;;;106        for (i = STREAM_TYPE_START; i < STREAM_TYPE_COUNT; i++) {
;;;107            if (stream[i].detect(data, size)) {
000004  4d09              LDR      r5,|L9.44|
000006  460e              MOV      r6,r1                 ;103
000008  4607              MOV      r7,r0                 ;103
00000a  2400              MOVS     r4,#0                 ;106
                  |L9.12|
00000c  eb051004          ADD      r0,r5,r4,LSL #4
000010  4631              MOV      r1,r6
000012  6802              LDR      r2,[r0,#0]
000014  4638              MOV      r0,r7
000016  4790              BLX      r2
000018  b110              CBZ      r0,|L9.32|
;;;108                return i;
00001a  4620              MOV      r0,r4
                  |L9.28|
;;;109            }
;;;110        }
;;;111    
;;;112        return STREAM_TYPE_NONE;
;;;113    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L9.32|
000020  1c64              ADDS     r4,r4,#1
000022  b2e4              UXTB     r4,r4                 ;106
000024  2c02              CMP      r4,#2                 ;106
000026  d3f1              BCC      |L9.12|
000028  2003              MOVS     r0,#3                 ;112
00002a  e7f7              B        |L9.28|
;;;114    
                          ENDP

                  |L9.44|
                          DCD      ||.data||+0xc

                          AREA ||i.stream_thread_assert||, CODE, READONLY, ALIGN=2

                  stream_thread_assert PROC
;;;96     }
;;;97     static void stream_thread_assert(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99         util_assert(osThreadGetId() == stream_thread_tid);
000002  f7fffffe          BL       osThreadGetId
000006  4906              LDR      r1,|L10.32|
000008  6889              LDR      r1,[r1,#8]  ; stream_thread_tid
00000a  4288              CMP      r0,r1
00000c  d101              BNE      |L10.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L10.20|
                  |L10.18|
000012  2000              MOVS     r0,#0
                  |L10.20|
000014  e8bd4010          POP      {r4,lr}
000018  2263              MOVS     r2,#0x63
00001a  a102              ADR      r1,|L10.36|
00001c  f7ffbffe          B.W      _util_assert
;;;100    }
;;;101    
                          ENDP

                  |L10.32|
                          DCD      ||.data||
                  |L10.36|
000024  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\file_stream.c"
000028  2e5c2e2e
00002c  5c736f75
000030  7263655c
000034  6461706c
000038  696e6b5c
00003c  64726167
000040  2d6e2d64
000044  726f705c
000048  66696c65
00004c  5f737472
000050  65616d2e
000054  63      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.stream_type_from_name||, CODE, READONLY, ALIGN=2

                  stream_type_from_name PROC
;;;115    // Identify the file type from its extension
;;;116    stream_type_t stream_type_from_name(const vfs_filename_t filename)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118        // 8.3 file names must be in upper case
;;;119        if (0 == strncmp("BIN", &filename[8], 3)) {
000002  f1000108          ADD      r1,r0,#8
000006  2203              MOVS     r2,#3
000008  460c              MOV      r4,r1
00000a  a007              ADR      r0,|L11.40|
00000c  f7fffffe          BL       strncmp
000010  2800              CMP      r0,#0
000012  d006              BEQ      |L11.34|
;;;120            return STREAM_TYPE_BIN;
;;;121        } else if (0 == strncmp("HEX", &filename[8], 3)) {
000014  2203              MOVS     r2,#3
000016  4621              MOV      r1,r4
000018  a004              ADR      r0,|L11.44|
00001a  f7fffffe          BL       strncmp
00001e  b108              CBZ      r0,|L11.36|
;;;122            return STREAM_TYPE_HEX;
;;;123        } else {
;;;124            return STREAM_TYPE_NONE;
000020  2003              MOVS     r0,#3
                  |L11.34|
;;;125        }
;;;126    }
000022  bd10              POP      {r4,pc}
                  |L11.36|
000024  2001              MOVS     r0,#1                 ;122
000026  bd10              POP      {r4,pc}
;;;127    
                          ENDP

                  |L11.40|
000028  42494e00          DCB      "BIN",0
                  |L11.44|
00002c  48455800          DCB      "HEX",0

                          AREA ||i.stream_write||, CODE, READONLY, ALIGN=2

                  stream_write PROC
;;;158    
;;;159    error_t stream_write(const uint8_t *data, uint32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;160    {
;;;161        error_t status;
;;;162    
;;;163        // Stream must be open already
;;;164        if (state != STREAM_STATE_OPEN) {
000002  4d15              LDR      r5,|L12.88|
000004  4606              MOV      r6,r0                 ;160
000006  460c              MOV      r4,r1                 ;160
000008  7828              LDRB     r0,[r5,#0]  ; state
00000a  2801              CMP      r0,#1
00000c  d006              BEQ      |L12.28|
;;;165            util_assert(0);
00000e  22a5              MOVS     r2,#0xa5
000010  a112              ADR      r1,|L12.92|
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       _util_assert
;;;166            return ERROR_INTERNAL;
000018  2002              MOVS     r0,#2
;;;167        }
;;;168    
;;;169        // Check thread after checking state since the stream thread is
;;;170        // set only if stream_open has been called
;;;171        stream_thread_assert();
;;;172        // Write to stream
;;;173        status = current_stream->write(&shared_state, data, size);
;;;174    
;;;175        if (ERROR_SUCCESS_DONE == status) {
;;;176            state = STREAM_STATE_END;
;;;177        } else if ((ERROR_SUCCESS_DONE_OR_CONTINUE == status) || (ERROR_SUCCESS == status)) {
;;;178            // Stream should remain in the open state
;;;179            util_assert(STREAM_STATE_OPEN == state);
;;;180        } else {
;;;181            state = STREAM_STATE_ERROR;
;;;182        }
;;;183    
;;;184        return status;
;;;185    }
00001a  bd70              POP      {r4-r6,pc}
                  |L12.28|
00001c  f7fffffe          BL       stream_thread_assert
000020  6868              LDR      r0,[r5,#4]            ;173  ; current_stream
000022  4622              MOV      r2,r4                 ;173
000024  4631              MOV      r1,r6                 ;173
000026  6883              LDR      r3,[r0,#8]            ;173
000028  4819              LDR      r0,|L12.144|
00002a  4798              BLX      r3                    ;173
00002c  4604              MOV      r4,r0                 ;173
00002e  2813              CMP      r0,#0x13              ;175
000030  d006              BEQ      |L12.64|
000032  2c14              CMP      r4,#0x14              ;177
000034  d006              BEQ      |L12.68|
000036  b12c              CBZ      r4,|L12.68|
000038  2003              MOVS     r0,#3                 ;181
                  |L12.58|
00003a  7028              STRB     r0,[r5,#0]            ;181
                  |L12.60|
00003c  4620              MOV      r0,r4                 ;184
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2002              MOVS     r0,#2                 ;176
000042  e7fa              B        |L12.58|
                  |L12.68|
000044  7828              LDRB     r0,[r5,#0]            ;179  ; state
000046  2801              CMP      r0,#1                 ;179
000048  d000              BEQ      |L12.76|
00004a  2000              MOVS     r0,#0                 ;179
                  |L12.76|
00004c  22b3              MOVS     r2,#0xb3              ;179
00004e  a103              ADR      r1,|L12.92|
000050  f7fffffe          BL       _util_assert
000054  e7f2              B        |L12.60|
;;;186    
                          ENDP

000056  0000              DCW      0x0000
                  |L12.88|
                          DCD      ||.data||
                  |L12.92|
00005c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\file_stream.c"
000060  2e5c2e2e
000064  5c736f75
000068  7263655c
00006c  6461706c
000070  696e6b5c
000074  64726167
000078  2d6e2d64
00007c  726f705c
000080  66696c65
000084  5f737472
000088  65616d2e
00008c  63      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L12.144|
                          DCD      ||.bss||

                          AREA ||i.write_bin||, CODE, READONLY, ALIGN=1

                  write_bin PROC
;;;219    
;;;220    static error_t write_bin(void *state, const uint8_t *data, uint32_t size)
000000  b5fe              PUSH     {r1-r7,lr}
;;;221    {
000002  4604              MOV      r4,r0
;;;222        error_t status;
;;;223        bin_state_t *bin_state = (bin_state_t *)state;
;;;224    
;;;225        if (bin_state->buf_pos < FLASH_DECODER_MIN_SIZE) {
000004  f8900030          LDRB     r0,[r0,#0x30]
000008  4615              MOV      r5,r2                 ;221
00000a  460f              MOV      r7,r1                 ;221
00000c  2830              CMP      r0,#0x30
00000e  d301              BCC      |L13.20|
;;;226            flash_decoder_type_t flash_type;
;;;227            uint32_t size_left;
;;;228            uint32_t copy_size;
;;;229            uint32_t start_addr;
;;;230            const flash_intf_t *flash_intf;
;;;231            // Buffer Data
;;;232            size_left = FLASH_DECODER_MIN_SIZE - bin_state->buf_pos;
;;;233            copy_size = MIN(size_left, size);
;;;234            memcpy(bin_state->vector_buf + bin_state->buf_pos, data, copy_size);
;;;235            bin_state->buf_pos += copy_size;
;;;236    
;;;237            if (bin_state->buf_pos < FLASH_DECODER_MIN_SIZE) {
;;;238                // Not enough data to determine type
;;;239                return ERROR_SUCCESS;
;;;240            }
;;;241    
;;;242            data += copy_size;
;;;243            size -= copy_size;
;;;244            // Determine type
;;;245            flash_type = flash_decoder_detect_type(bin_state->vector_buf, bin_state->buf_pos, 0, false);
;;;246    
;;;247            if (FLASH_DECODER_TYPE_UNKNOWN == flash_type) {
;;;248                return ERROR_FD_UNSUPPORTED_UPDATE;
;;;249            }
;;;250    
;;;251            // Determine flash addresss
;;;252            status = flash_decoder_get_flash(flash_type, 0, false, &start_addr, &flash_intf);
;;;253    
;;;254            if (ERROR_SUCCESS != status) {
;;;255                return status;
;;;256            }
;;;257    
;;;258            bin_state->flash_addr = start_addr;
;;;259            // Pass on data to the decoder
;;;260            status = flash_decoder_write(bin_state->flash_addr, bin_state->vector_buf, bin_state->buf_pos);
;;;261    
;;;262            if (ERROR_SUCCESS != status) {
;;;263                return status;
;;;264            }
;;;265    
;;;266            bin_state->flash_addr += bin_state->buf_pos;
;;;267        }
000010  6b60              LDR      r0,[r4,#0x34]
000012  e031              B        |L13.120|
                  |L13.20|
000014  f1c00630          RSB      r6,r0,#0x30           ;232
000018  42ae              CMP      r6,r5                 ;233
00001a  d300              BCC      |L13.30|
00001c  4616              MOV      r6,r2                 ;233
                  |L13.30|
00001e  4420              ADD      r0,r0,r4              ;234
000020  4632              MOV      r2,r6                 ;234
000022  f7fffffe          BL       __aeabi_memcpy
000026  f8940030          LDRB     r0,[r4,#0x30]         ;235
00002a  4430              ADD      r0,r0,r6              ;235
00002c  b2c1              UXTB     r1,r0                 ;235
00002e  f8841030          STRB     r1,[r4,#0x30]         ;235
000032  2930              CMP      r1,#0x30              ;237
000034  d201              BCS      |L13.58|
000036  2000              MOVS     r0,#0                 ;239
                  |L13.56|
;;;268    
;;;269        // Write data
;;;270        status = flash_decoder_write(bin_state->flash_addr, data, size);
;;;271    
;;;272        if (ERROR_SUCCESS != status) {
;;;273            return status;
;;;274        }
;;;275    
;;;276        bin_state->flash_addr += size;
;;;277        // There is no way to determine the end of a binary
;;;278        // file so any point could be the end
;;;279        return ERROR_SUCCESS_DONE_OR_CONTINUE;
;;;280    }
000038  bdfe              POP      {r1-r7,pc}
                  |L13.58|
00003a  2300              MOVS     r3,#0                 ;245
00003c  4437              ADD      r7,r7,r6              ;242
00003e  1bad              SUBS     r5,r5,r6              ;243
000040  461a              MOV      r2,r3                 ;245
000042  4620              MOV      r0,r4                 ;245
000044  f7fffffe          BL       flash_decoder_detect_type
000048  b308              CBZ      r0,|L13.142|
00004a  a902              ADD      r1,sp,#8              ;252
00004c  2200              MOVS     r2,#0                 ;252
00004e  9100              STR      r1,[sp,#0]            ;252
000050  ab01              ADD      r3,sp,#4              ;252
000052  4611              MOV      r1,r2                 ;252
000054  f7fffffe          BL       flash_decoder_get_flash
000058  2800              CMP      r0,#0                 ;254
00005a  d1ed              BNE      |L13.56|
00005c  9801              LDR      r0,[sp,#4]            ;258
00005e  6360              STR      r0,[r4,#0x34]         ;260
000060  f8942030          LDRB     r2,[r4,#0x30]         ;260
000064  4621              MOV      r1,r4                 ;260
000066  f7fffffe          BL       flash_decoder_write
00006a  2800              CMP      r0,#0                 ;262
00006c  d1e4              BNE      |L13.56|
00006e  f8941030          LDRB     r1,[r4,#0x30]         ;266
000072  6b60              LDR      r0,[r4,#0x34]         ;266
000074  4408              ADD      r0,r0,r1              ;266
000076  6360              STR      r0,[r4,#0x34]         ;266
                  |L13.120|
000078  462a              MOV      r2,r5                 ;270
00007a  4639              MOV      r1,r7                 ;270
00007c  f7fffffe          BL       flash_decoder_write
000080  2800              CMP      r0,#0                 ;272
000082  d1d9              BNE      |L13.56|
000084  6b60              LDR      r0,[r4,#0x34]         ;276
000086  4428              ADD      r0,r0,r5              ;276
000088  6360              STR      r0,[r4,#0x34]         ;279
00008a  2014              MOVS     r0,#0x14              ;279
00008c  bdfe              POP      {r1-r7,pc}
                  |L13.142|
00008e  201c              MOVS     r0,#0x1c              ;248
000090  bdfe              POP      {r1-r7,pc}
;;;281    
                          ENDP


                          AREA ||i.write_hex||, CODE, READONLY, ALIGN=2

                  write_hex PROC
;;;306    
;;;307    static error_t write_hex(void *state, const uint8_t *data, uint32_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;308    {
000004  b086              SUB      sp,sp,#0x18
;;;309        error_t status = ERROR_SUCCESS;
000006  2400              MOVS     r4,#0
000008  4616              MOV      r6,r2                 ;308
00000a  460f              MOV      r7,r1                 ;308
00000c  4605              MOV      r5,r0                 ;308
;;;310        hex_state_t *hex_state = (hex_state_t *)state;
;;;311        hexfile_parse_status_t parse_status = HEX_PARSE_UNINIT;
;;;312        uint32_t bin_start_address = 0; // Decoded from the hex file, the binary buffer data starts at this address
;;;313        uint32_t bin_buf_written = 0;   // The amount of data in the binary buffer starting at address above
00000e  9403              STR      r4,[sp,#0xc]
;;;314        uint32_t block_amt_parsed = 0;  // amount of data parsed in the block on the last call
000010  9404              STR      r4,[sp,#0x10]
;;;315    
;;;316        while (1) {
;;;317            // try to decode a block of hex data into bin data
;;;318            parse_status = parse_hex_blob(data, size, &block_amt_parsed, hex_state->bin_buffer, sizeof(hex_state->bin_buffer), &bin_start_address, &bin_buf_written);
000012  f10d0810          ADD      r8,sp,#0x10
000016  f10d090c          ADD      r9,sp,#0xc
00001a  f44f7a80          MOV      r10,#0x100
00001e  9405              STR      r4,[sp,#0x14]
                  |L14.32|
000020  f8cda000          STR      r10,[sp,#0]
000024  e9cd9801          STRD     r9,r8,[sp,#4]
000028  1c6b              ADDS     r3,r5,#1
00002a  aa05              ADD      r2,sp,#0x14
00002c  4631              MOV      r1,r6
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       parse_hex_blob
;;;319    
;;;320            // the entire block of hex was decoded. This is a simple state
;;;321            if (HEX_PARSE_OK == parse_status) {
000034  b168              CBZ      r0,|L14.82|
;;;322                if (bin_buf_written > 0) {
;;;323                    status = flash_decoder_write(bin_start_address, hex_state->bin_buffer, bin_buf_written);
;;;324                }
;;;325    
;;;326                break;
;;;327            } else if (HEX_PARSE_UNALIGNED == parse_status) {
000036  2802              CMP      r0,#2
000038  d013              BEQ      |L14.98|
;;;328                if (bin_buf_written > 0) {
;;;329                    status = flash_decoder_write(bin_start_address, hex_state->bin_buffer, bin_buf_written);
;;;330    
;;;331                    if (ERROR_SUCCESS != status) {
;;;332                        break;
;;;333                    }
;;;334                }
;;;335    
;;;336                // incrememntal offset to finish the block
;;;337                size -= block_amt_parsed;
;;;338                data += block_amt_parsed;
;;;339            } else if (HEX_PARSE_EOF == parse_status) {
00003a  2801              CMP      r0,#1
00003c  d01d              BEQ      |L14.122|
;;;340                if (bin_buf_written > 0) {
;;;341                    status = flash_decoder_write(bin_start_address, hex_state->bin_buffer, bin_buf_written);
;;;342                }
;;;343    
;;;344                if (ERROR_SUCCESS == status) {
;;;345                    status = ERROR_SUCCESS_DONE;
;;;346                }
;;;347    
;;;348                break;
;;;349            } else if (HEX_PARSE_CKSUM_FAIL == parse_status) {
00003e  2804              CMP      r0,#4
000040  d025              BEQ      |L14.142|
;;;350                status = ERROR_HEX_CKSUM;
;;;351                break;
;;;352            } else if ((HEX_PARSE_UNINIT == parse_status) || (HEX_PARSE_FAILURE == parse_status)) {
000042  2805              CMP      r0,#5
000044  d001              BEQ      |L14.74|
000046  2806              CMP      r0,#6
000048  d1ea              BNE      |L14.32|
                  |L14.74|
;;;353                util_assert(HEX_PARSE_UNINIT != parse_status);
00004a  2805              CMP      r0,#5
00004c  d021              BEQ      |L14.146|
00004e  2001              MOVS     r0,#1
000050  e020              B        |L14.148|
                  |L14.82|
000052  9a04              LDR      r2,[sp,#0x10]         ;322
000054  b322              CBZ      r2,|L14.160|
000056  1c69              ADDS     r1,r5,#1              ;323
000058  9803              LDR      r0,[sp,#0xc]          ;323
00005a  f7fffffe          BL       flash_decoder_write
00005e  4604              MOV      r4,r0                 ;323
000060  e01e              B        |L14.160|
                  |L14.98|
000062  9a04              LDR      r2,[sp,#0x10]         ;328
000064  b12a              CBZ      r2,|L14.114|
000066  1c69              ADDS     r1,r5,#1              ;329
000068  9803              LDR      r0,[sp,#0xc]          ;329
00006a  f7fffffe          BL       flash_decoder_write
00006e  0004              MOVS     r4,r0                 ;329
000070  d116              BNE      |L14.160|
                  |L14.114|
000072  9805              LDR      r0,[sp,#0x14]         ;337
000074  1a36              SUBS     r6,r6,r0              ;337
000076  4407              ADD      r7,r7,r0              ;338
000078  e7d2              B        |L14.32|
                  |L14.122|
00007a  9a04              LDR      r2,[sp,#0x10]         ;340
00007c  b122              CBZ      r2,|L14.136|
00007e  1c69              ADDS     r1,r5,#1              ;341
000080  9803              LDR      r0,[sp,#0xc]          ;341
000082  f7fffffe          BL       flash_decoder_write
000086  4604              MOV      r4,r0                 ;341
                  |L14.136|
000088  b954              CBNZ     r4,|L14.160|
00008a  2413              MOVS     r4,#0x13              ;345
00008c  e008              B        |L14.160|
                  |L14.142|
00008e  2415              MOVS     r4,#0x15              ;350
000090  e006              B        |L14.160|
                  |L14.146|
000092  2000              MOVS     r0,#0
                  |L14.148|
000094  f2401261          MOV      r2,#0x161
000098  a103              ADR      r1,|L14.168|
00009a  f7fffffe          BL       _util_assert
;;;354                status = ERROR_HEX_PARSER;
00009e  2416              MOVS     r4,#0x16
                  |L14.160|
;;;355                break;
;;;356            }
;;;357        }
;;;358    
;;;359        return status;
;;;360    }
0000a0  b006              ADD      sp,sp,#0x18
0000a2  4620              MOV      r0,r4                 ;359
0000a4  e8bd87f0          POP      {r4-r10,pc}
;;;361    
                          ENDP

                  |L14.168|
0000a8  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\file_stream.c"
0000ac  2e5c2e2e
0000b0  5c736f75
0000b4  7263655c
0000b8  6461706c
0000bc  696e6b5c
0000c0  64726167
0000c4  2d6e2d64
0000c8  726f705c
0000cc  66696c65
0000d0  5f737472
0000d4  65616d2e
0000d8  63      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  shared_state
                          %        260

                          AREA ||.data||, DATA, ALIGN=2

                  state
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  current_stream
                          DCD      0x00000000
                  stream_thread_tid
                          DCD      0x00000000
                  stream
                          DCD      detect_bin
                          DCD      open_bin
                          DCD      write_bin
                          DCD      close_bin
                          DCD      detect_hex
                          DCD      open_hex
                          DCD      write_hex
                          DCD      close_hex
