; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\dap.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\dap.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\dap.crf ..\..\..\source\daplink\cmsis-dap\DAP.c]
                          THUMB

                          AREA ||i.DAP_ExecuteCommand||, CODE, READONLY, ALIGN=1

                  DAP_ExecuteCommand PROC
;;;1569   //             number of bytes in request (upper 16 bits)
;;;1570   uint32_t DAP_ExecuteCommand(const uint8_t *request, uint8_t *response) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1571     uint32_t cnt, num, n;
;;;1572   
;;;1573     if (*request == ID_DAP_ExecuteCommands) {
000004  7802              LDRB     r2,[r0,#0]
000006  2a7f              CMP      r2,#0x7f
000008  d003              BEQ      |L1.18|
;;;1574       *response++ = *request++;
;;;1575       cnt = *request++;
;;;1576       *response++ = (uint8_t)cnt;
;;;1577       num = (2U << 16) | 2U;
;;;1578       while (cnt--) {
;;;1579         n = DAP_ProcessCommand(request, response);
;;;1580         num += n;
;;;1581         request  += (uint16_t)(n >> 16);
;;;1582         response += (uint16_t) n;  
;;;1583       }
;;;1584       return (num);
;;;1585     }
;;;1586   
;;;1587     return DAP_ProcessCommand(request, response);
00000a  e8bd41f0          POP      {r4-r8,lr}
00000e  f7ffbffe          B.W      DAP_ProcessCommand
                  |L1.18|
000012  f8012b01          STRB     r2,[r1],#1            ;1574
000016  7844              LDRB     r4,[r0,#1]            ;1575
000018  f8014b01          STRB     r4,[r1],#1            ;1576
00001c  1c86              ADDS     r6,r0,#2              ;1575
00001e  460d              MOV      r5,r1                 ;1576
000020  f04f1702          MOV      r7,#0x20002           ;1577
000024  e008              B        |L1.56|
                  |L1.38|
000026  4629              MOV      r1,r5                 ;1579
000028  4630              MOV      r0,r6                 ;1579
00002a  f7fffffe          BL       DAP_ProcessCommand
00002e  4407              ADD      r7,r7,r0              ;1580
000030  eb064610          ADD      r6,r6,r0,LSR #16      ;1581
000034  b280              UXTH     r0,r0                 ;1582
000036  4405              ADD      r5,r5,r0              ;1582
                  |L1.56|
000038  1e64              SUBS     r4,r4,#1              ;1582
00003a  d2f4              BCS      |L1.38|
00003c  4638              MOV      r0,r7                 ;1584
;;;1588   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1589   
                          ENDP


                          AREA ||i.DAP_Info||, CODE, READONLY, ALIGN=1

                  DAP_Info PROC
;;;88     //   return:  number of bytes in info data
;;;89     static uint8_t DAP_Info(uint8_t id, uint8_t *info) {
000000  b570              PUSH     {r4-r6,lr}
;;;90       uint8_t length = 0U;
000002  2400              MOVS     r4,#0
000004  460d              MOV      r5,r1                 ;89
;;;91       const char *data = NULL;
;;;92     
;;;93       switch (id) {
000006  2806              CMP      r0,#6
000008  d02b              BEQ      |L2.98|
00000a  dc06              BGT      |L2.26|
00000c  2805              CMP      r0,#5
00000e  d228              BCS      |L2.98|
000010  e8dff000          TBB      [pc,r0]
000014  2727270c          DCB      0x27,0x27,0x27,0x0c
000018  0f00              DCB      0x0f,0x00
                  |L2.26|
00001a  28f0              CMP      r0,#0xf0
00001c  d016              BEQ      |L2.76|
00001e  28fd              CMP      r0,#0xfd
000020  d01f              BEQ      |L2.98|
000022  28fe              CMP      r0,#0xfe
000024  d01a              BEQ      |L2.92|
000026  28ff              CMP      r0,#0xff
000028  d11b              BNE      |L2.98|
00002a  e011              B        |L2.80|
;;;94         case DAP_ID_VENDOR:
;;;95     #ifdef DAP_VENDOR
;;;96           memcpy(info, DAP_Vendor, sizeof(DAP_Vendor));
;;;97           length = (uint8_t)sizeof(DAP_Vendor);
;;;98     #endif
;;;99           break;
;;;100        case DAP_ID_PRODUCT:
;;;101    #ifdef DAP_PRODUCT
;;;102          memcpy(info, DAP_Product, sizeof(DAP_Product));
;;;103          length = (uint8_t)sizeof(DAP_Product);
;;;104    #endif
;;;105          break;
;;;106        case DAP_ID_SER_NUM:
;;;107    #ifdef DAP_SER_NUM
;;;108          memcpy(info, DAP_SerNum, sizeof(DAP_SerNum));
;;;109          length = (uint8_t)sizeof(DAP_SerNum);
;;;110    // --- begin DAPLink change ---
;;;111    #else
;;;112          data = info_get_unique_id();
00002c  f7fffffe          BL       info_get_unique_id
;;;113          length = (uint8_t)strlen(data) + 1;
;;;114          memcpy(info, data, length);
;;;115    // --- end DAPLink change ---
;;;116    #endif
;;;117          break;
000030  e001              B        |L2.54|
;;;118        case DAP_ID_FW_VER:
;;;119    // --- begin DAPLink change ---
;;;120          data = info_get_version();
000032  f7fffffe          BL       info_get_version
                  |L2.54|
000036  4606              MOV      r6,r0
;;;121          length = (uint8_t)strlen(data) + 1;
000038  f7fffffe          BL       strlen
00003c  1c40              ADDS     r0,r0,#1
00003e  b2c4              UXTB     r4,r0
;;;122          memcpy(info, data, length);
000040  4622              MOV      r2,r4
000042  4631              MOV      r1,r6
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       __aeabi_memcpy
00004a  e00a              B        |L2.98|
                  |L2.76|
;;;123    // Original:
;;;124    //       memcpy(info, DAP_FW_Ver, sizeof(DAP_FW_Ver));
;;;125    //       length = (uint8_t)sizeof(DAP_FW_Ver);
;;;126    // --- end DAPLink change ---
;;;127          break;
;;;128        case DAP_ID_DEVICE_VENDOR:
;;;129    #if TARGET_DEVICE_FIXED
;;;130          memcpy(info, TargetDeviceVendor, sizeof(TargetDeviceVendor));
;;;131          length = (uint8_t)sizeof(TargetDeviceVendor);
;;;132    #endif
;;;133          break;
;;;134        case DAP_ID_DEVICE_NAME:
;;;135    #if TARGET_DEVICE_FIXED
;;;136          memcpy(info, TargetDeviceName, sizeof(TargetDeviceName));
;;;137          length = (uint8_t)sizeof(TargetDeviceName);
;;;138    #endif
;;;139          break;
;;;140        case DAP_ID_CAPABILITIES:
;;;141          info[0] = ((DAP_SWD  != 0)       ? (1U << 0) : 0U) |
00004c  2011              MOVS     r0,#0x11
;;;142                    ((DAP_JTAG != 0)       ? (1U << 1) : 0U) |
;;;143                    ((SWO_UART != 0)       ? (1U << 2) : 0U) |
;;;144                    ((SWO_MANCHESTER != 0) ? (1U << 3) : 0U) |
;;;145                    /* Atomic Commands  */   (1U << 4);
;;;146          length = 1U;
;;;147          break;
00004e  e006              B        |L2.94|
                  |L2.80|
;;;148        case DAP_ID_SWO_BUFFER_SIZE:
;;;149    #if ((SWO_UART != 0) || (SWO_MANCHESTER != 0))
;;;150          info[0] = (uint8_t)(SWO_BUFFER_SIZE >>  0);
;;;151          info[1] = (uint8_t)(SWO_BUFFER_SIZE >>  8);
;;;152          info[2] = (uint8_t)(SWO_BUFFER_SIZE >> 16);
;;;153          info[3] = (uint8_t)(SWO_BUFFER_SIZE >> 24);
;;;154          length = 4U;
;;;155    #endif
;;;156          break;
;;;157        case DAP_ID_PACKET_SIZE:
;;;158          info[0] = (uint8_t)(DAP_PACKET_SIZE >> 0);
000050  2040              MOVS     r0,#0x40
000052  7028              STRB     r0,[r5,#0]
;;;159          info[1] = (uint8_t)(DAP_PACKET_SIZE >> 8);
000054  2000              MOVS     r0,#0
000056  7048              STRB     r0,[r1,#1]
;;;160          length = 2U;
000058  2402              MOVS     r4,#2
;;;161          break;
00005a  e002              B        |L2.98|
                  |L2.92|
;;;162        case DAP_ID_PACKET_COUNT:
;;;163          info[0] = DAP_PACKET_COUNT;
00005c  2004              MOVS     r0,#4
                  |L2.94|
00005e  7008              STRB     r0,[r1,#0]
;;;164          length = 1U;
000060  2401              MOVS     r4,#1
                  |L2.98|
;;;165          break;
;;;166        default:
;;;167          break;
;;;168      }
;;;169    
;;;170      return (length);
000062  4620              MOV      r0,r4
;;;171    }
000064  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP


                          AREA ||i.DAP_ProcessCommand||, CODE, READONLY, ALIGN=2

                  DAP_ProcessCommand PROC
;;;1462   //             number of bytes in request (upper 16 bits)
;;;1463   uint32_t DAP_ProcessCommand(const uint8_t *request, uint8_t *response) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1464     uint32_t num;
;;;1465   
;;;1466     if ((*request >= ID_DAP_Vendor0) && (*request <= ID_DAP_Vendor31)) {
000004  7802              LDRB     r2,[r0,#0]
000006  f1a20380          SUB      r3,r2,#0x80
00000a  2b1f              CMP      r3,#0x1f
00000c  d803              BHI      |L3.22|
;;;1467       return DAP_ProcessVendorCommand(request, response);
00000e  f7fffffe          BL       DAP_ProcessVendorCommand
                  |L3.18|
;;;1468     }
;;;1469   
;;;1470     *response++ = *request;
;;;1471   
;;;1472     switch (*request++) {
;;;1473       case ID_DAP_Info:
;;;1474         num = DAP_Info(*request, response+1);
;;;1475         *response = (uint8_t)num;
;;;1476         return ((2U << 16) + 2U + num);
;;;1477   
;;;1478       case ID_DAP_HostStatus:
;;;1479         num = DAP_HostStatus(request, response);
;;;1480         break;
;;;1481   
;;;1482       case ID_DAP_Connect:
;;;1483         num = DAP_Connect(request, response);
;;;1484         break;
;;;1485       case ID_DAP_Disconnect:
;;;1486         num = DAP_Disconnect(response);
;;;1487         break;
;;;1488   
;;;1489       case ID_DAP_Delay:
;;;1490         num = DAP_Delay(request, response);
;;;1491         break;
;;;1492   
;;;1493       case ID_DAP_ResetTarget:
;;;1494         num = DAP_ResetTarget(response);
;;;1495         break;
;;;1496   
;;;1497       case ID_DAP_SWJ_Pins:
;;;1498         num = DAP_SWJ_Pins(request, response);
;;;1499         break;
;;;1500       case ID_DAP_SWJ_Clock:
;;;1501         num = DAP_SWJ_Clock(request, response);
;;;1502         break;
;;;1503       case ID_DAP_SWJ_Sequence:
;;;1504         num = DAP_SWJ_Sequence(request, response);
;;;1505         break;
;;;1506   
;;;1507       case ID_DAP_SWD_Configure:
;;;1508         num = DAP_SWD_Configure(request, response);
;;;1509         break;
;;;1510   
;;;1511       case ID_DAP_JTAG_Sequence:
;;;1512         num = DAP_JTAG_Sequence(request, response);
;;;1513         break;
;;;1514       case ID_DAP_JTAG_Configure:
;;;1515         num = DAP_JTAG_Configure(request, response);
;;;1516         break;
;;;1517       case ID_DAP_JTAG_IDCODE:
;;;1518         num = DAP_JTAG_IDCode(request, response);
;;;1519         break;
;;;1520   
;;;1521       case ID_DAP_TransferConfigure:
;;;1522         num = DAP_TransferConfigure(request, response);
;;;1523         break;
;;;1524       case ID_DAP_Transfer:
;;;1525         num = DAP_Transfer(request, response);
;;;1526         break;
;;;1527       case ID_DAP_TransferBlock:
;;;1528         num = DAP_TransferBlock(request, response);
;;;1529         break;
;;;1530   
;;;1531       case ID_DAP_WriteABORT:
;;;1532         num = DAP_WriteAbort(request, response);
;;;1533         break;
;;;1534   
;;;1535   #if ((SWO_UART != 0) || (SWO_MANCHESTER != 0))
;;;1536       case ID_DAP_SWO_Transport:
;;;1537         num = SWO_Transport(request, response);
;;;1538         break;
;;;1539       case ID_DAP_SWO_Mode:
;;;1540         num = SWO_Mode(request, response);
;;;1541         break;
;;;1542       case ID_DAP_SWO_Baudrate:
;;;1543         num = SWO_Baudrate(request, response);
;;;1544         break;
;;;1545       case ID_DAP_SWO_Control:
;;;1546         num = SWO_Control(request, response);
;;;1547         break;
;;;1548       case ID_DAP_SWO_Status:
;;;1549         num = SWO_Status(response);
;;;1550         break;
;;;1551       case ID_DAP_SWO_Data:
;;;1552         num = SWO_Data(request, response);
;;;1553         break;
;;;1554   #endif
;;;1555   
;;;1556       default:
;;;1557         *(response-1) = ID_DAP_Invalid;
;;;1558         return ((1U << 16) | 1U);
;;;1559     }
;;;1560   
;;;1561     return ((1U << 16) + 1U + num);
;;;1562   }
000012  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.22|
000016  f8012b01          STRB     r2,[r1],#1            ;1470
00001a  4f94              LDR      r7,|L3.620|
00001c  460c              MOV      r4,r1                 ;1470
00001e  f810cb01          LDRB     r12,[r0],#1           ;1472
000022  2500              MOVS     r5,#0                 ;1472
000024  f8dfa244          LDR      r10,|L3.620|
000028  23ff              MOVS     r3,#0xff              ;1472
00002a  4991              LDR      r1,|L3.624|
00002c  4a91              LDR      r2,|L3.628|
00002e  3f10              SUBS     r7,r7,#0x10           ;1472
000030  f8dfb244          LDR      r11,|L3.632|
000034  f04f0901          MOV      r9,#1                 ;1466
000038  f04f1601          MOV      r6,#0x10001           ;1466
00003c  f1bc0f17          CMP      r12,#0x17             ;1472
000040  d273              BCS      |L3.298|
000042  e8dff00c          TBB      [pc,r12]              ;1472
000046  0c14              DCB      0x0c,0x14
000048  264db4c1          DCB      0x26,0x4d,0xb4,0xc1
00004c  dc72fa60          DCB      0xdc,0x72,0xfa,0x60
000050  73727272          DCB      0x73,0x72,0x72,0x72
000054  7272777b          DCB      0x72,0x72,0x77,0x7b
000058  809099af          DCB      0x80,0x90,0x99,0xaf
00005c  b200              DCB      0xb2,0x00
00005e  7800              LDRB     r0,[r0,#0]            ;1474
000060  1c61              ADDS     r1,r4,#1              ;1474
000062  f7fffffe          BL       DAP_Info
000066  7020              STRB     r0,[r4,#0]            ;1475
000068  f1001002          ADD      r0,r0,#0x20002        ;1475
00006c  e7d1              B        |L3.18|
00006e  7802              LDRB     r2,[r0,#0]
000070  b122              CBZ      r2,|L3.124|
000072  2a01              CMP      r2,#1
000074  d057              BEQ      |L3.294|
000076  7023              STRB     r3,[r4,#0]
                  |L3.120|
000078  460e              MOV      r6,r1                 ;1479
00007a  e0e3              B        |L3.580|
                  |L3.124|
00007c  7840              LDRB     r0,[r0,#1]            ;1480
00007e  07c2              LSLS     r2,r0,#31             ;1480
000080  f04f0040          MOV      r0,#0x40              ;1480
000084  d002              BEQ      |L3.140|
000086  4a79              LDR      r2,|L3.620|
000088  1d12              ADDS     r2,r2,#4              ;1480
00008a  e000              B        |L3.142|
                  |L3.140|
00008c  4652              MOV      r2,r10                ;1480
                  |L3.142|
00008e  6010              STR      r0,[r2,#0]            ;1480
000090  e049              B        |L3.294|
000092  7805              LDRB     r5,[r0,#0]            ;1480
000094  b125              CBZ      r5,|L3.160|
000096  2d01              CMP      r5,#1                 ;1480
000098  d003              BEQ      |L3.162|
00009a  2500              MOVS     r5,#0                 ;1480
                  |L3.156|
00009c  7025              STRB     r5,[r4,#0]            ;1480
00009e  e0d1              B        |L3.580|
                  |L3.160|
0000a0  2501              MOVS     r5,#1                 ;1484
                  |L3.162|
0000a2  f8829000          STRB     r9,[r2,#0]            ;1484
0000a6  210d              MOVS     r1,#0xd               ;1484
0000a8  46b8              MOV      r8,r7                 ;1484
0000aa  4638              MOV      r0,r7                 ;1484
0000ac  f7fffffe          BL       pin_out_init
0000b0  f44f5000          MOV      r0,#0x2000            ;1484
0000b4  4657              MOV      r7,r10                ;1484
0000b6  f8ca0000          STR      r0,[r10,#0]           ;1484
0000ba  210e              MOVS     r1,#0xe               ;1484
0000bc  4640              MOV      r0,r8                 ;1484
0000be  f7fffffe          BL       pin_out_init
0000c2  f44f4080          MOV      r0,#0x4000            ;1484
0000c6  6038              STR      r0,[r7,#0]            ;1484
0000c8  2201              MOVS     r2,#1                 ;1484
0000ca  210c              MOVS     r1,#0xc               ;1484
0000cc  4640              MOV      r0,r8                 ;1484
0000ce  f7fffffe          BL       pin_in_init
0000d2  2100              MOVS     r1,#0                 ;1484
0000d4  4640              MOV      r0,r8                 ;1484
0000d6  f7fffffe          BL       pin_out_od_init
0000da  f8c79000          STR      r9,[r7,#0]            ;1484
0000de  e7dd              B        |L3.156|
0000e0  7015              STRB     r5,[r2,#0]            ;1484
0000e2  2200              MOVS     r2,#0                 ;1484
0000e4  210d              MOVS     r1,#0xd               ;1484
0000e6  4638              MOV      r0,r7                 ;1484
0000e8  f7fffffe          BL       pin_in_init
0000ec  2200              MOVS     r2,#0                 ;1484
0000ee  210e              MOVS     r1,#0xe               ;1484
0000f0  4638              MOV      r0,r7                 ;1484
0000f2  f7fffffe          BL       pin_in_init
0000f6  2200              MOVS     r2,#0                 ;1484
0000f8  210c              MOVS     r1,#0xc               ;1484
0000fa  4638              MOV      r0,r7                 ;1484
0000fc  f7fffffe          BL       pin_in_init
000100  7025              STRB     r5,[r4,#0]            ;1484
000102  464e              MOV      r6,r9                 ;1484
000104  e09e              B        |L3.580|
000106  7842              LDRB     r2,[r0,#1]            ;1487
000108  7800              LDRB     r0,[r0,#0]            ;1487
00010a  4b5d              LDR      r3,|L3.640|
00010c  ea402202          ORR      r2,r0,r2,LSL #8       ;1487
000110  485a              LDR      r0,|L3.636|
000112  6800              LDR      r0,[r0,#0]            ;1487  ; SystemCoreClock
000114  fbb0f0f3          UDIV     r0,r0,r3              ;1487
000118  2303              MOVS     r3,#3                 ;1487
00011a  1c80              ADDS     r0,r0,#2              ;1487
00011c  fbb0f0f3          UDIV     r0,r0,r3              ;1487
000120  4350              MULS     r0,r2,r0              ;1487
                  |L3.290|
000122  1e40              SUBS     r0,r0,#1              ;1487
000124  d1fd              BNE      |L3.290|
                  |L3.294|
000126  7025              STRB     r5,[r4,#0]            ;1487
000128  e7a6              B        |L3.120|
                  |L3.298|
00012a  e09b              B        |L3.612|
00012c  7065              STRB     r5,[r4,#1]            ;1491
00012e  7025              STRB     r5,[r4,#0]            ;1491
000130  2602              MOVS     r6,#2                 ;1491
000132  e087              B        |L3.580|
000134  4621              MOV      r1,r4                 ;1498
000136  f7fffffe          BL       DAP_SWJ_Pins
00013a  e002              B        |L3.322|
00013c  4621              MOV      r1,r4                 ;1501
00013e  f7fffffe          BL       DAP_SWJ_Clock
                  |L3.322|
000142  4606              MOV      r6,r0                 ;1498
000144  e07e              B        |L3.580|
000146  f8106b01          LDRB     r6,[r0],#1            ;1498
00014a  b90e              CBNZ     r6,|L3.336|
00014c  f44f7680          MOV      r6,#0x100             ;1498
                  |L3.336|
000150  4601              MOV      r1,r0                 ;1498
000152  4630              MOV      r0,r6                 ;1498
000154  f7fffffe          BL       SWJ_Sequence
000158  1df6              ADDS     r6,r6,#7              ;1498
00015a  7025              STRB     r5,[r4,#0]            ;1498
00015c  08f0              LSRS     r0,r6,#3              ;1498
                  |L3.350|
00015e  0406              LSLS     r6,r0,#16             ;1498
000160  f1061601          ADD      r6,r6,#0x10001        ;1498
000164  e06e              B        |L3.580|
000166  7800              LDRB     r0,[r0,#0]            ;1498
000168  f0000103          AND      r1,r0,#3              ;1498
00016c  1c49              ADDS     r1,r1,#1              ;1498
00016e  7511              STRB     r1,[r2,#0x14]         ;1498
000170  f3c00080          UBFX     r0,r0,#2,#1           ;1498
000174  7550              STRB     r0,[r2,#0x15]         ;1498
000176  e791              B        |L3.156|
000178  7023              STRB     r3,[r4,#0]            ;1509
00017a  2201              MOVS     r2,#1                 ;1509
00017c  4616              MOV      r6,r2                 ;1509
00017e  f8103b01          LDRB     r3,[r0],#1            ;1509
000182  e00a              B        |L3.410|
                  |L3.388|
000184  f8101b01          LDRB     r1,[r0],#1            ;1512
000188  f011013f          ANDS     r1,r1,#0x3f           ;1512
00018c  d100              BNE      |L3.400|
00018e  2140              MOVS     r1,#0x40              ;1512
                  |L3.400|
000190  1dc9              ADDS     r1,r1,#7              ;1512
000192  08c9              LSRS     r1,r1,#3              ;1512
000194  440a              ADD      r2,r2,r1              ;1512
000196  4408              ADD      r0,r0,r1              ;1512
000198  1c52              ADDS     r2,r2,#1              ;1512
                  |L3.410|
00019a  1e5b              SUBS     r3,r3,#1              ;1512
00019c  d2f2              BCS      |L3.388|
00019e  f362461f          BFI      r6,r2,#16,#16         ;1512
0001a2  e04f              B        |L3.580|
0001a4  7800              LDRB     r0,[r0,#0]            ;1513
0001a6  7023              STRB     r3,[r4,#0]            ;1513
0001a8  e7d9              B        |L3.350|
0001aa  7023              STRB     r3,[r4,#0]            ;1516
0001ac  e04a              B        |L3.580|
0001ae  7801              LDRB     r1,[r0,#0]            ;1519
0001b0  7211              STRB     r1,[r2,#8]            ;1519
0001b2  7881              LDRB     r1,[r0,#2]            ;1519
0001b4  7843              LDRB     r3,[r0,#1]            ;1519
0001b6  ea432101          ORR      r1,r3,r1,LSL #8       ;1519
0001ba  8151              STRH     r1,[r2,#0xa]          ;1519
0001bc  7901              LDRB     r1,[r0,#4]            ;1519
0001be  78c3              LDRB     r3,[r0,#3]            ;1519
0001c0  ea432001          ORR      r0,r3,r1,LSL #8       ;1519
0001c4  8190              STRH     r0,[r2,#0xc]          ;1519
0001c6  e04b              B        |L3.608|
0001c8  7812              LDRB     r2,[r2,#0]            ;1523  ; DAP_Data
0001ca  4621              MOV      r1,r4                 ;1525
0001cc  2a01              CMP      r2,#1                 ;1525
0001ce  d013              BEQ      |L3.504|
0001d0  4606              MOV      r6,r0                 ;1525
0001d2  1c40              ADDS     r0,r0,#1              ;1525
0001d4  f8102b01          LDRB     r2,[r0],#1            ;1525
0001d8  b142              CBZ      r2,|L3.492|
                  |L3.474|
0001da  f8103b01          LDRB     r3,[r0],#1            ;1525
0001de  079c              LSLS     r4,r3,#30             ;1525
0001e0  d501              BPL      |L3.486|
0001e2  06db              LSLS     r3,r3,#27             ;1525
0001e4  d500              BPL      |L3.488|
                  |L3.486|
0001e6  1d00              ADDS     r0,r0,#4              ;1525
                  |L3.488|
0001e8  1e52              SUBS     r2,r2,#1              ;1525
0001ea  d1f6              BNE      |L3.474|
                  |L3.492|
0001ec  1b80              SUBS     r0,r0,r6              ;1525
0001ee  700d              STRB     r5,[r1,#0]            ;1525
0001f0  0400              LSLS     r0,r0,#16             ;1525
0001f2  704d              STRB     r5,[r1,#1]            ;1525
0001f4  1c80              ADDS     r0,r0,#2              ;1525
0001f6  e7a4              B        |L3.322|
                  |L3.504|
0001f8  f7fffffe          BL       DAP_SWD_Transfer
0001fc  e7a1              B        |L3.322|
0001fe  4606              MOV      r6,r0                 ;1528
000200  7810              LDRB     r0,[r2,#0]            ;1528  ; DAP_Data
000202  4621              MOV      r1,r4                 ;1528
000204  2801              CMP      r0,#1                 ;1528
000206  d009              BEQ      |L3.540|
000208  700d              STRB     r5,[r1,#0]            ;1528
00020a  704d              STRB     r5,[r1,#1]            ;1528
00020c  70a5              STRB     r5,[r4,#2]            ;1528
00020e  2003              MOVS     r0,#3                 ;1528
                  |L3.528|
000210  78f1              LDRB     r1,[r6,#3]            ;1528
000212  0789              LSLS     r1,r1,#30             ;1528
000214  d507              BPL      |L3.550|
000216  f4402680          ORR      r6,r0,#0x40000        ;1528
00021a  e013              B        |L3.580|
                  |L3.540|
00021c  4630              MOV      r0,r6                 ;1528
00021e  f7fffffe          BL       DAP_SWD_TransferBlock
000222  e7f5              B        |L3.528|
000224  e009              B        |L3.570|
                  |L3.550|
000226  78b1              LDRB     r1,[r6,#2]            ;1528
000228  7872              LDRB     r2,[r6,#1]            ;1528
00022a  ea422101          ORR      r1,r2,r1,LSL #8       ;1528
00022e  f44f2280          MOV      r2,#0x40000           ;1528
000232  eb024681          ADD      r6,r2,r1,LSL #18      ;1528
000236  4306              ORRS     r6,r6,r0              ;1528
000238  e004              B        |L3.580|
                  |L3.570|
00023a  7811              LDRB     r1,[r2,#0]            ;1528  ; DAP_Data
00023c  2901              CMP      r1,#1                 ;1528
00023e  d004              BEQ      |L3.586|
000240  7023              STRB     r3,[r4,#0]            ;1532
                  |L3.578|
000242  465e              MOV      r6,r11                ;1532
                  |L3.580|
000244  f1061001          ADD      r0,r6,#0x10001        ;1561
000248  e6e3              B        |L3.18|
                  |L3.586|
00024a  7906              LDRB     r6,[r0,#4]
00024c  1c40              ADDS     r0,r0,#1
00024e  f7fffffe          BL       __aeabi_uread4
000252  f366601f          BFI      r0,r6,#24,#8
000256  9000              STR      r0,[sp,#0]
000258  4669              MOV      r1,sp
00025a  2000              MOVS     r0,#0
00025c  f7fffffe          BL       SWD_Transfer
                  |L3.608|
000260  7025              STRB     r5,[r4,#0]
000262  e7ee              B        |L3.578|
                  |L3.612|
000264  f8043c01          STRB     r3,[r4,#-1]           ;1557
000268  4630              MOV      r0,r6                 ;1558
00026a  e6d2              B        |L3.18|
;;;1563   
                          ENDP

                  |L3.620|
                          DCD      0x40010c10
                  |L3.624|
                          DCD      0x00020001
                  |L3.628|
                          DCD      ||.bss||
                  |L3.632|
                          DCD      0x00050001
                  |L3.636|
                          DCD      SystemCoreClock
                  |L3.640|
                          DCD      0x000f4240

                          AREA ||i.DAP_ProcessVendorCommand||, CODE, READONLY, ALIGN=1

                  DAP_ProcessVendorCommand PROC
;;;1451   //             number of bytes in request (upper 16 bits)
;;;1452   __weak uint32_t DAP_ProcessVendorCommand(const uint8_t *request, uint8_t *response) {
000000  20ff              MOVS     r0,#0xff
;;;1453     *response = ID_DAP_Invalid;
000002  7008              STRB     r0,[r1,#0]
;;;1454     return ((1U << 16) | 1U);
000004  f04f1001          MOV      r0,#0x10001
;;;1455   }
000008  4770              BX       lr
;;;1456   
                          ENDP


                          AREA ||i.DAP_SETUP||, CODE, READONLY, ALIGN=2

                  DAP_SETUP PROC
;;;477    */
;;;478    static __inline void DAP_SETUP(void)
000000  b538              PUSH     {r3-r5,lr}
;;;479    {
;;;480        /* Enable port clock */
;;;481        __HAL_RCC_GPIOA_CLK_ENABLE();
000002  4821              LDR      r0,|L5.136|
000004  6981              LDR      r1,[r0,#0x18]
000006  f0410104          ORR      r1,r1,#4
00000a  6181              STR      r1,[r0,#0x18]
00000c  6981              LDR      r1,[r0,#0x18]
00000e  f0010104          AND      r1,r1,#4
;;;482        __HAL_RCC_GPIOB_CLK_ENABLE();
000012  9100              STR      r1,[sp,#0]
000014  6981              LDR      r1,[r0,#0x18]
000016  f0410108          ORR      r1,r1,#8
00001a  6181              STR      r1,[r0,#0x18]
00001c  6981              LDR      r1,[r0,#0x18]
00001e  f0010108          AND      r1,r1,#8
;;;483        __HAL_RCC_GPIOC_CLK_ENABLE();
000022  9100              STR      r1,[sp,#0]
000024  6981              LDR      r1,[r0,#0x18]
000026  f0410110          ORR      r1,r1,#0x10
00002a  6181              STR      r1,[r0,#0x18]
00002c  6981              LDR      r1,[r0,#0x18]
00002e  f0010110          AND      r1,r1,#0x10
;;;484        __HAL_RCC_GPIOD_CLK_ENABLE();
000032  9100              STR      r1,[sp,#0]
000034  6981              LDR      r1,[r0,#0x18]
000036  f0410120          ORR      r1,r1,#0x20
00003a  6181              STR      r1,[r0,#0x18]
00003c  6980              LDR      r0,[r0,#0x18]
;;;485        /* Configure I/O pin SWCLK */
;;;486        pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);
00003e  4d13              LDR      r5,|L5.140|
000040  f0000020          AND      r0,r0,#0x20           ;484
000044  9000              STR      r0,[sp,#0]
000046  210d              MOVS     r1,#0xd
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       pin_out_init
;;;487        SWCLK_TCK_PIN_PORT->BSRR = SWCLK_TCK_PIN;
00004e  4c0f              LDR      r4,|L5.140|
000050  1468              ASRS     r0,r5,#17
000052  3410              ADDS     r4,r4,#0x10
000054  6020              STR      r0,[r4,#0]
;;;488    
;;;489        pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);
000056  210e              MOVS     r1,#0xe
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       pin_out_init
;;;490        SWDIO_OUT_PIN_PORT->BSRR = SWDIO_OUT_PIN;
00005e  f44f4080          MOV      r0,#0x4000
000062  6020              STR      r0,[r4,#0]
;;;491    
;;;492        pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, 1);
000064  2201              MOVS     r2,#1
000066  210c              MOVS     r1,#0xc
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       pin_in_init
;;;493    
;;;494        pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);
00006e  2100              MOVS     r1,#0
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       pin_out_od_init
;;;495        nRESET_PIN_PORT->BSRR = nRESET_PIN;
000076  2001              MOVS     r0,#1
000078  6020              STR      r0,[r4,#0]
;;;496    
;;;497        pin_out_init(CONNECTED_LED_PORT, CONNECTED_LED_PIN_Bit);
00007a  2106              MOVS     r1,#6
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       pin_out_init
;;;498        CONNECTED_LED_PORT->BSRR = CONNECTED_LED_PIN;
000082  2040              MOVS     r0,#0x40
000084  6020              STR      r0,[r4,#0]
;;;499    }
000086  bd38              POP      {r3-r5,pc}
;;;500    
                          ENDP

                  |L5.136|
                          DCD      0x40021000
                  |L5.140|
                          DCD      0x40010c00

                          AREA ||i.DAP_SWD_Transfer||, CODE, READONLY, ALIGN=2

                  DAP_SWD_Transfer PROC
;;;647    #if (DAP_SWD != 0)
;;;648    static uint32_t DAP_SWD_Transfer(const uint8_t *request, uint8_t *response) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
;;;649      const
;;;650      uint8_t  *request_head;
;;;651      uint32_t  request_count;
;;;652      uint32_t  request_value;
;;;653      uint8_t  *response_head;
;;;654      uint32_t  response_count;
;;;655      uint32_t  response_value;
;;;656      uint32_t  post_read;
;;;657      uint32_t  check_write;
;;;658      uint32_t  match_value;
;;;659      uint32_t  match_retry;
;;;660      uint32_t  retry;
;;;661      uint32_t  data;
;;;662    
;;;663      request_head   = request;
;;;664    
;;;665      response_count = 0U;
000008  9005              STR      r0,[sp,#0x14]
00000a  2000              MOVS     r0,#0
;;;666      response_value = 0U;
;;;667      response_head  = response;
;;;668      response      += 2;
;;;669    
;;;670      DAP_TransferAbort = 0U;
00000c  f8dfa2ec          LDR      r10,|L6.764|
000010  e9cd0101          STRD     r0,r1,[sp,#4]
000014  1c8d              ADDS     r5,r1,#2              ;667
000016  f88a0000          STRB     r0,[r10,#0]
;;;671    
;;;672      post_read   = 0U;
;;;673      check_write = 0U;
;;;674    
;;;675      request++;            // Ignore DAP index
;;;676    
;;;677      request_count = *request++;
00001a  9003              STR      r0,[sp,#0xc]
00001c  7866              LDRB     r6,[r4,#1]
00001e  1ca4              ADDS     r4,r4,#2
000020  4680              MOV      r8,r0                 ;672
;;;678    
;;;679      for (; request_count; request_count--) {
000022  2e00              CMP      r6,#0
000024  d07e              BEQ      |L6.292|
                  |L6.38|
;;;680        request_value = *request++;
000026  f8149b01          LDRB     r9,[r4],#1
;;;681        if (request_value & DAP_TRANSFER_RnW) {
00002a  ea5f7189          LSLS     r1,r9,#30
00002e  d57a              BPL      |L6.294|
;;;682          // Read register
;;;683          if (post_read) {
000030  f1b80f00          CMP      r8,#0
000034  d031              BEQ      |L6.154|
;;;684            // Read was posted before
;;;685            retry = DAP_Data.transfer.retry_count;
000036  48b2              LDR      r0,|L6.768|
000038  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
;;;686            if ((request_value & (DAP_TRANSFER_APnDP | DAP_TRANSFER_MATCH_VALUE)) == DAP_TRANSFER_APnDP) {
00003a  f0090011          AND      r0,r9,#0x11
00003e  2801              CMP      r0,#1
000040  d10c              BNE      |L6.92|
                  |L6.66|
;;;687              // Read previous AP data and post next AP read
;;;688              do {
;;;689                response_value = SWD_Transfer(request_value, &data);
000042  4669              MOV      r1,sp
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       SWD_Transfer
;;;690              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00004a  2802              CMP      r0,#2
00004c  d114              BNE      |L6.120|
00004e  1e7f              SUBS     r7,r7,#1
000050  d303              BCC      |L6.90|
000052  f89a1000          LDRB     r1,[r10,#0]  ; DAP_TransferAbort
000056  2900              CMP      r1,#0
000058  d0f3              BEQ      |L6.66|
                  |L6.90|
00005a  e0ff              B        |L6.604|
                  |L6.92|
;;;691            } else {
;;;692              // Read previous AP data
;;;693              do {
;;;694                response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
00005c  4669              MOV      r1,sp
00005e  200e              MOVS     r0,#0xe
000060  f7fffffe          BL       SWD_Transfer
;;;695              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000064  2802              CMP      r0,#2
000066  d105              BNE      |L6.116|
000068  1e7f              SUBS     r7,r7,#1
00006a  d303              BCC      |L6.116|
00006c  f89a1000          LDRB     r1,[r10,#0]  ; DAP_TransferAbort
000070  2900              CMP      r1,#0
000072  d0f3              BEQ      |L6.92|
                  |L6.116|
;;;696              post_read = 0U;
000074  f04f0800          MOV      r8,#0
                  |L6.120|
;;;697            }
;;;698            if (response_value != DAP_TRANSFER_OK) { break; }
000078  2801              CMP      r0,#1
00007a  d1ee              BNE      |L6.90|
;;;699            // Store previous AP data
;;;700            *response++ = (uint8_t) data;
00007c  9900              LDR      r1,[sp,#0]
00007e  f8051b01          STRB     r1,[r5],#1
;;;701            *response++ = (uint8_t)(data >>  8);
000082  9900              LDR      r1,[sp,#0]
000084  0a09              LSRS     r1,r1,#8
000086  f8051b01          STRB     r1,[r5],#1
;;;702            *response++ = (uint8_t)(data >> 16);
00008a  9900              LDR      r1,[sp,#0]
00008c  0c09              LSRS     r1,r1,#16
00008e  f8051b02          STRB     r1,[r5],#2
;;;703            *response++ = (uint8_t)(data >> 24);
000092  9900              LDR      r1,[sp,#0]
000094  0e09              LSRS     r1,r1,#24
000096  f8051c01          STRB     r1,[r5,#-1]
                  |L6.154|
;;;704          }
;;;705          if (request_value & DAP_TRANSFER_MATCH_VALUE) {
00009a  ea5f61c9          LSLS     r1,r9,#27
00009e  d54e              BPL      |L6.318|
;;;706            // Read with value match
;;;707            match_value = (*(request+0) <<  0) |
0000a0  78e7              LDRB     r7,[r4,#3]
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       __aeabi_uread4
0000a8  f367601f          BFI      r0,r7,#24,#8
;;;708                          (*(request+1) <<  8) |
;;;709                          (*(request+2) << 16) |
;;;710                          (*(request+3) << 24);
;;;711            request += 4;
;;;712            match_retry = DAP_Data.transfer.match_retry;
0000ac  9004              STR      r0,[sp,#0x10]
0000ae  4894              LDR      r0,|L6.768|
0000b0  1d24              ADDS     r4,r4,#4
0000b2  f8b0b00c          LDRH     r11,[r0,#0xc]  ; DAP_Data
;;;713            if (request_value & DAP_TRANSFER_APnDP) {
0000b6  ea5f70c9          LSLS     r0,r9,#31
0000ba  d011              BEQ      |L6.224|
;;;714              // Post AP read
;;;715              retry = DAP_Data.transfer.retry_count;
0000bc  4890              LDR      r0,|L6.768|
0000be  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L6.192|
;;;716              do {
;;;717                response_value = SWD_Transfer(request_value, NULL);
0000c0  2100              MOVS     r1,#0
0000c2  4648              MOV      r0,r9
0000c4  f7fffffe          BL       SWD_Transfer
;;;718              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000c8  2802              CMP      r0,#2
0000ca  d002              BEQ      |L6.210|
;;;719              if (response_value != DAP_TRANSFER_OK) { break; }
0000cc  2801              CMP      r0,#1
0000ce  d106              BNE      |L6.222|
0000d0  e006              B        |L6.224|
                  |L6.210|
0000d2  1e7f              SUBS     r7,r7,#1
0000d4  d303              BCC      |L6.222|
0000d6  f89a1000          LDRB     r1,[r10,#0]           ;718  ; DAP_TransferAbort
0000da  2900              CMP      r1,#0                 ;718
0000dc  d0f0              BEQ      |L6.192|
                  |L6.222|
0000de  e0bd              B        |L6.604|
                  |L6.224|
;;;720            }
;;;721            do {
;;;722              // Read register until its value matches or retry counter expires
;;;723              retry = DAP_Data.transfer.retry_count;
0000e0  4887              LDR      r0,|L6.768|
0000e2  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L6.228|
;;;724              do {
;;;725                response_value = SWD_Transfer(request_value, &data);
0000e4  4669              MOV      r1,sp
0000e6  4648              MOV      r0,r9
0000e8  f7fffffe          BL       SWD_Transfer
;;;726              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000ec  2802              CMP      r0,#2
0000ee  d002              BEQ      |L6.246|
;;;727              if (response_value != DAP_TRANSFER_OK) { break; }
0000f0  2801              CMP      r0,#1
0000f2  d115              BNE      |L6.288|
0000f4  e006              B        |L6.260|
                  |L6.246|
0000f6  1e7f              SUBS     r7,r7,#1
0000f8  d312              BCC      |L6.288|
0000fa  f89a1000          LDRB     r1,[r10,#0]           ;726  ; DAP_TransferAbort
0000fe  2900              CMP      r1,#0                 ;726
000100  d0f0              BEQ      |L6.228|
000102  e00d              B        |L6.288|
                  |L6.260|
;;;728            } while (((data & DAP_Data.transfer.match_mask) != match_value) && match_retry-- && !DAP_TransferAbort);
000104  497e              LDR      r1,|L6.768|
000106  9a00              LDR      r2,[sp,#0]
000108  6909              LDR      r1,[r1,#0x10]  ; DAP_Data
00010a  4011              ANDS     r1,r1,r2
00010c  9a04              LDR      r2,[sp,#0x10]
00010e  4291              CMP      r1,r2
000110  d006              BEQ      |L6.288|
000112  f1bb0b01          SUBS     r11,r11,#1
000116  d303              BCC      |L6.288|
000118  f89a1000          LDRB     r1,[r10,#0]  ; DAP_TransferAbort
00011c  2900              CMP      r1,#0
00011e  d0df              BEQ      |L6.224|
                  |L6.288|
;;;729            if ((data & DAP_Data.transfer.match_mask) != match_value) {
000120  4977              LDR      r1,|L6.768|
000122  e001              B        |L6.296|
                  |L6.292|
000124  e0ba              B        |L6.668|
                  |L6.294|
000126  e046              B        |L6.438|
                  |L6.296|
000128  6909              LDR      r1,[r1,#0x10]  ; DAP_Data
00012a  9a00              LDR      r2,[sp,#0]
00012c  4011              ANDS     r1,r1,r2
00012e  9a04              LDR      r2,[sp,#0x10]
000130  4291              CMP      r1,r2
000132  d001              BEQ      |L6.312|
;;;730              response_value |= DAP_TRANSFER_MISMATCH;
000134  f0400010          ORR      r0,r0,#0x10
                  |L6.312|
;;;731            }
;;;732            if (response_value != DAP_TRANSFER_OK) { break; }
000138  2801              CMP      r0,#1
00013a  d117              BNE      |L6.364|
00013c  e039              B        |L6.434|
                  |L6.318|
;;;733          } else {
;;;734            // Normal read
;;;735            retry = DAP_Data.transfer.retry_count;
00013e  4970              LDR      r1,|L6.768|
000140  894f              LDRH     r7,[r1,#0xa]  ; DAP_Data
;;;736            if (request_value & DAP_TRANSFER_APnDP) {
000142  ea5f71c9          LSLS     r1,r9,#31
000146  d015              BEQ      |L6.372|
;;;737              // Read AP register
;;;738              if (post_read == 0U) {
000148  f1b80f00          CMP      r8,#0
00014c  d131              BNE      |L6.434|
                  |L6.334|
;;;739                // Post AP read
;;;740                do {
;;;741                  response_value = SWD_Transfer(request_value, NULL);
00014e  2100              MOVS     r1,#0
000150  4648              MOV      r0,r9
000152  f7fffffe          BL       SWD_Transfer
;;;742                } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000156  2802              CMP      r0,#2
000158  d002              BEQ      |L6.352|
;;;743                if (response_value != DAP_TRANSFER_OK) { break; }
00015a  2801              CMP      r0,#1
00015c  d17e              BNE      |L6.604|
00015e  e006              B        |L6.366|
                  |L6.352|
000160  1e7f              SUBS     r7,r7,#1
000162  d37b              BCC      |L6.604|
000164  f89a1000          LDRB     r1,[r10,#0]           ;742  ; DAP_TransferAbort
000168  2900              CMP      r1,#0                 ;742
00016a  d0f0              BEQ      |L6.334|
                  |L6.364|
00016c  e076              B        |L6.604|
                  |L6.366|
;;;744                post_read = 1U;
00016e  f04f0801          MOV      r8,#1
000172  e01e              B        |L6.434|
                  |L6.372|
;;;745              }
;;;746            } else {
;;;747              // Read DP register
;;;748              do {
;;;749                response_value = SWD_Transfer(request_value, &data);
000174  4669              MOV      r1,sp
000176  4648              MOV      r0,r9
000178  f7fffffe          BL       SWD_Transfer
;;;750              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00017c  2802              CMP      r0,#2
00017e  d002              BEQ      |L6.390|
;;;751              if (response_value != DAP_TRANSFER_OK) { break; }
000180  2801              CMP      r0,#1
000182  d16b              BNE      |L6.604|
000184  e006              B        |L6.404|
                  |L6.390|
000186  1e7f              SUBS     r7,r7,#1
000188  d368              BCC      |L6.604|
00018a  f89a1000          LDRB     r1,[r10,#0]           ;750  ; DAP_TransferAbort
00018e  2900              CMP      r1,#0                 ;750
000190  d0f0              BEQ      |L6.372|
000192  e063              B        |L6.604|
                  |L6.404|
;;;752              // Store data
;;;753              *response++ = (uint8_t) data;
000194  9900              LDR      r1,[sp,#0]
000196  f8051b01          STRB     r1,[r5],#1
;;;754              *response++ = (uint8_t)(data >>  8);
00019a  9900              LDR      r1,[sp,#0]
00019c  0a09              LSRS     r1,r1,#8
00019e  f8051b01          STRB     r1,[r5],#1
;;;755              *response++ = (uint8_t)(data >> 16);
0001a2  9900              LDR      r1,[sp,#0]
0001a4  0c09              LSRS     r1,r1,#16
0001a6  f8051b02          STRB     r1,[r5],#2
;;;756              *response++ = (uint8_t)(data >> 24);
0001aa  9900              LDR      r1,[sp,#0]
0001ac  0e09              LSRS     r1,r1,#24
0001ae  f8051c01          STRB     r1,[r5,#-1]
                  |L6.434|
;;;757            }
;;;758          }
;;;759          check_write = 0U;
0001b2  2100              MOVS     r1,#0
0001b4  e047              B        |L6.582|
                  |L6.438|
;;;760        } else {
;;;761          // Write register
;;;762          if (post_read) {
0001b6  f1b80f00          CMP      r8,#0
0001ba  d022              BEQ      |L6.514|
;;;763            // Read previous data
;;;764            retry = DAP_Data.transfer.retry_count;
0001bc  4850              LDR      r0,|L6.768|
0001be  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L6.448|
;;;765            do {
;;;766              response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
0001c0  4669              MOV      r1,sp
0001c2  200e              MOVS     r0,#0xe
0001c4  f7fffffe          BL       SWD_Transfer
;;;767            } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0001c8  2802              CMP      r0,#2
0001ca  d002              BEQ      |L6.466|
;;;768            if (response_value != DAP_TRANSFER_OK) { break; }
0001cc  2801              CMP      r0,#1
0001ce  d145              BNE      |L6.604|
0001d0  e006              B        |L6.480|
                  |L6.466|
0001d2  1e7f              SUBS     r7,r7,#1
0001d4  d342              BCC      |L6.604|
0001d6  f89a1000          LDRB     r1,[r10,#0]           ;767  ; DAP_TransferAbort
0001da  2900              CMP      r1,#0                 ;767
0001dc  d0f0              BEQ      |L6.448|
0001de  e03d              B        |L6.604|
                  |L6.480|
;;;769            // Store previous data
;;;770            *response++ = (uint8_t) data;
0001e0  9800              LDR      r0,[sp,#0]
0001e2  f8050b01          STRB     r0,[r5],#1
;;;771            *response++ = (uint8_t)(data >>  8);
0001e6  9800              LDR      r0,[sp,#0]
;;;772            *response++ = (uint8_t)(data >> 16);
;;;773            *response++ = (uint8_t)(data >> 24);
;;;774            post_read = 0U;
0001e8  f04f0800          MOV      r8,#0
0001ec  0a00              LSRS     r0,r0,#8              ;771
0001ee  f8050b01          STRB     r0,[r5],#1            ;771
0001f2  9800              LDR      r0,[sp,#0]            ;772
0001f4  0c00              LSRS     r0,r0,#16             ;772
0001f6  f8050b02          STRB     r0,[r5],#2            ;772
0001fa  9800              LDR      r0,[sp,#0]            ;773
0001fc  0e00              LSRS     r0,r0,#24             ;773
0001fe  f8050c01          STRB     r0,[r5,#-1]           ;773
                  |L6.514|
;;;775          }
;;;776          // Load data
;;;777          data = (*(request+0) <<  0) |
000202  78e7              LDRB     r7,[r4,#3]
000204  4620              MOV      r0,r4
000206  f7fffffe          BL       __aeabi_uread4
00020a  f367601f          BFI      r0,r7,#24,#8
00020e  1d24              ADDS     r4,r4,#4
;;;778                 (*(request+1) <<  8) |
;;;779                 (*(request+2) << 16) |
;;;780                 (*(request+3) << 24);
;;;781          request += 4;
;;;782          if (request_value & DAP_TRANSFER_MATCH_MASK) {
000210  9000              STR      r0,[sp,#0]
000212  ea5f6189          LSLS     r1,r9,#26
000216  d503              BPL      |L6.544|
;;;783            // Write match mask
;;;784            DAP_Data.transfer.match_mask = data;
000218  4939              LDR      r1,|L6.768|
;;;785            response_value = DAP_TRANSFER_OK;
00021a  6108              STR      r0,[r1,#0x10]  ; DAP_Data
00021c  2001              MOVS     r0,#1
00021e  e013              B        |L6.584|
                  |L6.544|
;;;786          } else {
;;;787            // Write DP/AP register
;;;788            retry = DAP_Data.transfer.retry_count;
000220  4837              LDR      r0,|L6.768|
000222  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L6.548|
;;;789            do {
;;;790              response_value = SWD_Transfer(request_value, &data);
000224  4669              MOV      r1,sp
000226  4648              MOV      r0,r9
000228  f7fffffe          BL       SWD_Transfer
;;;791            } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00022c  2802              CMP      r0,#2
00022e  d002              BEQ      |L6.566|
;;;792            if (response_value != DAP_TRANSFER_OK) { break; }
000230  2801              CMP      r0,#1
000232  d113              BNE      |L6.604|
000234  e006              B        |L6.580|
                  |L6.566|
000236  1e7f              SUBS     r7,r7,#1
000238  d310              BCC      |L6.604|
00023a  f89a1000          LDRB     r1,[r10,#0]           ;791  ; DAP_TransferAbort
00023e  2900              CMP      r1,#0                 ;791
000240  d0f0              BEQ      |L6.548|
000242  e00b              B        |L6.604|
                  |L6.580|
;;;793            check_write = 1U;
000244  2101              MOVS     r1,#1
                  |L6.582|
000246  9103              STR      r1,[sp,#0xc]
                  |L6.584|
;;;794          }
;;;795        }
;;;796        response_count++;
000248  9901              LDR      r1,[sp,#4]
00024a  1c49              ADDS     r1,r1,#1
;;;797        if (DAP_TransferAbort) { break; }
00024c  9101              STR      r1,[sp,#4]
00024e  f89a1000          LDRB     r1,[r10,#0]  ; DAP_TransferAbort
000252  b919              CBNZ     r1,|L6.604|
000254  1e76              SUBS     r6,r6,#1
000256  f47faee6          BNE      |L6.38|
00025a  e009              B        |L6.624|
                  |L6.604|
;;;798      }
;;;799    
;;;800      for (; request_count; request_count--) {
00025c  b146              CBZ      r6,|L6.624|
;;;801        // Process canceled requests
;;;802        request_value = *request++;
00025e  f8141b01          LDRB     r1,[r4],#1
;;;803        if (request_value & DAP_TRANSFER_RnW) {
000262  078a              LSLS     r2,r1,#30
000264  d501              BPL      |L6.618|
;;;804          // Read register
;;;805          if (request_value & DAP_TRANSFER_MATCH_VALUE) {
000266  06c9              LSLS     r1,r1,#27
000268  d500              BPL      |L6.620|
                  |L6.618|
00026a  1d24              ADDS     r4,r4,#4
                  |L6.620|
00026c  1e76              SUBS     r6,r6,#1
00026e  e7f5              B        |L6.604|
                  |L6.624|
;;;806            // Read with value match
;;;807            request += 4;
;;;808          }
;;;809        } else {
;;;810          // Write register
;;;811          request += 4;
;;;812        }
;;;813      }
;;;814    
;;;815      if (response_value == DAP_TRANSFER_OK) {
000270  2801              CMP      r0,#1
000272  d134              BNE      |L6.734|
;;;816        if (post_read) {
000274  f1b80f00          CMP      r8,#0
000278  d021              BEQ      |L6.702|
;;;817          // Read previous data
;;;818          retry = DAP_Data.transfer.retry_count;
00027a  4821              LDR      r0,|L6.768|
00027c  4657              MOV      r7,r10                ;670
00027e  8946              LDRH     r6,[r0,#0xa]  ; DAP_Data
                  |L6.640|
;;;819          do {
;;;820            response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
000280  4669              MOV      r1,sp
000282  200e              MOVS     r0,#0xe
000284  f7fffffe          BL       SWD_Transfer
;;;821          } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000288  2802              CMP      r0,#2
00028a  d002              BEQ      |L6.658|
;;;822          if (response_value != DAP_TRANSFER_OK) { goto end; }
00028c  2801              CMP      r0,#1
00028e  d126              BNE      |L6.734|
000290  e005              B        |L6.670|
                  |L6.658|
000292  1e76              SUBS     r6,r6,#1
000294  d323              BCC      |L6.734|
000296  7839              LDRB     r1,[r7,#0]            ;821  ; DAP_TransferAbort
000298  2900              CMP      r1,#0                 ;821
00029a  d0f1              BEQ      |L6.640|
                  |L6.668|
00029c  e01f              B        |L6.734|
                  |L6.670|
;;;823          // Store previous data
;;;824          *response++ = (uint8_t) data;
00029e  9900              LDR      r1,[sp,#0]
0002a0  f8051b01          STRB     r1,[r5],#1
;;;825          *response++ = (uint8_t)(data >>  8);
0002a4  9900              LDR      r1,[sp,#0]
0002a6  0a09              LSRS     r1,r1,#8
0002a8  f8051b01          STRB     r1,[r5],#1
;;;826          *response++ = (uint8_t)(data >> 16);
0002ac  9900              LDR      r1,[sp,#0]
0002ae  0c09              LSRS     r1,r1,#16
0002b0  f8051b02          STRB     r1,[r5],#2
;;;827          *response++ = (uint8_t)(data >> 24);
0002b4  9900              LDR      r1,[sp,#0]
0002b6  0e09              LSRS     r1,r1,#24
0002b8  f8051c01          STRB     r1,[r5,#-1]
0002bc  e00f              B        |L6.734|
                  |L6.702|
;;;828        } else if (check_write) {
0002be  9903              LDR      r1,[sp,#0xc]
0002c0  b169              CBZ      r1,|L6.734|
;;;829          // Check last write
;;;830          retry = DAP_Data.transfer.retry_count;
0002c2  480f              LDR      r0,|L6.768|
0002c4  4657              MOV      r7,r10                ;670
0002c6  8946              LDRH     r6,[r0,#0xa]  ; DAP_Data
                  |L6.712|
;;;831          do {
;;;832            response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
0002c8  2100              MOVS     r1,#0
0002ca  200e              MOVS     r0,#0xe
0002cc  f7fffffe          BL       SWD_Transfer
;;;833          } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0002d0  2802              CMP      r0,#2
0002d2  d104              BNE      |L6.734|
0002d4  1e76              SUBS     r6,r6,#1
0002d6  d302              BCC      |L6.734|
0002d8  7839              LDRB     r1,[r7,#0]  ; DAP_TransferAbort
0002da  2900              CMP      r1,#0
0002dc  d0f4              BEQ      |L6.712|
                  |L6.734|
0002de  e9dd1201          LDRD     r1,r2,[sp,#4]
;;;834        }
;;;835      }
;;;836    
;;;837    end:
;;;838      *(response_head+0) = (uint8_t)response_count;
0002e2  7011              STRB     r1,[r2,#0]
;;;839      *(response_head+1) = (uint8_t)response_value;
0002e4  9902              LDR      r1,[sp,#8]
0002e6  7048              STRB     r0,[r1,#1]
;;;840    
;;;841      return (((request - request_head) << 16) | (response - response_head));
0002e8  9802              LDR      r0,[sp,#8]
0002ea  1a29              SUBS     r1,r5,r0
0002ec  9805              LDR      r0,[sp,#0x14]
;;;842    }
0002ee  b007              ADD      sp,sp,#0x1c
0002f0  1a20              SUBS     r0,r4,r0              ;841
0002f2  ea414000          ORR      r0,r1,r0,LSL #16      ;841
0002f6  e8bd8ff0          POP      {r4-r11,pc}
;;;843    #endif
                          ENDP

0002fa  0000              DCW      0x0000
                  |L6.764|
                          DCD      ||.data||
                  |L6.768|
                          DCD      ||.bss||

                          AREA ||i.DAP_SWD_TransferBlock||, CODE, READONLY, ALIGN=2

                  DAP_SWD_TransferBlock PROC
;;;1137   #if (DAP_SWD != 0)
;;;1138   static uint32_t DAP_SWD_TransferBlock(const uint8_t *request, uint8_t *response) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1139     uint32_t  request_count;
;;;1140     uint32_t  request_value;
;;;1141     uint32_t  response_count;
;;;1142     uint32_t  response_value;
;;;1143     uint8_t  *response_head;
;;;1144     uint32_t  retry;
;;;1145     uint32_t  data;
;;;1146   
;;;1147     response_count = 0U;
000004  2500              MOVS     r5,#0
;;;1148     response_value = 0U;
;;;1149     response_head  = response;
;;;1150     response      += 3;
;;;1151   
;;;1152     DAP_TransferAbort = 0U;
000006  f8dfb118          LDR      r11,|L7.288|
00000a  4602              MOV      r2,r0                 ;1138
00000c  4628              MOV      r0,r5                 ;1148
00000e  468a              MOV      r10,r1                ;1149
000010  1cce              ADDS     r6,r1,#3              ;1150
000012  f88b5000          STRB     r5,[r11,#0]
;;;1153   
;;;1154     request++;            // Ignore DAP index
;;;1155   
;;;1156     request_count = *request | (*(request+1) << 8);
000016  7891              LDRB     r1,[r2,#2]
000018  7853              LDRB     r3,[r2,#1]
00001a  1cd2              ADDS     r2,r2,#3
00001c  ea532401          ORRS     r4,r3,r1,LSL #8
000020  d073              BEQ      |L7.266|
;;;1157     request += 2;
;;;1158     if (request_count == 0U) { goto end; }
;;;1159   
;;;1160     request_value = *request++;
000022  f8129b01          LDRB     r9,[r2],#1
000026  4690              MOV      r8,r2
;;;1161     if (request_value & DAP_TRANSFER_RnW) {
000028  ea5f7189          LSLS     r1,r9,#30
00002c  d55d              BPL      |L7.234|
;;;1162       // Read register block
;;;1163       if (request_value & DAP_TRANSFER_APnDP) {
00002e  ea5f71c9          LSLS     r1,r9,#31
000032  d03a              BEQ      |L7.170|
;;;1164         // Post AP read
;;;1165         retry = DAP_Data.transfer.retry_count;
000034  483b              LDR      r0,|L7.292|
000036  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L7.56|
;;;1166         do {
;;;1167           response_value = SWD_Transfer(request_value, NULL);
000038  2100              MOVS     r1,#0
00003a  4648              MOV      r0,r9
00003c  f7fffffe          BL       SWD_Transfer
;;;1168         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000040  2802              CMP      r0,#2
000042  d002              BEQ      |L7.74|
;;;1169         if (response_value != DAP_TRANSFER_OK) { goto end; }
000044  2801              CMP      r0,#1
000046  d160              BNE      |L7.266|
000048  e02f              B        |L7.170|
                  |L7.74|
00004a  1e7f              SUBS     r7,r7,#1
00004c  d35d              BCC      |L7.266|
00004e  f89b1000          LDRB     r1,[r11,#0]           ;1168  ; DAP_TransferAbort
000052  2900              CMP      r1,#0                 ;1168
000054  d0f0              BEQ      |L7.56|
000056  e058              B        |L7.266|
                  |L7.88|
;;;1170       }
;;;1171       while (request_count--) {
;;;1172         // Read DP/AP register
;;;1173         if ((request_count == 0U) && (request_value & DAP_TRANSFER_APnDP)) {
000058  b924              CBNZ     r4,|L7.100|
00005a  ea5f70c9          LSLS     r0,r9,#31
00005e  d001              BEQ      |L7.100|
;;;1174           // Last AP read
;;;1175           request_value = DP_RDBUFF | DAP_TRANSFER_RnW;
000060  f04f090e          MOV      r9,#0xe
                  |L7.100|
;;;1176         }
;;;1177         retry = DAP_Data.transfer.retry_count;
000064  482f              LDR      r0,|L7.292|
000066  46d8              MOV      r8,r11                ;1152
000068  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L7.106|
;;;1178         do {
;;;1179           response_value = SWD_Transfer(request_value, &data);
00006a  4669              MOV      r1,sp
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       SWD_Transfer
;;;1180         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000072  2802              CMP      r0,#2
000074  d002              BEQ      |L7.124|
;;;1181         if (response_value != DAP_TRANSFER_OK) { goto end; }
000076  2801              CMP      r0,#1
000078  d147              BNE      |L7.266|
00007a  e006              B        |L7.138|
                  |L7.124|
00007c  1e7f              SUBS     r7,r7,#1
00007e  d344              BCC      |L7.266|
000080  f8981000          LDRB     r1,[r8,#0]            ;1180  ; DAP_TransferAbort
000084  2900              CMP      r1,#0                 ;1180
000086  d0f0              BEQ      |L7.106|
000088  e03f              B        |L7.266|
                  |L7.138|
;;;1182         // Store data
;;;1183         *response++ = (uint8_t) data;
00008a  9900              LDR      r1,[sp,#0]
00008c  f8061b01          STRB     r1,[r6],#1
;;;1184         *response++ = (uint8_t)(data >>  8);
000090  9900              LDR      r1,[sp,#0]
000092  0a09              LSRS     r1,r1,#8
000094  f8061b01          STRB     r1,[r6],#1
;;;1185         *response++ = (uint8_t)(data >> 16);
000098  9900              LDR      r1,[sp,#0]
00009a  0c09              LSRS     r1,r1,#16
00009c  f8061b02          STRB     r1,[r6],#2
;;;1186         *response++ = (uint8_t)(data >> 24);
0000a0  9900              LDR      r1,[sp,#0]
0000a2  0e09              LSRS     r1,r1,#24
0000a4  f8061c01          STRB     r1,[r6,#-1]
0000a8  1c6d              ADDS     r5,r5,#1
                  |L7.170|
0000aa  1e64              SUBS     r4,r4,#1
0000ac  d2d4              BCS      |L7.88|
0000ae  e02c              B        |L7.266|
                  |L7.176|
;;;1187         response_count++;
;;;1188       }
;;;1189     } else {
;;;1190       // Write register block
;;;1191       while (request_count--) {
;;;1192         // Load data
;;;1193         data = (*(request+0) <<  0) |
0000b0  4640              MOV      r0,r8
0000b2  f8987003          LDRB     r7,[r8,#3]
0000b6  f7fffffe          BL       __aeabi_uread4
0000ba  f367601f          BFI      r0,r7,#24,#8
;;;1194                (*(request+1) <<  8) |
;;;1195                (*(request+2) << 16) |
;;;1196                (*(request+3) << 24);
;;;1197         request += 4;
;;;1198         // Write DP/AP register
;;;1199         retry = DAP_Data.transfer.retry_count;
0000be  9000              STR      r0,[sp,#0]
0000c0  4818              LDR      r0,|L7.292|
0000c2  f1080804          ADD      r8,r8,#4              ;1197
0000c6  8947              LDRH     r7,[r0,#0xa]  ; DAP_Data
                  |L7.200|
;;;1200         do {
;;;1201           response_value = SWD_Transfer(request_value, &data);
0000c8  4669              MOV      r1,sp
0000ca  4648              MOV      r0,r9
0000cc  f7fffffe          BL       SWD_Transfer
;;;1202         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000d0  2802              CMP      r0,#2
0000d2  d002              BEQ      |L7.218|
;;;1203         if (response_value != DAP_TRANSFER_OK) { goto end; }
0000d4  2801              CMP      r0,#1
0000d6  d118              BNE      |L7.266|
0000d8  e006              B        |L7.232|
                  |L7.218|
0000da  1e7f              SUBS     r7,r7,#1
0000dc  d315              BCC      |L7.266|
0000de  f89b1000          LDRB     r1,[r11,#0]           ;1202  ; DAP_TransferAbort
0000e2  2900              CMP      r1,#0                 ;1202
0000e4  d0f0              BEQ      |L7.200|
0000e6  e010              B        |L7.266|
                  |L7.232|
0000e8  1c6d              ADDS     r5,r5,#1              ;1202
                  |L7.234|
0000ea  1e64              SUBS     r4,r4,#1              ;1202
0000ec  d2e0              BCS      |L7.176|
;;;1204         response_count++;
;;;1205       }
;;;1206       // Check last write
;;;1207       retry = DAP_Data.transfer.retry_count;
0000ee  480d              LDR      r0,|L7.292|
0000f0  465f              MOV      r7,r11                ;1152
0000f2  8944              LDRH     r4,[r0,#0xa]  ; DAP_Data
                  |L7.244|
;;;1208       do {
;;;1209         response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
0000f4  2100              MOVS     r1,#0
0000f6  200e              MOVS     r0,#0xe
0000f8  f7fffffe          BL       SWD_Transfer
;;;1210       } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000fc  2802              CMP      r0,#2
0000fe  d104              BNE      |L7.266|
000100  1e64              SUBS     r4,r4,#1
000102  d302              BCC      |L7.266|
000104  7839              LDRB     r1,[r7,#0]  ; DAP_TransferAbort
000106  2900              CMP      r1,#0
000108  d0f4              BEQ      |L7.244|
                  |L7.266|
;;;1211     }
;;;1212   
;;;1213   end:
;;;1214     *(response_head+0) = (uint8_t)(response_count >> 0);
00010a  f88a5000          STRB     r5,[r10,#0]
;;;1215     *(response_head+1) = (uint8_t)(response_count >> 8);
00010e  0a2a              LSRS     r2,r5,#8
000110  f88a2001          STRB     r2,[r10,#1]
;;;1216     *(response_head+2) = (uint8_t) response_value;
000114  f88a0002          STRB     r0,[r10,#2]
;;;1217   
;;;1218     return (response - response_head);
000118  eba6000a          SUB      r0,r6,r10
;;;1219   }
00011c  e8bd8ff8          POP      {r3-r11,pc}
;;;1220   #endif
                          ENDP

                  |L7.288|
                          DCD      ||.data||
                  |L7.292|
                          DCD      ||.bss||

                          AREA ||i.DAP_SWJ_Clock||, CODE, READONLY, ALIGN=2

                  DAP_SWJ_Clock PROC
;;;417    //             number of bytes in request (upper 16 bits)
;;;418    static uint32_t DAP_SWJ_Clock(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
;;;419    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;420      uint32_t clock;
;;;421      uint32_t delay;
;;;422    
;;;423      clock = (*(request+0) <<  0) |
000004  78c5              LDRB     r5,[r0,#3]
000006  f7fffffe          BL       __aeabi_uread4
00000a  f365601f          BFI      r0,r5,#24,#8
;;;424              (*(request+1) <<  8) |
;;;425              (*(request+2) << 16) |
;;;426              (*(request+3) << 24);
;;;427    
;;;428      if (clock == 0U) {
;;;429        *response = DAP_ERROR;
;;;430        return ((4U << 16) | 1U);
00000e  4d10              LDR      r5,|L8.80|
000010  b148              CBZ      r0,|L8.38|
;;;431      }
;;;432    
;;;433      if (clock >= MAX_SWJ_CLOCK(DELAY_FAST_CYCLES)) {
000012  4910              LDR      r1,|L8.84|
000014  2300              MOVS     r3,#0
;;;434        DAP_Data.fast_clock  = 1U;
000016  4a10              LDR      r2,|L8.88|
000018  6809              LDR      r1,[r1,#0]            ;433  ; SystemCoreClock
00001a  ebb00f91          CMP      r0,r1,LSR #2          ;433
00001e  d305              BCC      |L8.44|
000020  2001              MOVS     r0,#1
000022  7050              STRB     r0,[r2,#1]
;;;435        DAP_Data.clock_delay = 1U;
000024  e00f              B        |L8.70|
                  |L8.38|
000026  20ff              MOVS     r0,#0xff              ;429
000028  7020              STRB     r0,[r4,#0]            ;429
00002a  e00e              B        |L8.74|
                  |L8.44|
;;;436      } else {
;;;437        DAP_Data.fast_clock  = 0U;
;;;438    
;;;439        delay = ((CPU_CLOCK/2U) + (clock - 1U)) / clock;
00002c  eb000151          ADD      r1,r0,r1,LSR #1
000030  1e49              SUBS     r1,r1,#1
000032  fbb1f0f0          UDIV     r0,r1,r0
000036  7053              STRB     r3,[r2,#1]            ;437
;;;440        if (delay > IO_PORT_WRITE_CYCLES) {
000038  2802              CMP      r0,#2
00003a  d903              BLS      |L8.68|
;;;441          delay -= IO_PORT_WRITE_CYCLES;
;;;442          delay  = (delay + (DELAY_SLOW_CYCLES - 1U)) / DELAY_SLOW_CYCLES;
00003c  2103              MOVS     r1,#3
00003e  fbb0f0f1          UDIV     r0,r0,r1
000042  e000              B        |L8.70|
                  |L8.68|
;;;443        } else {
;;;444          delay  = 1U;
000044  2001              MOVS     r0,#1
                  |L8.70|
;;;445        }
;;;446    
;;;447        DAP_Data.clock_delay = delay;
;;;448      }
;;;449    
;;;450      *response = DAP_OK;
000046  6050              STR      r0,[r2,#4]  ; DAP_Data
000048  7023              STRB     r3,[r4,#0]
                  |L8.74|
;;;451    #else
;;;452      *response = DAP_ERROR;
;;;453    #endif
;;;454    
;;;455      return ((4U << 16) | 1U);
00004a  4628              MOV      r0,r5
;;;456    }
00004c  bd70              POP      {r4-r6,pc}
;;;457    
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0x00040001
                  |L8.84|
                          DCD      SystemCoreClock
                  |L8.88|
                          DCD      ||.bss||

                          AREA ||i.DAP_SWJ_Pins||, CODE, READONLY, ALIGN=2

                  DAP_SWJ_Pins PROC
;;;335    //             number of bytes in request (upper 16 bits)
;;;336    static uint32_t DAP_SWJ_Pins(const uint8_t *request, uint8_t *response) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;337    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;338      uint32_t value;
;;;339      uint32_t select;
;;;340      uint32_t wait;
;;;341      
;;;342      value  =  *(request+0);
000004  f8105b01          LDRB     r5,[r0],#1
000008  460e              MOV      r6,r1                 ;336
;;;343      select =  *(request+1); 
00000a  f8104b01          LDRB     r4,[r0],#1
;;;344      wait   = (*(request+2) <<  0) |
00000e  78c7              LDRB     r7,[r0,#3]
000010  f7fffffe          BL       __aeabi_uread4
000014  4938              LDR      r1,|L9.248|
000016  f367601f          BFI      r0,r7,#24,#8
;;;345               (*(request+3) <<  8) |
;;;346               (*(request+4) << 16) |
;;;347               (*(request+5) << 24);
;;;348    
;;;349      if (select & (1U << DAP_SWJ_SWCLK_TCK)) {
00001a  07e3              LSLS     r3,r4,#31
00001c  f1010204          ADD      r2,r1,#4
000020  d006              BEQ      |L9.48|
;;;350        if (value & (1U << DAP_SWJ_SWCLK_TCK)) {
000022  07ef              LSLS     r7,r5,#31
000024  f44f5300          MOV      r3,#0x2000
000028  d001              BEQ      |L9.46|
00002a  600b              STR      r3,[r1,#0]
;;;351          PIN_SWCLK_TCK_SET();
00002c  e000              B        |L9.48|
                  |L9.46|
00002e  6013              STR      r3,[r2,#0]
                  |L9.48|
;;;352        } else {
;;;353          PIN_SWCLK_TCK_CLR();
;;;354        }
;;;355      }
;;;356      if (select & (1U << DAP_SWJ_SWDIO_TMS)) {
000030  07a3              LSLS     r3,r4,#30
000032  d506              BPL      |L9.66|
;;;357        if (value & (1U << DAP_SWJ_SWDIO_TMS)) {
000034  07af              LSLS     r7,r5,#30
000036  f44f4380          MOV      r3,#0x4000
00003a  d501              BPL      |L9.64|
00003c  600b              STR      r3,[r1,#0]
;;;358          PIN_SWDIO_TMS_SET();
00003e  e000              B        |L9.66|
                  |L9.64|
000040  6013              STR      r3,[r2,#0]
                  |L9.66|
;;;359        } else {
;;;360          PIN_SWDIO_TMS_CLR();
;;;361        }
;;;362      }
;;;363      if (select & (1U << DAP_SWJ_TDI)) {
;;;364        PIN_TDI_OUT(value >> DAP_SWJ_TDI);
;;;365      }
;;;366      if (select & (1U << DAP_SWJ_nTRST)) {
;;;367        PIN_nTRST_OUT(value >> DAP_SWJ_nTRST);
;;;368      }
;;;369      if (select & (1U << DAP_SWJ_nRESET)) {
000042  0623              LSLS     r3,r4,#24
000044  d507              BPL      |L9.86|
;;;370        PIN_nRESET_OUT(value >> DAP_SWJ_nRESET);
000046  09eb              LSRS     r3,r5,#7
000048  07df              LSLS     r7,r3,#31
00004a  f04f0301          MOV      r3,#1
00004e  d001              BEQ      |L9.84|
000050  600b              STR      r3,[r1,#0]
000052  e000              B        |L9.86|
                  |L9.84|
000054  6013              STR      r3,[r2,#0]
                  |L9.86|
000056  f8dfc0a0          LDR      r12,|L9.248|
00005a  2700              MOVS     r7,#0
00005c  f1ac0c04          SUB      r12,r12,#4
000060  f1ac0304          SUB      r3,r12,#4
;;;371      }
;;;372    
;;;373      if (wait) {
000064  b3c0              CBZ      r0,|L9.216|
;;;374        if (wait > 3000000U) { wait = 3000000U; }
000066  4925              LDR      r1,|L9.252|
000068  4288              CMP      r0,r1
00006a  d900              BLS      |L9.110|
00006c  4608              MOV      r0,r1
                  |L9.110|
00006e  f04f22e0          MOV      r2,#0xe000e000
000072  6197              STR      r7,[r2,#0x18]
000074  4922              LDR      r1,|L9.256|
000076  f8dfe08c          LDR      lr,|L9.260|
00007a  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00007c  fbb1f1fe          UDIV     r1,r1,lr
000080  4341              MULS     r1,r0,r1
000082  6151              STR      r1,[r2,#0x14]
000084  2005              MOVS     r0,#5
000086  6110              STR      r0,[r2,#0x10]
                  |L9.136|
;;;375        TIMER_START(wait);
;;;376        do {
;;;377          if (select & (1U << DAP_SWJ_SWCLK_TCK)) {
000088  07e0              LSLS     r0,r4,#31
00008a  d005              BEQ      |L9.152|
00008c  f8dc0000          LDR      r0,[r12,#0]
000090  f3c03040          UBFX     r0,r0,#13,#1
;;;378            if ((value >> DAP_SWJ_SWCLK_TCK) ^ PIN_SWCLK_TCK_IN()) { continue; }
000094  42a8              CMP      r0,r5
000096  d119              BNE      |L9.204|
                  |L9.152|
;;;379          }
;;;380          if (select & (1U << DAP_SWJ_SWDIO_TMS)) {
000098  07a0              LSLS     r0,r4,#30
00009a  d505              BPL      |L9.168|
00009c  6818              LDR      r0,[r3,#0]
00009e  f3c03000          UBFX     r0,r0,#12,#1
;;;381            if ((value >> DAP_SWJ_SWDIO_TMS) ^ PIN_SWDIO_TMS_IN()) { continue; }
0000a2  ebb00f55          CMP      r0,r5,LSR #1
0000a6  d111              BNE      |L9.204|
                  |L9.168|
;;;382          }
;;;383          if (select & (1U << DAP_SWJ_TDI)) {
0000a8  0760              LSLS     r0,r4,#29
0000aa  d502              BPL      |L9.178|
;;;384            if ((value >> DAP_SWJ_TDI) ^ PIN_TDI_IN()) { continue; }
0000ac  ebb70f95          CMP      r7,r5,LSR #2
0000b0  d10c              BNE      |L9.204|
                  |L9.178|
;;;385          }
;;;386          if (select & (1U << DAP_SWJ_nTRST)) {
0000b2  06a0              LSLS     r0,r4,#26
0000b4  d502              BPL      |L9.188|
;;;387            if ((value >> DAP_SWJ_nTRST) ^ PIN_nTRST_IN()) { continue; }
0000b6  ebb71f55          CMP      r7,r5,LSR #5
0000ba  d107              BNE      |L9.204|
                  |L9.188|
;;;388          }
;;;389          if (select & (1U << DAP_SWJ_nRESET)) {
0000bc  0620              LSLS     r0,r4,#24
0000be  d50a              BPL      |L9.214|
0000c0  6818              LDR      r0,[r3,#0]
0000c2  f0000001          AND      r0,r0,#1
;;;390            if ((value >> DAP_SWJ_nRESET) ^ PIN_nRESET_IN()) { continue; }
0000c6  ebb01fd5          CMP      r0,r5,LSR #7
0000ca  d004              BEQ      |L9.214|
                  |L9.204|
0000cc  6910              LDR      r0,[r2,#0x10]
0000ce  f3c04000          UBFX     r0,r0,#16,#1
;;;391          }
;;;392          break;
;;;393        } while (!TIMER_EXPIRED());
0000d2  2800              CMP      r0,#0
0000d4  d0d8              BEQ      |L9.136|
                  |L9.214|
0000d6  6117              STR      r7,[r2,#0x10]
                  |L9.216|
0000d8  f8dc0000          LDR      r0,[r12,#0]
0000dc  6819              LDR      r1,[r3,#0]
0000de  f3c03040          UBFX     r0,r0,#13,#1
0000e2  f3c13100          UBFX     r1,r1,#12,#1
;;;394        TIMER_STOP();
;;;395      }
;;;396    
;;;397      value = (PIN_SWCLK_TCK_IN() << DAP_SWJ_SWCLK_TCK) |
0000e6  ea400041          ORR      r0,r0,r1,LSL #1
0000ea  6819              LDR      r1,[r3,#0]
0000ec  ea4010c1          ORR      r0,r0,r1,LSL #7
;;;398              (PIN_SWDIO_TMS_IN() << DAP_SWJ_SWDIO_TMS) |
;;;399              (PIN_TDI_IN()       << DAP_SWJ_TDI)       |
;;;400              (PIN_TDO_IN()       << DAP_SWJ_TDO)       |
;;;401              (PIN_nTRST_IN()     << DAP_SWJ_nTRST)     |
;;;402              (PIN_nRESET_IN()    << DAP_SWJ_nRESET);
;;;403    
;;;404      *response = (uint8_t)value;
0000f0  7030              STRB     r0,[r6,#0]
;;;405    #else
;;;406      *response = 0U;
;;;407    #endif
;;;408    
;;;409      return ((6U << 16) | 1U);
0000f2  4805              LDR      r0,|L9.264|
;;;410    }
0000f4  e8bd81f0          POP      {r4-r8,pc}
;;;411    
                          ENDP

                  |L9.248|
                          DCD      0x40010c10
                  |L9.252|
                          DCD      0x002dc6c0
                  |L9.256|
                          DCD      SystemCoreClock
                  |L9.260|
                          DCD      0x000f4240
                  |L9.264|
                          DCD      0x00060001

                          AREA ||i.DAP_Setup||, CODE, READONLY, ALIGN=2

                  DAP_Setup PROC
;;;1591   // Setup DAP
;;;1592   void DAP_Setup(void) {
000000  480a              LDR      r0,|L10.44|
;;;1593   
;;;1594     // Default settings
;;;1595     DAP_Data.debug_port  = 0U;
000002  2100              MOVS     r1,#0
;;;1596     DAP_Data.fast_clock  = 0U;
;;;1597     DAP_Data.clock_delay = CLOCK_DELAY(DAP_DEFAULT_SWJ_CLOCK);
000004  4a0a              LDR      r2,|L10.48|
000006  7001              STRB     r1,[r0,#0]            ;1595
000008  7041              STRB     r1,[r0,#1]            ;1596
00000a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00000c  4b09              LDR      r3,|L10.52|
00000e  fbb2f2f3          UDIV     r2,r2,r3
000012  1e92              SUBS     r2,r2,#2
;;;1598     DAP_Data.transfer.idle_cycles = 0U;
000014  6042              STR      r2,[r0,#4]  ; DAP_Data
000016  7201              STRB     r1,[r0,#8]
;;;1599     DAP_Data.transfer.retry_count = 100U;
000018  2264              MOVS     r2,#0x64
00001a  8142              STRH     r2,[r0,#0xa]
;;;1600     DAP_Data.transfer.match_retry = 0U;
00001c  8181              STRH     r1,[r0,#0xc]
;;;1601     DAP_Data.transfer.match_mask  = 0x00000000U;
;;;1602   #if (DAP_SWD != 0)
;;;1603     DAP_Data.swd_conf.turnaround  = 1U;
00001e  2201              MOVS     r2,#1
000020  6101              STR      r1,[r0,#0x10]  ; DAP_Data
000022  7502              STRB     r2,[r0,#0x14]
;;;1604     DAP_Data.swd_conf.data_phase  = 0U;
000024  7541              STRB     r1,[r0,#0x15]
;;;1605   #endif
;;;1606   #if (DAP_JTAG != 0)
;;;1607     DAP_Data.jtag_dev.count = 0U;
;;;1608   #endif
;;;1609   
;;;1610     DAP_SETUP();  // Device specific setup
000026  f7ffbffe          B.W      DAP_SETUP
;;;1611   }
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      ||.bss||
                  |L10.48|
                          DCD      SystemCoreClock
                  |L10.52|
                          DCD      0x00989680

                          AREA ||i.Delayms||, CODE, READONLY, ALIGN=2

                  Delayms PROC
;;;221    //    delay:  delay time in ms
;;;222    void Delayms(uint32_t delay) {
000000  4906              LDR      r1,|L11.28|
;;;223      delay *= ((CPU_CLOCK/1000U) + (DELAY_SLOW_CYCLES-1U)) / DELAY_SLOW_CYCLES;
000002  f44f727a          MOV      r2,#0x3e8
000006  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000008  fbb1f1f2          UDIV     r1,r1,r2
00000c  2203              MOVS     r2,#3
00000e  1c89              ADDS     r1,r1,#2
000010  fbb1f1f2          UDIV     r1,r1,r2
000014  4341              MULS     r1,r0,r1
                  |L11.22|
000016  1e49              SUBS     r1,r1,#1
000018  d1fd              BNE      |L11.22|
;;;224      PIN_DELAY_SLOW(delay);
;;;225    }
00001a  4770              BX       lr
;;;226    
                          ENDP

                  |L11.28|
                          DCD      SystemCoreClock

                          AREA ||i.pin_in_init||, CODE, READONLY, ALIGN=1

                  pin_in_init PROC
;;;144    
;;;145    static __inline void pin_in_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit, uint8_t mode)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
;;;147        uint8_t config;
;;;148        if(mode == 1)
000002  2a01              CMP      r2,#1
000004  d012              BEQ      |L12.44|
;;;149            config = 0x08; //Up
;;;150        else if(mode == 2)
000006  2a02              CMP      r2,#2
000008  d010              BEQ      |L12.44|
;;;151            config = 0x08; //down
;;;152        else
;;;153            config = 0x00; //GPIO_Mode_AIN
00000a  2300              MOVS     r3,#0
                  |L12.12|
00000c  2401              MOVS     r4,#1                 ;146
;;;154    
;;;155        if(pin_bit >= 8)
;;;156        {
;;;157            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
;;;158            GPIOx->CRH |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit-8) << 2) );
;;;159            if(mode == 1)
;;;160                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
00000e  408c              LSLS     r4,r4,r1
000010  260f              MOVS     r6,#0xf               ;157
000012  008d              LSLS     r5,r1,#2              ;157
000014  2908              CMP      r1,#8                 ;155
000016  d311              BCC      |L12.60|
000018  3d20              SUBS     r5,r5,#0x20           ;155
00001a  6841              LDR      r1,[r0,#4]            ;157
00001c  40ae              LSLS     r6,r6,r5              ;157
00001e  43b1              BICS     r1,r1,r6              ;157
000020  6041              STR      r1,[r0,#4]            ;157
000022  6841              LDR      r1,[r0,#4]            ;158
000024  40ab              LSLS     r3,r3,r5              ;158
000026  430b              ORRS     r3,r3,r1              ;158
000028  6043              STR      r3,[r0,#4]            ;158
00002a  e00f              B        |L12.76|
                  |L12.44|
00002c  2308              MOVS     r3,#8                 ;151
00002e  e7ed              B        |L12.12|
                  |L12.48|
000030  6104              STR      r4,[r0,#0x10]
                  |L12.50|
;;;161            else if(mode == 2)
;;;162                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;163        }
;;;164        else
;;;165        {
;;;166            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;167            GPIOx->CRL |= ( ((uint32_t)(config) & 0x0F) << ((pin_bit) << 2) );
;;;168            if(mode == 1)
;;;169                GPIOx->BSRR = (((uint32_t)0x01) << pin_bit);
;;;170            else if(mode == 2)
;;;171                GPIOx->BRR = (((uint32_t)0x01) << pin_bit);
;;;172        }
;;;173    }
000032  bd70              POP      {r4-r6,pc}
                  |L12.52|
000034  2a02              CMP      r2,#2                 ;161
000036  d1fc              BNE      |L12.50|
000038  6144              STR      r4,[r0,#0x14]         ;162
00003a  bd70              POP      {r4-r6,pc}
                  |L12.60|
00003c  6801              LDR      r1,[r0,#0]            ;166
00003e  40ae              LSLS     r6,r6,r5              ;166
000040  43b1              BICS     r1,r1,r6              ;166
000042  6001              STR      r1,[r0,#0]            ;166
000044  6801              LDR      r1,[r0,#0]            ;167
000046  40ab              LSLS     r3,r3,r5              ;167
000048  430b              ORRS     r3,r3,r1              ;167
00004a  6003              STR      r3,[r0,#0]            ;167
                  |L12.76|
00004c  2a01              CMP      r2,#1                 ;168
00004e  d1f1              BNE      |L12.52|
000050  e7ee              B        |L12.48|
;;;174    //**************************************************************************************************
                          ENDP


                          AREA ||i.pin_out_init||, CODE, READONLY, ALIGN=1

                  pin_out_init PROC
;;;116    
;;;117    static __inline void pin_out_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119        if(pin_bit >= 8)
;;;120        {
;;;121            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
000002  230f              MOVS     r3,#0xf
;;;122            GPIOx->CRH |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit-8) << 2) );
000004  2403              MOVS     r4,#3
000006  008a              LSLS     r2,r1,#2              ;121
000008  2908              CMP      r1,#8                 ;119
00000a  d309              BCC      |L13.32|
00000c  3a20              SUBS     r2,r2,#0x20           ;118
00000e  6841              LDR      r1,[r0,#4]            ;121
000010  4093              LSLS     r3,r3,r2              ;121
000012  4399              BICS     r1,r1,r3              ;121
000014  6041              STR      r1,[r0,#4]            ;121
000016  6841              LDR      r1,[r0,#4]
000018  4094              LSLS     r4,r4,r2
00001a  430c              ORRS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
;;;123        }
;;;124        else
;;;125        {
;;;126            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;127            GPIOx->CRL |= ( ((uint32_t)(0x00|0x03) & 0x0F) << ((pin_bit) << 2) );
;;;128        }
;;;129    }
00001e  bd10              POP      {r4,pc}
                  |L13.32|
000020  6801              LDR      r1,[r0,#0]            ;126
000022  4093              LSLS     r3,r3,r2              ;126
000024  4399              BICS     r1,r1,r3              ;126
000026  6001              STR      r1,[r0,#0]            ;126
000028  6801              LDR      r1,[r0,#0]            ;127
00002a  4094              LSLS     r4,r4,r2              ;127
00002c  4321              ORRS     r1,r1,r4              ;127
00002e  6001              STR      r1,[r0,#0]            ;127
000030  bd10              POP      {r4,pc}
;;;130    
                          ENDP


                          AREA ||i.pin_out_od_init||, CODE, READONLY, ALIGN=1

                  pin_out_od_init PROC
;;;130    
;;;131    static __inline void pin_out_od_init(GPIO_TypeDef* GPIOx, uint8_t pin_bit)
000000  b510              PUSH     {r4,lr}
;;;132    {
;;;133        if(pin_bit >= 8)
;;;134        {
;;;135            GPIOx->CRH &= ~(0x0000000F << ((pin_bit-8) << 2));
000002  230f              MOVS     r3,#0xf
;;;136            GPIOx->CRH |= ( ((uint32_t)(0x04|0x03) & 0x0F) << ((pin_bit-8) << 2) );
000004  2407              MOVS     r4,#7
000006  008a              LSLS     r2,r1,#2              ;135
000008  2908              CMP      r1,#8                 ;133
00000a  d309              BCC      |L14.32|
00000c  3a20              SUBS     r2,r2,#0x20           ;132
00000e  6841              LDR      r1,[r0,#4]            ;135
000010  4093              LSLS     r3,r3,r2              ;135
000012  4399              BICS     r1,r1,r3              ;135
000014  6041              STR      r1,[r0,#4]            ;135
000016  6841              LDR      r1,[r0,#4]
000018  4094              LSLS     r4,r4,r2
00001a  430c              ORRS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
;;;137        }
;;;138        else
;;;139        {
;;;140            GPIOx->CRL &= ~(0x0000000F << ((pin_bit) << 2));
;;;141            GPIOx->CRL |= ( ((uint32_t)(0x04|0x03) & 0x0F) << ((pin_bit) << 2) );
;;;142        }
;;;143    }
00001e  bd10              POP      {r4,pc}
                  |L14.32|
000020  6801              LDR      r1,[r0,#0]            ;140
000022  4093              LSLS     r3,r3,r2              ;140
000024  4399              BICS     r1,r1,r3              ;140
000026  6001              STR      r1,[r0,#0]            ;140
000028  6801              LDR      r1,[r0,#0]            ;141
00002a  4094              LSLS     r4,r4,r2              ;141
00002c  4321              ORRS     r1,r1,r4              ;141
00002e  6001              STR      r1,[r0,#0]            ;141
000030  bd10              POP      {r4,pc}
;;;144    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DAP_Data
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DAP_FW_Ver
000000  312e3130          DCB      0x31,0x2e,0x31,0x30
000004  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=0

                  DAP_TransferAbort
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\cmsis-dap\\DAP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_33658ade____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___5_DAP_c_33658ade____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_33658ade____REVSH|
#line 144
|__asm___5_DAP_c_33658ade____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
