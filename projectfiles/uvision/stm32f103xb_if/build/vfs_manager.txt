; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\build\vfs_manager.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\vfs_manager.d --cpu=Cortex-M3 --apcs=interwork --no_unaligned_access --diag_suppress=9931 -I..\..\..\source\usb -I..\..\..\source\daplink\cmsis-dap -I..\..\..\source\daplink\drag-n-drop -I..\..\..\source\daplink\usb2uart -I..\..\..\source\daplink\settings -I..\..\..\source\daplink -I..\..\..\source\daplink\interface -I..\..\..\source\cmsis-core -I..\..\..\source\hic_hal -I..\..\..\source\target -I..\..\..\source\rtos -I..\..\..\source\hic_hal\stm32\stm32f103xb -I..\..\..\source\hic_hal\stm32\stm32f103xb\cmsis -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver -I..\..\..\source\hic_hal\stm32\stm32f103xb\STM32F1xx_HAL_Driver\Inc -I.\RTE\_stm32f103xb_if -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DDAPLINK_VERSION=254 -DHID_ENDPOINT -DMSC_ENDPOINT -DCDC_ENDPOINT -DWEBUSB_INTERFACE -DWINUSB_INTERFACE -DDRAG_N_DROP_SUPPORT -DDAPLINK_IF -DDAPLINK_BUILD_KEY=0x9B939E8F -DOS_TICK=10000 -DINTERFACE_STM32F103XB -DUSE_HAL_DRIVER -DSTM32F103xB -DDAPLINK_HIC_ID=0x97969908 -D__packed=__packed -DDAPLINK_NO_ASSERT_FILENAMES -DOS_CLOCK=72000000 -DBULK_ENDPOINT --omf_browse=.\build\vfs_manager.crf ..\..\..\source\daplink\drag-n-drop\vfs_manager.c]
                          THUMB

                          AREA ||i.build_filesystem||, CODE, READONLY, ALIGN=2

                  build_filesystem PROC
;;;379    
;;;380    static void build_filesystem()
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382        // Update anything that could have changed file system state
;;;383        file_transfer_state = default_transfer_state;
000002  2228              MOVS     r2,#0x28
000004  490d              LDR      r1,|L1.60|
000006  480e              LDR      r0,|L1.64|
000008  f7fffffe          BL       __aeabi_memcpy4
;;;384        vfs_user_build_filesystem();
00000c  f7fffffe          BL       vfs_user_build_filesystem
;;;385        vfs_set_file_change_callback(file_change_handler);
000010  480c              LDR      r0,|L1.68|
000012  f7fffffe          BL       vfs_set_file_change_callback
;;;386        // Set mass storage parameters
;;;387        USBD_MSC_MemorySize = vfs_get_total_size();
000016  f7fffffe          BL       vfs_get_total_size
00001a  490b              LDR      r1,|L1.72|
;;;388        USBD_MSC_BlockSize  = VFS_SECTOR_SIZE;
00001c  4a0b              LDR      r2,|L1.76|
;;;389        USBD_MSC_BlockGroup = 1;
00001e  4b0c              LDR      r3,|L1.80|
000020  6008              STR      r0,[r1,#0]            ;388  ; USBD_MSC_MemorySize
000022  f44f7100          MOV      r1,#0x200             ;388
;;;390        USBD_MSC_BlockCount = USBD_MSC_MemorySize / USBD_MSC_BlockSize;
000026  fbb0f0f1          UDIV     r0,r0,r1
00002a  6011              STR      r1,[r2,#0]            ;389  ; USBD_MSC_BlockSize
00002c  4909              LDR      r1,|L1.84|
00002e  2201              MOVS     r2,#1                 ;389
000030  601a              STR      r2,[r3,#0]  ; USBD_MSC_BlockGroup
;;;391        USBD_MSC_BlockBuf   = (uint8_t *)usb_buffer;
000032  6008              STR      r0,[r1,#0]  ; USBD_MSC_BlockCount
000034  4909              LDR      r1,|L1.92|
000036  4808              LDR      r0,|L1.88|
000038  6008              STR      r0,[r1,#0]  ; USBD_MSC_BlockBuf
;;;392    }
00003a  bd10              POP      {r4,pc}
;;;393    
                          ENDP

                  |L1.60|
                          DCD      ||.constdata||
                  |L1.64|
                          DCD      ||.bss||+0x200
                  |L1.68|
                          DCD      file_change_handler
                  |L1.72|
                          DCD      USBD_MSC_MemorySize
                  |L1.76|
                          DCD      USBD_MSC_BlockSize
                  |L1.80|
                          DCD      USBD_MSC_BlockGroup
                  |L1.84|
                          DCD      USBD_MSC_BlockCount
                  |L1.88|
                          DCD      ||.bss||
                  |L1.92|
                          DCD      USBD_MSC_BlockBuf

                          AREA ||i.changing_state||, CODE, READONLY, ALIGN=2

                  changing_state PROC
;;;374    
;;;375    static bool changing_state()
000000  4804              LDR      r0,|L2.20|
;;;376    {
;;;377        return vfs_state != vfs_state_next;
000002  7841              LDRB     r1,[r0,#1]  ; vfs_state
000004  7880              LDRB     r0,[r0,#2]  ; vfs_state_next
000006  4281              CMP      r1,r0
000008  d001              BEQ      |L2.14|
00000a  2001              MOVS     r0,#1
;;;378    }
00000c  4770              BX       lr
                  |L2.14|
00000e  2000              MOVS     r0,#0                 ;377
000010  4770              BX       lr
;;;379    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.file_change_handler||, CODE, READONLY, ALIGN=2

                  file_change_handler PROC
;;;394    // Callback to handle changes to the root directory.  Should be used with vfs_set_file_change_callback
;;;395    static void file_change_handler(const vfs_filename_t filename, vfs_file_change_t change, vfs_file_t file, vfs_file_t new_file_data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;396    {
000004  461e              MOV      r6,r3
000006  4615              MOV      r5,r2
000008  460c              MOV      r4,r1
00000a  4607              MOV      r7,r0
;;;397        vfs_mngr_printf("vfs_manager file_change_handler(name=%*s, file=%p, change=%i)\r\n", 11, filename, file, change);
;;;398        vfs_user_file_change_handler(filename, change, file, new_file_data);
00000c  f7fffffe          BL       vfs_user_file_change_handler
;;;399        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000010  482c              LDR      r0,|L3.196|
000012  f8901020          LDRB     r1,[r0,#0x20]  ; file_transfer_state
000016  2903              CMP      r1,#3
000018  d00f              BEQ      |L3.58|
;;;400            // If the transfer is finished stop further processing
;;;401            return;
;;;402        }
;;;403    
;;;404        if (VFS_FILE_CHANGED == change) {
00001a  2c02              CMP      r4,#2
00001c  d00f              BEQ      |L3.62|
;;;405            if (file == file_transfer_state.file_to_program) {
;;;406                stream_type_t stream;
;;;407                uint32_t size = vfs_file_get_size(new_file_data);
;;;408                vfs_sector_t sector = vfs_file_get_start_sector(new_file_data);
;;;409                stream = stream_type_from_name(filename);
;;;410                transfer_update_file_info(file, sector, size, stream);
;;;411            }
;;;412        }
;;;413    
;;;414        if (VFS_FILE_CREATED == change) {
00001e  b304              CBZ      r4,|L3.98|
;;;415            stream_type_t stream;
;;;416    
;;;417            if (STREAM_TYPE_NONE != stream_type_from_name(filename)) {
;;;418                // Check for a know file extension to detect the current file being
;;;419                // transferred.  Ignore hidden files since MAC uses hidden files with
;;;420                // the same extension to keep track of transfer info in some cases.
;;;421                if (!(VFS_FILE_ATTR_HIDDEN & vfs_file_get_attr(new_file_data))) {
;;;422                    stream = stream_type_from_name(filename);
;;;423                    uint32_t size = vfs_file_get_size(new_file_data);
;;;424                    vfs_sector_t sector = vfs_file_get_start_sector(new_file_data);
;;;425                    transfer_update_file_info(file, sector, size, stream);
;;;426                }
;;;427            }
;;;428        }
;;;429    
;;;430        if (VFS_FILE_DELETED == change) {
000020  2c01              CMP      r4,#1
000022  d10a              BNE      |L3.58|
;;;431            if (file == file_transfer_state.file_to_program) {
000024  6801              LDR      r1,[r0,#0]  ; file_transfer_state
000026  42a9              CMP      r1,r5
000028  d107              BNE      |L3.58|
00002a  f8901022          LDRB     r1,[r0,#0x22]  ; file_transfer_state
00002e  b3a9              CBZ      r1,|L3.156|
000030  2100              MOVS     r1,#0
000032  1e4a              SUBS     r2,r1,#1
000034  6001              STR      r1,[r0,#0]  ; file_transfer_state
000036  6082              STR      r2,[r0,#8]  ; file_transfer_state
000038  6181              STR      r1,[r0,#0x18]  ; file_transfer_state
                  |L3.58|
;;;432                // The file that was being transferred has been deleted
;;;433                transfer_reset_file_info();
;;;434            }
;;;435        }
;;;436    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L3.62|
00003e  6800              LDR      r0,[r0,#0]            ;405  ; file_transfer_state
000040  42a8              CMP      r0,r5                 ;405
000042  d1fa              BNE      |L3.58|
000044  4630              MOV      r0,r6                 ;407
000046  f7fffffe          BL       vfs_file_get_size
00004a  4604              MOV      r4,r0                 ;407
00004c  4630              MOV      r0,r6                 ;408
00004e  f7fffffe          BL       vfs_file_get_start_sector
000052  4606              MOV      r6,r0                 ;408
000054  4638              MOV      r0,r7                 ;409
000056  f7fffffe          BL       stream_type_from_name
00005a  4603              MOV      r3,r0                 ;409
00005c  4622              MOV      r2,r4                 ;410
00005e  4631              MOV      r1,r6                 ;410
000060  e017              B        |L3.146|
                  |L3.98|
000062  4638              MOV      r0,r7                 ;417
000064  f7fffffe          BL       stream_type_from_name
000068  2803              CMP      r0,#3                 ;417
00006a  d0e6              BEQ      |L3.58|
00006c  4630              MOV      r0,r6                 ;421
00006e  f7fffffe          BL       vfs_file_get_attr
000072  0780              LSLS     r0,r0,#30             ;421
000074  d4e1              BMI      |L3.58|
000076  4638              MOV      r0,r7                 ;422
000078  f7fffffe          BL       stream_type_from_name
00007c  4607              MOV      r7,r0                 ;422
00007e  4630              MOV      r0,r6                 ;423
000080  f7fffffe          BL       vfs_file_get_size
000084  4604              MOV      r4,r0                 ;423
000086  4630              MOV      r0,r6                 ;424
000088  f7fffffe          BL       vfs_file_get_start_sector
00008c  4601              MOV      r1,r0                 ;424
00008e  463b              MOV      r3,r7                 ;425
000090  4622              MOV      r2,r4                 ;425
                  |L3.146|
000092  4628              MOV      r0,r5                 ;425
000094  e8bd41f0          POP      {r4-r8,lr}            ;425
000098  f7ffbffe          B.W      transfer_update_file_info
                  |L3.156|
00009c  2228              MOVS     r2,#0x28              ;425
00009e  490a              LDR      r1,|L3.200|
0000a0  4808              LDR      r0,|L3.196|
0000a2  f7fffffe          BL       __aeabi_memcpy4
0000a6  f7fffffe          BL       sync_lock
0000aa  4808              LDR      r0,|L3.204|
0000ac  7881              LDRB     r1,[r0,#2]            ;425  ; vfs_state_next
0000ae  2901              CMP      r1,#1                 ;425
0000b0  d103              BNE      |L3.186|
0000b2  7841              LDRB     r1,[r0,#1]            ;425  ; vfs_state
0000b4  2902              CMP      r1,#2                 ;425
0000b6  d100              BNE      |L3.186|
0000b8  7081              STRB     r1,[r0,#2]            ;425
                  |L3.186|
0000ba  e8bd41f0          POP      {r4-r8,lr}            ;425
0000be  f7ffbffe          B.W      sync_unlock
;;;437    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ||.bss||+0x200
                  |L3.200|
                          DCD      ||.constdata||
                  |L3.204|
                          DCD      ||.data||

                          AREA ||i.file_data_handler||, CODE, READONLY, ALIGN=2

                  file_data_handler PROC
;;;439    // for detecting the start of a BIN/HEX file and performing programming
;;;440    static void file_data_handler(uint32_t sector, const uint8_t *buf, uint32_t num_of_sectors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;441    {
;;;442        stream_type_t stream;
;;;443        uint32_t size;
;;;444    
;;;445        // this is the key for starting a file write - we dont care what file types are sent
;;;446        //  just look for something unique (NVIC table, hex, srec, etc) until root dir is updated
;;;447        if (!file_transfer_state.stream_started) {
000004  4e1d              LDR      r6,|L4.124|
000006  4604              MOV      r4,r0                 ;441
000008  4617              MOV      r7,r2                 ;441
00000a  f8960022          LDRB     r0,[r6,#0x22]  ; file_transfer_state
00000e  4688              MOV      r8,r1                 ;441
;;;448            // look for file types we can program
;;;449            stream = stream_start_identify((uint8_t *)buf, VFS_SECTOR_SIZE * num_of_sectors);
000010  0255              LSLS     r5,r2,#9
000012  b960              CBNZ     r0,|L4.46|
000014  4629              MOV      r1,r5                 ;441
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       stream_start_identify
;;;450    
;;;451            if (STREAM_TYPE_NONE != stream) {
00001c  2803              CMP      r0,#3
00001e  d002              BEQ      |L4.38|
;;;452                transfer_stream_open(stream, sector);
000020  4621              MOV      r1,r4
000022  f7fffffe          BL       transfer_stream_open
                  |L4.38|
;;;453            }
;;;454        }
;;;455    
;;;456        if (file_transfer_state.stream_started) {
000026  f8960022          LDRB     r0,[r6,#0x22]  ; file_transfer_state
00002a  2800              CMP      r0,#0
00002c  d00f              BEQ      |L4.78|
                  |L4.46|
;;;457            // Ignore sectors coming before this file
;;;458            if (sector < file_transfer_state.start_sector) {
00002e  6870              LDR      r0,[r6,#4]  ; file_transfer_state
000030  42a0              CMP      r0,r4
000032  d80c              BHI      |L4.78|
;;;459                return;
;;;460            }
;;;461    
;;;462            // sectors must be in order
;;;463            if (sector != file_transfer_state.file_next_sector) {
000034  68f0              LDR      r0,[r6,#0xc]  ; file_transfer_state
000036  42a0              CMP      r0,r4
000038  d00b              BEQ      |L4.82|
;;;464                vfs_mngr_printf("vfs_manager file_data_handler sector=%i\r\n", sector);
;;;465    
;;;466                if (sector < file_transfer_state.file_next_sector) {
00003a  d908              BLS      |L4.78|
;;;467                    vfs_mngr_printf("    sector out of order! lowest ooo = %i\r\n",
;;;468                                    file_transfer_state.last_ooo_sector);
;;;469    
;;;470                    if (VFS_INVALID_SECTOR == file_transfer_state.last_ooo_sector) {
00003c  6930              LDR      r0,[r6,#0x10]  ; file_transfer_state
00003e  1c40              ADDS     r0,r0,#1
000040  d100              BNE      |L4.68|
;;;471                        file_transfer_state.last_ooo_sector = sector;
000042  6134              STR      r4,[r6,#0x10]  ; file_transfer_state
                  |L4.68|
;;;472                    }
;;;473    
;;;474                    file_transfer_state.last_ooo_sector =
000044  6930              LDR      r0,[r6,#0x10]  ; file_transfer_state
000046  42a0              CMP      r0,r4
000048  d200              BCS      |L4.76|
;;;475                        MIN(file_transfer_state.last_ooo_sector, sector);
00004a  4604              MOV      r4,r0
                  |L4.76|
00004c  6134              STR      r4,[r6,#0x10]  ; file_transfer_state
                  |L4.78|
;;;476                } else {
;;;477                    vfs_mngr_printf("    sector not part of file transfer\r\n");
;;;478                }
;;;479    
;;;480                vfs_mngr_printf("    discarding data - size transferred=0x%x, data=%x,%x,%x,%x,...\r\n",
;;;481                                file_transfer_state.size_transferred, buf[0], buf[1], buf[2], buf[3]);
;;;482                return;
;;;483            }
;;;484    
;;;485            // This sector could be part of the file so record it
;;;486            size = VFS_SECTOR_SIZE * num_of_sectors;
;;;487            file_transfer_state.size_transferred += size;
;;;488            file_transfer_state.file_next_sector = sector + num_of_sectors;
;;;489    
;;;490            // If stream processing is done then discard the data
;;;491            if (file_transfer_state.stream_finished) {
;;;492                vfs_mngr_printf("vfs_manager file_data_handler\r\n    sector=%i, size=%i\r\n", sector, size);
;;;493                vfs_mngr_printf("    discarding data - size transferred=0x%x, data=%x,%x,%x,%x,...\r\n",
;;;494                                file_transfer_state.size_transferred, buf[0], buf[1], buf[2], buf[3]);
;;;495                transfer_update_state(ERROR_SUCCESS);
;;;496                return;
;;;497            }
;;;498    
;;;499            transfer_stream_data(sector, buf, size);
;;;500        }
;;;501    }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.82|
000052  69f0              LDR      r0,[r6,#0x1c]         ;487  ; file_transfer_state
000054  462a              MOV      r2,r5
000056  4410              ADD      r0,r0,r2              ;487
000058  61f0              STR      r0,[r6,#0x1c]         ;488  ; file_transfer_state
00005a  19e0              ADDS     r0,r4,r7              ;488
00005c  60f0              STR      r0,[r6,#0xc]          ;491  ; file_transfer_state
00005e  f8960023          LDRB     r0,[r6,#0x23]         ;491  ; file_transfer_state
000062  b120              CBZ      r0,|L4.110|
000064  e8bd41f0          POP      {r4-r8,lr}            ;495
000068  2000              MOVS     r0,#0                 ;495
00006a  f7ffbffe          B.W      transfer_update_state
                  |L4.110|
00006e  4641              MOV      r1,r8                 ;499
000070  4620              MOV      r0,r4                 ;499
000072  e8bd41f0          POP      {r4-r8,lr}            ;499
000076  f7ffbffe          B.W      transfer_stream_data
;;;502    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      ||.bss||+0x200

                          AREA ||i.ready_for_state_change||, CODE, READONLY, ALIGN=2

                  ready_for_state_change PROC
;;;502    
;;;503    static bool ready_for_state_change(void)
000000  b570              PUSH     {r4-r6,lr}
;;;504    {
;;;505        uint32_t timeout_ms = INVALID_TIMEOUT_MS;
;;;506        util_assert(vfs_state != vfs_state_next);
000002  4d24              LDR      r5,|L5.148|
000004  f04f34ff          MOV      r4,#0xffffffff        ;505
000008  7868              LDRB     r0,[r5,#1]  ; vfs_state
00000a  78a9              LDRB     r1,[r5,#2]  ; vfs_state_next
00000c  4288              CMP      r0,r1
00000e  d001              BEQ      |L5.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L5.22|
                  |L5.20|
000014  2000              MOVS     r0,#0
                  |L5.22|
000016  f44f72fd          MOV      r2,#0x1fa
00001a  a11f              ADR      r1,|L5.152|
00001c  f7fffffe          BL       _util_assert
;;;507    
;;;508        if (VFS_MNGR_STATE_CONNECTED == vfs_state) {
000020  7868              LDRB     r0,[r5,#1]  ; vfs_state
000022  2802              CMP      r0,#2
000024  d003              BEQ      |L5.46|
;;;509            switch (file_transfer_state.transfer_state) {
;;;510                case TRANSFER_NOT_STARTED:
;;;511                case TRASNFER_FINISHED:
;;;512                    timeout_ms = DISCONNECT_DELAY_MS;
;;;513                    break;
;;;514    
;;;515                case TRANSFER_IN_PROGRESS:
;;;516                    timeout_ms = DISCONNECT_DELAY_TRANSFER_TIMEOUT_MS;
;;;517                    break;
;;;518    
;;;519                case TRANSFER_CAN_BE_FINISHED:
;;;520                    timeout_ms = DISCONNECT_DELAY_TRANSFER_IDLE_MS;
;;;521                    break;
;;;522    
;;;523                default:
;;;524                    util_assert(0);
;;;525                    timeout_ms = DISCONNECT_DELAY_MS;
;;;526                    break;
;;;527            }
;;;528        } else if ((VFS_MNGR_STATE_DISCONNECTED == vfs_state) &&
000026  b1c0              CBZ      r0,|L5.90|
;;;529                   (VFS_MNGR_STATE_CONNECTED == vfs_state_next)) {
;;;530            timeout_ms = CONNECT_DELAY_MS;
;;;531        } else if ((VFS_MNGR_STATE_RECONNECTING == vfs_state) &&
000028  2801              CMP      r0,#1
00002a  d01a              BEQ      |L5.98|
00002c  e022              B        |L5.116|
                  |L5.46|
00002e  4827              LDR      r0,|L5.204|
000030  f44f74fa          MOV      r4,#0x1f4             ;512
000034  f8900020          LDRB     r0,[r0,#0x20]         ;509  ; file_transfer_state
000038  b1e0              CBZ      r0,|L5.116|
00003a  2801              CMP      r0,#1                 ;509
00003c  d00a              BEQ      |L5.84|
00003e  2802              CMP      r0,#2                 ;509
000040  d018              BEQ      |L5.116|
000042  2803              CMP      r0,#3                 ;509
000044  d016              BEQ      |L5.116|
000046  f44f7203          MOV      r2,#0x20c             ;524
00004a  a113              ADR      r1,|L5.152|
00004c  2000              MOVS     r0,#0                 ;524
00004e  f7fffffe          BL       _util_assert
000052  e00f              B        |L5.116|
                  |L5.84|
000054  f6446420          MOV      r4,#0x4e20            ;516
000058  e00c              B        |L5.116|
                  |L5.90|
00005a  78a8              LDRB     r0,[r5,#2]            ;529  ; vfs_state_next
00005c  2802              CMP      r0,#2                 ;529
00005e  d008              BEQ      |L5.114|
000060  e008              B        |L5.116|
                  |L5.98|
;;;532                   (VFS_MNGR_STATE_CONNECTED == vfs_state_next)) {
000062  78a8              LDRB     r0,[r5,#2]  ; vfs_state_next
000064  2802              CMP      r0,#2
000066  d001              BEQ      |L5.108|
;;;533            timeout_ms = RECONNECT_DELAY_MS;
;;;534        } else if ((VFS_MNGR_STATE_RECONNECTING == vfs_state) &&
;;;535                   (VFS_MNGR_STATE_DISCONNECTED == vfs_state_next)) {
000068  b118              CBZ      r0,|L5.114|
00006a  e003              B        |L5.116|
                  |L5.108|
00006c  f64014c4          MOV      r4,#0x9c4             ;533
000070  e000              B        |L5.116|
                  |L5.114|
;;;536            timeout_ms = 0;
000072  2400              MOVS     r4,#0
                  |L5.116|
;;;537        }
;;;538    
;;;539        if (INVALID_TIMEOUT_MS == timeout_ms) {
000074  1c60              ADDS     r0,r4,#1
000076  d105              BNE      |L5.132|
;;;540            util_assert(0);
000078  f44f7207          MOV      r2,#0x21c
00007c  a106              ADR      r1,|L5.152|
00007e  f7fffffe          BL       _util_assert
;;;541            timeout_ms = 0;
000082  2400              MOVS     r4,#0
                  |L5.132|
;;;542        }
;;;543    
;;;544        return time_usb_idle > timeout_ms ? true : false;
000084  68a8              LDR      r0,[r5,#8]  ; time_usb_idle
000086  42a0              CMP      r0,r4
000088  d901              BLS      |L5.142|
00008a  2001              MOVS     r0,#1
;;;545    }
00008c  bd70              POP      {r4-r6,pc}
                  |L5.142|
00008e  2000              MOVS     r0,#0                 ;544
000090  bd70              POP      {r4-r6,pc}
;;;546    
                          ENDP

000092  0000              DCW      0x0000
                  |L5.148|
                          DCD      ||.data||
                  |L5.152|
000098  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00009c  2e5c2e2e
0000a0  5c736f75
0000a4  7263655c
0000a8  6461706c
0000ac  696e6b5c
0000b0  64726167
0000b4  2d6e2d64
0000b8  726f705c
0000bc  7666735f
0000c0  6d616e61
0000c4  6765722e
0000c8  63      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L5.204|
                          DCD      ||.bss||+0x200

                          AREA ||i.sync_assert_usb_thread||, CODE, READONLY, ALIGN=2

                  sync_assert_usb_thread PROC
;;;359    
;;;360    static void sync_assert_usb_thread(void)
000000  b510              PUSH     {r4,lr}
;;;361    {
;;;362        util_assert(osThreadGetId() == sync_thread);
000002  f7fffffe          BL       osThreadGetId
000006  4907              LDR      r1,|L6.36|
000008  6849              LDR      r1,[r1,#4]  ; sync_thread
00000a  4288              CMP      r0,r1
00000c  d101              BNE      |L6.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L6.20|
                  |L6.18|
000012  2000              MOVS     r0,#0
                  |L6.20|
000014  e8bd4010          POP      {r4,lr}
000018  f44f72b5          MOV      r2,#0x16a
00001c  a102              ADR      r1,|L6.40|
00001e  f7ffbffe          B.W      _util_assert
;;;363    }
;;;364    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      ||.data||
                  |L6.40|
000028  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00002c  2e5c2e2e
000030  5c736f75
000034  7263655c
000038  6461706c
00003c  696e6b5c
000040  64726167
000044  2d6e2d64
000048  726f705c
00004c  7666735f
000050  6d616e61
000054  6765722e
000058  63      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.sync_lock||, CODE, READONLY, ALIGN=2

                  sync_lock PROC
;;;364    
;;;365    static void sync_lock(void)
000000  4802              LDR      r0,|L7.12|
;;;366    {
;;;367        osMutexAcquire(sync_mutex, 0);
000002  2100              MOVS     r1,#0
000004  68c0              LDR      r0,[r0,#0xc]  ; sync_mutex
000006  f7ffbffe          B.W      osMutexAcquire
;;;368    }
;;;369    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.sync_unlock||, CODE, READONLY, ALIGN=2

                  sync_unlock PROC
;;;369    
;;;370    static void sync_unlock(void)
000000  4801              LDR      r0,|L8.8|
;;;371    {
;;;372        osMutexRelease(sync_mutex);
000002  68c0              LDR      r0,[r0,#0xc]  ; sync_mutex
000004  f7ffbffe          B.W      osMutexRelease
;;;373    }
;;;374    
                          ENDP

                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.transfer_stream_data||, CODE, READONLY, ALIGN=2

                  transfer_stream_data PROC
;;;696    // Update the tranfer state with new information
;;;697    static void transfer_stream_data(uint32_t sector, const uint8_t *data, uint32_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;698    {
;;;699        error_t status;
;;;700        vfs_mngr_printf("vfs_manager transfer_stream_data(sector=%i, size=%i)\r\n", sector, size);
;;;701        vfs_mngr_printf("    size processed=0x%x, data=%x,%x,%x,%x,...\r\n",
;;;702                        file_transfer_state.size_processed, data[0], data[1], data[2], data[3]);
;;;703    
;;;704        if (file_transfer_state.stream_finished) {
000004  4c1e              LDR      r4,|L9.128|
000006  4615              MOV      r5,r2                 ;698
000008  460e              MOV      r6,r1                 ;698
00000a  f8940023          LDRB     r0,[r4,#0x23]  ; file_transfer_state
00000e  b138              CBZ      r0,|L9.32|
;;;705            util_assert(0);
000010  e8bd41f0          POP      {r4-r8,lr}
000014  f24022c1          MOV      r2,#0x2c1
000018  a11a              ADR      r1,|L9.132|
00001a  2000              MOVS     r0,#0
00001c  f7ffbffe          B.W      _util_assert
                  |L9.32|
;;;706            return;
;;;707        }
;;;708    
;;;709        util_assert(size % VFS_SECTOR_SIZE == 0);
000020  05e8              LSLS     r0,r5,#23
000022  d01f              BEQ      |L9.100|
000024  2000              MOVS     r0,#0
                  |L9.38|
000026  f24022c5          MOV      r2,#0x2c5
00002a  a116              ADR      r1,|L9.132|
00002c  f7fffffe          BL       _util_assert
;;;710        util_assert(file_transfer_state.stream_open);
000030  f8940021          LDRB     r0,[r4,#0x21]  ; file_transfer_state
000034  f24022c6          MOV      r2,#0x2c6
000038  a112              ADR      r1,|L9.132|
00003a  f7fffffe          BL       _util_assert
;;;711        status = stream_write((uint8_t *)data, size);
00003e  4629              MOV      r1,r5
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       stream_write
000046  2700              MOVS     r7,#0
000048  2601              MOVS     r6,#1                 ;709
;;;712        vfs_mngr_printf("    stream_write ret=%i\r\n", status);
;;;713    
;;;714        if (ERROR_SUCCESS_DONE == status) {
00004a  2813              CMP      r0,#0x13
00004c  d00c              BEQ      |L9.104|
;;;715            // Override status so ERROR_SUCCESS_DONE
;;;716            // does not get passed into transfer_update_state
;;;717            status = stream_close();
;;;718            vfs_mngr_printf("    stream_close ret=%i\r\n", status);
;;;719            file_transfer_state.stream_open = false;
;;;720            file_transfer_state.stream_finished = true;
;;;721            file_transfer_state.stream_optional_finish = true;
;;;722        } else if (ERROR_SUCCESS_DONE_OR_CONTINUE == status) {
00004e  2814              CMP      r0,#0x14
000050  d011              BEQ      |L9.118|
;;;723            status = ERROR_SUCCESS;
;;;724            file_transfer_state.stream_optional_finish = true;
;;;725        } else {
;;;726            file_transfer_state.stream_optional_finish = false;
000052  f8847024          STRB     r7,[r4,#0x24]
                  |L9.86|
;;;727        }
;;;728    
;;;729        file_transfer_state.size_processed += size;
000056  6961              LDR      r1,[r4,#0x14]  ; file_transfer_state
000058  4429              ADD      r1,r1,r5
;;;730        transfer_update_state(status);
00005a  6161              STR      r1,[r4,#0x14]  ; file_transfer_state
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  f7ffbffe          B.W      transfer_update_state
                  |L9.100|
000064  2001              MOVS     r0,#1                 ;709
000066  e7de              B        |L9.38|
                  |L9.104|
000068  f7fffffe          BL       stream_close
00006c  f8847021          STRB     r7,[r4,#0x21]         ;719
000070  f8846023          STRB     r6,[r4,#0x23]         ;720
000074  e000              B        |L9.120|
                  |L9.118|
000076  2000              MOVS     r0,#0                 ;723
                  |L9.120|
000078  f8846024          STRB     r6,[r4,#0x24]         ;724
00007c  e7eb              B        |L9.86|
;;;731    }
;;;732    
                          ENDP

00007e  0000              DCW      0x0000
                  |L9.128|
                          DCD      ||.bss||+0x200
                  |L9.132|
000084  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
000088  2e5c2e2e
00008c  5c736f75
000090  7263655c
000094  6461706c
000098  696e6b5c
00009c  64726167
0000a0  2d6e2d64
0000a4  726f705c
0000a8  7666735f
0000ac  6d616e61
0000b0  6765722e
0000b4  63      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.transfer_stream_open||, CODE, READONLY, ALIGN=2

                  transfer_stream_open PROC
;;;642    // Update the tranfer state with new information
;;;643    static void transfer_stream_open(stream_type_t stream, uint32_t start_sector)
000000  b570              PUSH     {r4-r6,lr}
;;;644    {
;;;645        error_t status;
;;;646        util_assert(!file_transfer_state.stream_open);
000002  4d1c              LDR      r5,|L10.116|
000004  4606              MOV      r6,r0                 ;644
000006  460c              MOV      r4,r1                 ;644
000008  f8950021          LDRB     r0,[r5,#0x21]  ; file_transfer_state
00000c  2800              CMP      r0,#0
00000e  d011              BEQ      |L10.52|
000010  2000              MOVS     r0,#0
                  |L10.18|
000012  f2402286          MOV      r2,#0x286
000016  a118              ADR      r1,|L10.120|
000018  f7fffffe          BL       _util_assert
;;;647        util_assert(start_sector != VFS_INVALID_SECTOR);
00001c  1c60              ADDS     r0,r4,#1
00001e  d000              BEQ      |L10.34|
000020  2001              MOVS     r0,#1
                  |L10.34|
000022  f2402287          MOV      r2,#0x287
000026  a114              ADR      r1,|L10.120|
000028  f7fffffe          BL       _util_assert
;;;648        vfs_mngr_printf("vfs_manager transfer_update_stream_open(stream=%i, start_sector=%i)\r\n",
;;;649                        stream, start_sector);
;;;650    
;;;651        // Initialize the starting sector if it has not been set
;;;652        if (VFS_INVALID_SECTOR == file_transfer_state.start_sector) {
00002c  6868              LDR      r0,[r5,#4]  ; file_transfer_state
00002e  1c40              ADDS     r0,r0,#1
000030  d002              BEQ      |L10.56|
000032  e002              B        |L10.58|
                  |L10.52|
000034  2001              MOVS     r0,#1                 ;646
000036  e7ec              B        |L10.18|
                  |L10.56|
;;;653            file_transfer_state.start_sector = start_sector;
000038  606c              STR      r4,[r5,#4]  ; file_transfer_state
                  |L10.58|
;;;654    
;;;655            if (start_sector != VFS_INVALID_SECTOR) {
;;;656                vfs_mngr_printf("    start_sector=%i\r\n", start_sector);
;;;657            }
;;;658        }
;;;659    
;;;660        // Initialize the stream if it has not been set
;;;661        if (STREAM_TYPE_NONE == file_transfer_state.stream) {
00003a  f8950027          LDRB     r0,[r5,#0x27]  ; file_transfer_state
00003e  2803              CMP      r0,#3
000040  d101              BNE      |L10.70|
;;;662            file_transfer_state.stream = stream;
000042  f8856027          STRB     r6,[r5,#0x27]
                  |L10.70|
;;;663    
;;;664            if (stream != STREAM_TYPE_NONE) {
;;;665                vfs_mngr_printf("    stream=%i\r\n", stream);
;;;666            }
;;;667        }
;;;668    
;;;669        // Check - Starting sector must be the same
;;;670        if (start_sector != file_transfer_state.start_sector) {
000046  6868              LDR      r0,[r5,#4]  ; file_transfer_state
000048  42a0              CMP      r0,r4
00004a  d103              BNE      |L10.84|
;;;671            vfs_mngr_printf("    error: starting sector changed from %i to %i\r\n", file_transfer_state.start_sector, start_sector);
;;;672            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;673            return;
;;;674        }
;;;675    
;;;676        // Check - stream must be the same
;;;677        if (stream != file_transfer_state.stream) {
00004c  f8950027          LDRB     r0,[r5,#0x27]  ; file_transfer_state
000050  42b0              CMP      r0,r6
000052  d001              BEQ      |L10.88|
                  |L10.84|
000054  2003              MOVS     r0,#3                 ;672
000056  e008              B        |L10.106|
                  |L10.88|
;;;678            vfs_mngr_printf("    error: changed types during transfer from %i to %i\r\n", file_transfer_state.stream, stream);
;;;679            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;680            return;
;;;681        }
;;;682    
;;;683        // Open stream
;;;684        status = stream_open(stream);
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       stream_open
;;;685        vfs_mngr_printf("    stream_open stream=%i ret %i\r\n", stream, status);
;;;686    
;;;687        if (ERROR_SUCCESS == status) {
00005e  b920              CBNZ     r0,|L10.106|
;;;688            file_transfer_state.file_next_sector = start_sector;
000060  f8454f0c          STR      r4,[r5,#0xc]!  ; file_transfer_state
;;;689            file_transfer_state.stream_open = true;
000064  2101              MOVS     r1,#1
000066  7569              STRB     r1,[r5,#0x15]
;;;690            file_transfer_state.stream_started = true;
000068  75a9              STRB     r1,[r5,#0x16]
                  |L10.106|
;;;691        }
;;;692    
;;;693        transfer_update_state(status);
00006a  e8bd4070          POP      {r4-r6,lr}
00006e  f7ffbffe          B.W      transfer_update_state
;;;694    }
;;;695    
                          ENDP

000072  0000              DCW      0x0000
                  |L10.116|
                          DCD      ||.bss||+0x200
                  |L10.120|
000078  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00007c  2e5c2e2e
000080  5c736f75
000084  7263655c
000088  6461706c
00008c  696e6b5c
000090  64726167
000094  2d6e2d64
000098  726f705c
00009c  7666735f
0000a0  6d616e61
0000a4  6765722e
0000a8  63      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.transfer_update_file_info||, CODE, READONLY, ALIGN=2

                  transfer_update_file_info PROC
;;;560    // Update the tranfer state with file information
;;;561    static void transfer_update_file_info(vfs_file_t file, uint32_t start_sector, uint32_t size, stream_type_t stream)
000000  b430              PUSH     {r4,r5}
;;;562    {
;;;563        vfs_mngr_printf("vfs_manager transfer_update_file_info(file=%p, start_sector=%i, size=%i)\r\n", file, start_sector, size);
;;;564    
;;;565        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000002  4c19              LDR      r4,|L11.104|
000004  f8945020          LDRB     r5,[r4,#0x20]  ; file_transfer_state
000008  2d03              CMP      r5,#3
00000a  d002              BEQ      |L11.18|
;;;566            util_assert(0);
;;;567            return;
;;;568        }
;;;569    
;;;570        // Initialize the directory entry if it has not been set
;;;571        if (VFS_FILE_INVALID == file_transfer_state.file_to_program) {
00000c  6825              LDR      r5,[r4,#0]  ; file_transfer_state
00000e  b13d              CBZ      r5,|L11.32|
000010  e007              B        |L11.34|
                  |L11.18|
000012  bc30              POP      {r4,r5}               ;566
000014  f2402236          MOV      r2,#0x236             ;566
000018  a114              ADR      r1,|L11.108|
00001a  2000              MOVS     r0,#0                 ;566
00001c  f7ffbffe          B.W      _util_assert
                  |L11.32|
;;;572            file_transfer_state.file_to_program = file;
000020  6020              STR      r0,[r4,#0]  ; file_transfer_state
                  |L11.34|
;;;573    
;;;574            if (file != VFS_FILE_INVALID) {
;;;575                vfs_mngr_printf("    file_to_program=%p\r\n", file);
;;;576            }
;;;577        }
;;;578    
;;;579        // Initialize the starting sector if it has not been set
;;;580        if (VFS_INVALID_SECTOR == file_transfer_state.file_start_sector) {
000022  68a0              LDR      r0,[r4,#8]  ; file_transfer_state
000024  1c40              ADDS     r0,r0,#1
000026  d100              BNE      |L11.42|
;;;581            file_transfer_state.file_start_sector = start_sector;
000028  60a1              STR      r1,[r4,#8]  ; file_transfer_state
                  |L11.42|
;;;582    
;;;583            if (start_sector != VFS_INVALID_SECTOR) {
;;;584                vfs_mngr_printf("    start_sector=%i\r\n", start_sector);
;;;585            }
;;;586        }
;;;587    
;;;588        // Initialize the stream if it has not been set
;;;589        if (STREAM_TYPE_NONE == file_transfer_state.stream) {
00002a  f8940027          LDRB     r0,[r4,#0x27]  ; file_transfer_state
00002e  2803              CMP      r0,#3
000030  d101              BNE      |L11.54|
;;;590            file_transfer_state.stream = stream;
000032  f8843027          STRB     r3,[r4,#0x27]
                  |L11.54|
;;;591    
;;;592            if (stream != STREAM_TYPE_NONE) {
;;;593                vfs_mngr_printf("    stream=%i\r\n", stream);
;;;594            }
;;;595        }
;;;596    
;;;597        // Check - File size must either grow or be smaller than the size already transferred
;;;598        if ((size < file_transfer_state.file_size) && (size < file_transfer_state.size_transferred) && (size > 0)) {
000036  69a0              LDR      r0,[r4,#0x18]  ; file_transfer_state
000038  4290              CMP      r0,r2
00003a  d905              BLS      |L11.72|
00003c  69e0              LDR      r0,[r4,#0x1c]  ; file_transfer_state
00003e  4290              CMP      r0,r2
000040  d902              BLS      |L11.72|
000042  b10a              CBZ      r2,|L11.72|
                  |L11.68|
;;;599            vfs_mngr_printf("    error: file size changed from %i to %i\r\n", file_transfer_state.file_size, size);
;;;600            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
000044  2003              MOVS     r0,#3
;;;601            return;
000046  e00c              B        |L11.98|
                  |L11.72|
;;;602        }
;;;603    
;;;604        // Check - Starting sector must be the same  - this is optional for file info since it may not be present initially
;;;605        if ((VFS_INVALID_SECTOR != start_sector) && (start_sector != file_transfer_state.file_start_sector)) {
000048  1c48              ADDS     r0,r1,#1
00004a  d002              BEQ      |L11.82|
00004c  68a0              LDR      r0,[r4,#8]  ; file_transfer_state
00004e  4288              CMP      r0,r1
000050  d1f8              BNE      |L11.68|
                  |L11.82|
;;;606            vfs_mngr_printf("    error: starting sector changed from %i to %i\r\n", file_transfer_state.file_start_sector, start_sector);
;;;607            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;608            return;
;;;609        }
;;;610    
;;;611        // Check - stream must be the same
;;;612        if ((stream != STREAM_TYPE_NONE) && (stream != file_transfer_state.stream)) {
000052  2b03              CMP      r3,#3
000054  d003              BEQ      |L11.94|
000056  f8940027          LDRB     r0,[r4,#0x27]  ; file_transfer_state
00005a  4298              CMP      r0,r3
00005c  d1f2              BNE      |L11.68|
                  |L11.94|
;;;613            vfs_mngr_printf("    error: changed types during transfer from %i to %i\r\n", file_transfer_state.stream, stream);
;;;614            transfer_update_state(ERROR_ERROR_DURING_TRANSFER);
;;;615            return;
;;;616        }
;;;617    
;;;618        // Update values - Size is the only value that can change
;;;619        file_transfer_state.file_size = size;
;;;620        vfs_mngr_printf("    updated size=%i\r\n", size);
;;;621    
;;;622        transfer_update_state(ERROR_SUCCESS);
00005e  2000              MOVS     r0,#0
000060  61a2              STR      r2,[r4,#0x18]  ; file_transfer_state
                  |L11.98|
000062  bc30              POP      {r4,r5}
000064  f7ffbffe          B.W      transfer_update_state
;;;623    }
;;;624    
                          ENDP

                  |L11.104|
                          DCD      ||.bss||+0x200
                  |L11.108|
00006c  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
000070  2e5c2e2e
000074  5c736f75
000078  7263655c
00007c  6461706c
000080  696e6b5c
000084  64726167
000088  2d6e2d64
00008c  726f705c
000090  7666735f
000094  6d616e61
000098  6765722e
00009c  63      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.transfer_update_state||, CODE, READONLY, ALIGN=2

                  transfer_update_state PROC
;;;733    // Check if the current transfer is still in progress, done, or if an error has occurred
;;;734    static void transfer_update_state(error_t status)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;735    {
;;;736        bool transfer_timeout;
;;;737        bool transfer_started;
;;;738        bool transfer_can_be_finished;
;;;739        bool transfer_must_be_finished;
;;;740        bool out_of_order_sector;
;;;741        error_t local_status = status;
000004  4604              MOV      r4,r0
;;;742        util_assert((status != ERROR_SUCCESS_DONE) &&
000006  2813              CMP      r0,#0x13
000008  d003              BEQ      |L12.18|
00000a  2c14              CMP      r4,#0x14
00000c  d001              BEQ      |L12.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L12.20|
                  |L12.18|
000012  2000              MOVS     r0,#0
                  |L12.20|
000014  f24022e6          MOV      r2,#0x2e6
000018  a143              ADR      r1,|L12.296|
00001a  f7fffffe          BL       _util_assert
;;;743                    (status != ERROR_SUCCESS_DONE_OR_CONTINUE));
;;;744    
;;;745        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
00001e  4d4f              LDR      r5,|L12.348|
000020  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
000024  2803              CMP      r0,#3
000026  d00c              BEQ      |L12.66|
;;;746            util_assert(0);
;;;747            return;
;;;748        }
;;;749    
;;;750        // Update file info status.  The end of a file is never known for sure since
;;;751        // what looks like a complete file could be part of a file getting flushed to disk.
;;;752        // The criteria for an successful optional finish is
;;;753        // 1. A file has been detected
;;;754        // 2. The size of the file indicated in the root dir has been transferred
;;;755        // 3. The file size is greater than zero
;;;756        // 4. Matching start sector set by stream and vfs changes
;;;757        file_transfer_state.file_info_optional_finish =
000028  6829              LDR      r1,[r5,#0]  ; file_transfer_state
00002a  b191              CBZ      r1,|L12.82|
00002c  e9d50206          LDRD     r0,r2,[r5,#0x18]
;;;758            (file_transfer_state.file_to_program != VFS_FILE_INVALID) &&
;;;759            (file_transfer_state.size_transferred >= file_transfer_state.file_size) &&
000030  4282              CMP      r2,r0
000032  d30e              BCC      |L12.82|
;;;760            (file_transfer_state.file_size > 0) &&
000034  b168              CBZ      r0,|L12.82|
000036  e9d50201          LDRD     r0,r2,[r5,#4]
;;;761            (file_transfer_state.start_sector == file_transfer_state.file_start_sector);
00003a  4290              CMP      r0,r2
00003c  d109              BNE      |L12.82|
00003e  2001              MOVS     r0,#1
000040  e008              B        |L12.84|
                  |L12.66|
000042  e8bd47f0          POP      {r4-r10,lr}           ;746
000046  f24022ea          MOV      r2,#0x2ea             ;746
00004a  a137              ADR      r1,|L12.296|
00004c  2000              MOVS     r0,#0                 ;746
00004e  f7ffbffe          B.W      _util_assert
                  |L12.82|
000052  2000              MOVS     r0,#0
                  |L12.84|
000054  f8850025          STRB     r0,[r5,#0x25]
;;;762        transfer_timeout = file_transfer_state.transfer_timeout;
000058  f8959026          LDRB     r9,[r5,#0x26]  ; file_transfer_state
;;;763        transfer_started = (VFS_FILE_INVALID != file_transfer_state.file_to_program) ||
00005c  b919              CBNZ     r1,|L12.102|
;;;764                           (STREAM_TYPE_NONE != file_transfer_state.stream);
00005e  f8951027          LDRB     r1,[r5,#0x27]  ; file_transfer_state
000062  2903              CMP      r1,#3
000064  d001              BEQ      |L12.106|
                  |L12.102|
000066  2101              MOVS     r1,#1
000068  e000              B        |L12.108|
                  |L12.106|
00006a  2100              MOVS     r1,#0
                  |L12.108|
00006c  4688              MOV      r8,r1
;;;765        // The transfer can be finished if both file and stream processing
;;;766        // can be considered complete
;;;767        transfer_can_be_finished = file_transfer_state.file_info_optional_finish &&
00006e  b120              CBZ      r0,|L12.122|
;;;768                                   file_transfer_state.stream_optional_finish;
000070  f8951024          LDRB     r1,[r5,#0x24]  ; file_transfer_state
000074  b109              CBZ      r1,|L12.122|
000076  2601              MOVS     r6,#1
000078  e000              B        |L12.124|
                  |L12.122|
00007a  2600              MOVS     r6,#0
                  |L12.124|
;;;769        // The transfer must be fnished if stream processing is for sure complete
;;;770        // and file processing can be considered complete
;;;771        transfer_must_be_finished = file_transfer_state.stream_finished &&
00007c  f8951023          LDRB     r1,[r5,#0x23]  ; file_transfer_state
000080  b111              CBZ      r1,|L12.136|
;;;772                                    file_transfer_state.file_info_optional_finish;
000082  b108              CBZ      r0,|L12.136|
000084  2001              MOVS     r0,#1
000086  e000              B        |L12.138|
                  |L12.136|
000088  2000              MOVS     r0,#0
                  |L12.138|
00008a  4682              MOV      r10,r0
;;;773        out_of_order_sector = false;
;;;774    
;;;775        if (file_transfer_state.last_ooo_sector != VFS_INVALID_SECTOR) {
00008c  6928              LDR      r0,[r5,#0x10]  ; file_transfer_state
00008e  2700              MOVS     r7,#0                 ;773
000090  1c40              ADDS     r0,r0,#1
000092  d010              BEQ      |L12.182|
;;;776            util_assert(file_transfer_state.start_sector != VFS_INVALID_SECTOR);
000094  6868              LDR      r0,[r5,#4]  ; file_transfer_state
000096  1c40              ADDS     r0,r0,#1
000098  d000              BEQ      |L12.156|
00009a  2001              MOVS     r0,#1
                  |L12.156|
00009c  f44f7242          MOV      r2,#0x308
0000a0  a121              ADR      r1,|L12.296|
0000a2  f7fffffe          BL       _util_assert
;;;777            uint32_t sector_offset = (file_transfer_state.last_ooo_sector -
0000a6  6869              LDR      r1,[r5,#4]  ; file_transfer_state
0000a8  6928              LDR      r0,[r5,#0x10]  ; file_transfer_state
0000aa  1a40              SUBS     r0,r0,r1
;;;778                                      file_transfer_state.start_sector) * VFS_SECTOR_SIZE;
;;;779    
;;;780            if (sector_offset < file_transfer_state.size_processed) {
0000ac  6969              LDR      r1,[r5,#0x14]  ; file_transfer_state
0000ae  0240              LSLS     r0,r0,#9              ;777
0000b0  4281              CMP      r1,r0
0000b2  d900              BLS      |L12.182|
;;;781                // The out of order sector was within the range of data already
;;;782                // processed.
;;;783                out_of_order_sector = true;
0000b4  2701              MOVS     r7,#1
                  |L12.182|
0000b6  2003              MOVS     r0,#3                 ;745
;;;784            }
;;;785        }
;;;786    
;;;787        // Set the transfer state and set the status if necessary
;;;788        if (local_status != ERROR_SUCCESS) {
0000b8  b114              CBZ      r4,|L12.192|
                  |L12.186|
;;;789            file_transfer_state.transfer_state = TRASNFER_FINISHED;
0000ba  f8850020          STRB     r0,[r5,#0x20]
0000be  e01d              B        |L12.252|
                  |L12.192|
;;;790        } else if (transfer_timeout) {
0000c0  f1b90f00          CMP      r9,#0
0000c4  d009              BEQ      |L12.218|
;;;791            if (out_of_order_sector) {
0000c6  b10f              CBZ      r7,|L12.204|
;;;792                local_status = ERROR_OOO_SECTOR;
0000c8  2406              MOVS     r4,#6
0000ca  e7f6              B        |L12.186|
                  |L12.204|
;;;793            } else if (!transfer_started) {
0000cc  f1b80f00          CMP      r8,#0
0000d0  d0f3              BEQ      |L12.186|
;;;794                local_status = ERROR_SUCCESS;
;;;795            } else if (transfer_can_be_finished) {
0000d2  2e00              CMP      r6,#0
0000d4  d1f1              BNE      |L12.186|
;;;796                local_status = ERROR_SUCCESS;
;;;797            } else {
;;;798                local_status = ERROR_TRANSFER_TIMEOUT;
0000d6  2404              MOVS     r4,#4
0000d8  e7ef              B        |L12.186|
                  |L12.218|
;;;799            }
;;;800    
;;;801            file_transfer_state.transfer_state = TRASNFER_FINISHED;
;;;802        } else if (transfer_must_be_finished) {
0000da  f1ba0f00          CMP      r10,#0
0000de  d1ec              BNE      |L12.186|
;;;803            file_transfer_state.transfer_state = TRASNFER_FINISHED;
;;;804        } else if (transfer_can_be_finished) {
0000e0  b10e              CBZ      r6,|L12.230|
;;;805            file_transfer_state.transfer_state = TRANSFER_CAN_BE_FINISHED;
0000e2  2002              MOVS     r0,#2
0000e4  e003              B        |L12.238|
                  |L12.230|
;;;806        } else if (transfer_started) {
0000e6  f1b80f00          CMP      r8,#0
0000ea  d003              BEQ      |L12.244|
;;;807            file_transfer_state.transfer_state = TRANSFER_IN_PROGRESS;
0000ec  2001              MOVS     r0,#1
                  |L12.238|
0000ee  f8850020          STRB     r0,[r5,#0x20]
0000f2  e012              B        |L12.282|
                  |L12.244|
;;;808        }
;;;809    
;;;810        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
0000f4  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
0000f8  2803              CMP      r0,#3
0000fa  d10b              BNE      |L12.276|
                  |L12.252|
;;;811            vfs_mngr_printf("vfs_manager transfer_update_state(status=%i)\r\n", status);
;;;812            vfs_mngr_printf("    file=%p, start_sect= %i %i, size=%i\r\n",
;;;813                            file_transfer_state.file_to_program, file_transfer_state.start_sector,
;;;814                            file_transfer_state.file_start_sector, file_transfer_state.file_size);
;;;815            vfs_mngr_printf("    stream=%i, size_processed=%i, opt_finish=%i, timeout=%i\r\n",
;;;816                            file_transfer_state.stream, file_transfer_state.size_processed,
;;;817                            file_transfer_state.file_info_optional_finish, transfer_timeout);
;;;818    
;;;819            // Close the file stream if it is open
;;;820            if (file_transfer_state.stream_open) {
0000fc  f8950021          LDRB     r0,[r5,#0x21]  ; file_transfer_state
000100  b130              CBZ      r0,|L12.272|
;;;821                error_t close_status;
;;;822                close_status = stream_close();
000102  f7fffffe          BL       stream_close
;;;823                vfs_mngr_printf("    stream closed ret=%i\r\n", close_status);
;;;824                file_transfer_state.stream_open = false;
000106  2100              MOVS     r1,#0
000108  f8851021          STRB     r1,[r5,#0x21]
;;;825    
;;;826                if (ERROR_SUCCESS == local_status) {
00010c  b904              CBNZ     r4,|L12.272|
;;;827                    local_status = close_status;
00010e  4604              MOV      r4,r0
                  |L12.272|
;;;828                }
;;;829            }
;;;830    
;;;831            // Set the fail reason
;;;832            fail_reason = local_status;
000110  4813              LDR      r0,|L12.352|
000112  7004              STRB     r4,[r0,#0]
                  |L12.276|
;;;833            vfs_mngr_printf("    Transfer finished, status: %i=%s\r\n", fail_reason, error_get_string(fail_reason));
;;;834        }
;;;835    
;;;836        // If this state change is not from aborting a transfer
;;;837        // due to a remount then trigger a remount
;;;838        if (!transfer_timeout) {
000114  f1b90f00          CMP      r9,#0
000118  d103              BNE      |L12.290|
                  |L12.282|
;;;839            vfs_mngr_fs_remount();
00011a  e8bd47f0          POP      {r4-r10,lr}
00011e  f7ffbffe          B.W      vfs_mngr_fs_remount
                  |L12.290|
;;;840        }
;;;841    }
000122  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

000126  0000              DCW      0x0000
                  |L12.296|
000128  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
00012c  2e5c2e2e
000130  5c736f75
000134  7263655c
000138  6461706c
00013c  696e6b5c
000140  64726167
000144  2d6e2d64
000148  726f705c
00014c  7666735f
000150  6d616e61
000154  6765722e
000158  63      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L12.348|
                          DCD      ||.bss||+0x200
                  |L12.352|
                          DCD      ||.data||

                          AREA ||i.usbd_msc_init||, CODE, READONLY, ALIGN=2

                  usbd_msc_init PROC
;;;303    
;;;304    void usbd_msc_init(void)
000000  b510              PUSH     {r4,lr}
000002  f7fffffe          BL       osThreadGetId
000006  4c07              LDR      r4,|L13.36|
000008  6060              STR      r0,[r4,#4]  ; sync_thread
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       osMutexNew
;;;305    {
;;;306        sync_init();
;;;307        build_filesystem();
000010  60e0              STR      r0,[r4,#0xc]  ; sync_mutex
000012  f7fffffe          BL       build_filesystem
;;;308        vfs_state = VFS_MNGR_STATE_DISCONNECTED;
000016  2000              MOVS     r0,#0
000018  7060              STRB     r0,[r4,#1]
;;;309        vfs_state_next = VFS_MNGR_STATE_DISCONNECTED;
;;;310        time_usb_idle = 0;
;;;311        USBD_MSC_MediaReady = 0;
00001a  4903              LDR      r1,|L13.40|
00001c  70a0              STRB     r0,[r4,#2]            ;309
00001e  60a0              STR      r0,[r4,#8]  ; time_usb_idle
000020  6008              STR      r0,[r1,#0]  ; USBD_MSC_MediaReady
;;;312    }
000022  bd10              POP      {r4,pc}
;;;313    
                          ENDP

                  |L13.36|
                          DCD      ||.data||
                  |L13.40|
                          DCD      USBD_MSC_MediaReady

                          AREA ||i.usbd_msc_read_sect||, CODE, READONLY, ALIGN=2

                  usbd_msc_read_sect PROC
;;;313    
;;;314    void usbd_msc_read_sect(uint32_t sector, uint8_t *buf, uint32_t num_of_sectors)
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;316        sync_assert_usb_thread();
000008  f7fffffe          BL       sync_assert_usb_thread
;;;317    
;;;318        // dont proceed if we're not ready
;;;319        if (!USBD_MSC_MediaReady) {
00000c  4b07              LDR      r3,|L14.44|
00000e  6818              LDR      r0,[r3,#0]  ; USBD_MSC_MediaReady
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L14.40|
;;;320            return;
;;;321        }
;;;322    
;;;323        // indicate msc activity
;;;324        main_blink_msc_led(MAIN_LED_FLASH);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       main_blink_msc_led
;;;325        vfs_read(sector, buf, num_of_sectors);
00001a  4622              MOV      r2,r4
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  e8bd4070          POP      {r4-r6,lr}
000024  f7ffbffe          B.W      vfs_read
                  |L14.40|
;;;326    }
000028  bd70              POP      {r4-r6,pc}
;;;327    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      USBD_MSC_MediaReady

                          AREA ||i.usbd_msc_write_sect||, CODE, READONLY, ALIGN=2

                  usbd_msc_write_sect PROC
;;;327    
;;;328    void usbd_msc_write_sect(uint32_t sector, uint8_t *buf, uint32_t num_of_sectors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;329    {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;330        sync_assert_usb_thread();
00000a  f7fffffe          BL       sync_assert_usb_thread
;;;331    
;;;332        if (!USBD_MSC_MediaReady) {
00000e  4810              LDR      r0,|L15.80|
000010  6800              LDR      r0,[r0,#0]  ; USBD_MSC_MediaReady
000012  2800              CMP      r0,#0
000014  d01a              BEQ      |L15.76|
;;;333            return;
;;;334        }
;;;335    
;;;336        // Restart the disconnect counter on every packet
;;;337        // so the device does not detach in the middle of a
;;;338        // transfer.
;;;339        time_usb_idle = 0;
000016  490f              LDR      r1,|L15.84|
;;;340    
;;;341        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000018  4c0f              LDR      r4,|L15.88|
00001a  2000              MOVS     r0,#0                 ;339
00001c  6088              STR      r0,[r1,#8]  ; time_usb_idle
00001e  f8940020          LDRB     r0,[r4,#0x20]  ; file_transfer_state
000022  2803              CMP      r0,#3
000024  d012              BEQ      |L15.76|
;;;342            return;
;;;343        }
;;;344    
;;;345        // indicate msc activity
;;;346        main_blink_msc_led(MAIN_LED_FLASH);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       main_blink_msc_led
;;;347        vfs_write(sector, buf, num_of_sectors);
00002c  462a              MOV      r2,r5
00002e  4631              MOV      r1,r6
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       vfs_write
;;;348        if (TRASNFER_FINISHED == file_transfer_state.transfer_state) {
000036  f8940020          LDRB     r0,[r4,#0x20]  ; file_transfer_state
00003a  2803              CMP      r0,#3
00003c  d006              BEQ      |L15.76|
;;;349            return;
;;;350        }
;;;351        file_data_handler(sector, buf, num_of_sectors);
00003e  462a              MOV      r2,r5
000040  4631              MOV      r1,r6
000042  4638              MOV      r0,r7
000044  e8bd41f0          POP      {r4-r8,lr}
000048  f7ffbffe          B.W      file_data_handler
                  |L15.76|
;;;352    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;353    
                          ENDP

                  |L15.80|
                          DCD      USBD_MSC_MediaReady
                  |L15.84|
                          DCD      ||.data||
                  |L15.88|
                          DCD      ||.bss||+0x200

                          AREA ||i.vfs_mngr_fs_enable||, CODE, READONLY, ALIGN=2

                  vfs_mngr_fs_enable PROC
;;;163    
;;;164    void vfs_mngr_fs_enable(bool enable)
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166        sync_lock();
000004  f7fffffe          BL       sync_lock
;;;167    
;;;168        if (enable) {
;;;169            if (VFS_MNGR_STATE_DISCONNECTED == vfs_state_next) {
000008  4905              LDR      r1,|L16.32|
00000a  b13c              CBZ      r4,|L16.28|
00000c  7888              LDRB     r0,[r1,#2]  ; vfs_state_next
00000e  b908              CBNZ     r0,|L16.20|
;;;170                vfs_state_next = VFS_MNGR_STATE_CONNECTED;
000010  2002              MOVS     r0,#2
                  |L16.18|
000012  7088              STRB     r0,[r1,#2]
                  |L16.20|
;;;171            }
;;;172        } else {
;;;173            vfs_state_next = VFS_MNGR_STATE_DISCONNECTED;
;;;174        }
;;;175    
;;;176        sync_unlock();
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      sync_unlock
                  |L16.28|
00001c  2000              MOVS     r0,#0                 ;173
00001e  e7f8              B        |L16.18|
;;;177    }
;;;178    
                          ENDP

                  |L16.32|
                          DCD      ||.data||

                          AREA ||i.vfs_mngr_fs_remount||, CODE, READONLY, ALIGN=2

                  vfs_mngr_fs_remount PROC
;;;178    
;;;179    void vfs_mngr_fs_remount(void)
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181        sync_lock();
000002  f7fffffe          BL       sync_lock
;;;182    
;;;183        // Only start a remount if in the connected state and not in a transition
;;;184        if (!changing_state() && (VFS_MNGR_STATE_CONNECTED == vfs_state)) {
000006  f7fffffe          BL       changing_state
00000a  b928              CBNZ     r0,|L17.24|
00000c  4804              LDR      r0,|L17.32|
00000e  7841              LDRB     r1,[r0,#1]  ; vfs_state
000010  2902              CMP      r1,#2
000012  d101              BNE      |L17.24|
;;;185            vfs_state_next = VFS_MNGR_STATE_RECONNECTING;
000014  2101              MOVS     r1,#1
000016  7081              STRB     r1,[r0,#2]
                  |L17.24|
;;;186        }
;;;187    
;;;188        sync_unlock();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      sync_unlock
;;;189    }
;;;190    
                          ENDP

                  |L17.32|
                          DCD      ||.data||

                          AREA ||i.vfs_mngr_get_transfer_status||, CODE, READONLY, ALIGN=2

                  vfs_mngr_get_transfer_status PROC
;;;297    
;;;298    error_t vfs_mngr_get_transfer_status()
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300        sync_assert_usb_thread();
000002  f7fffffe          BL       sync_assert_usb_thread
;;;301        return fail_reason;
000006  4801              LDR      r0,|L18.12|
000008  7800              LDRB     r0,[r0,#0]  ; fail_reason
;;;302    }
00000a  bd10              POP      {r4,pc}
;;;303    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.vfs_mngr_init||, CODE, READONLY, ALIGN=2

                  vfs_mngr_init PROC
;;;190    
;;;191    void vfs_mngr_init(bool enable)
000000  b510              PUSH     {r4,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193        sync_assert_usb_thread();
000004  f7fffffe          BL       sync_assert_usb_thread
;;;194        build_filesystem();
000008  f7fffffe          BL       build_filesystem
;;;195    
;;;196        if (enable) {
;;;197            vfs_state = VFS_MNGR_STATE_CONNECTED;
00000c  4906              LDR      r1,|L19.40|
;;;198            vfs_state_next = VFS_MNGR_STATE_CONNECTED;
;;;199            USBD_MSC_MediaReady = 1;
00000e  4a07              LDR      r2,|L19.44|
000010  b124              CBZ      r4,|L19.28|
000012  2002              MOVS     r0,#2                 ;197
000014  7048              STRB     r0,[r1,#1]            ;197
000016  7088              STRB     r0,[r1,#2]            ;198
000018  2001              MOVS     r0,#1
00001a  e002              B        |L19.34|
                  |L19.28|
;;;200        } else {
;;;201            vfs_state = VFS_MNGR_STATE_DISCONNECTED;
00001c  2000              MOVS     r0,#0
00001e  7048              STRB     r0,[r1,#1]
;;;202            vfs_state_next = VFS_MNGR_STATE_DISCONNECTED;
000020  7088              STRB     r0,[r1,#2]
                  |L19.34|
000022  6010              STR      r0,[r2,#0]            ;199  ; USBD_MSC_MediaReady
;;;203            USBD_MSC_MediaReady = 0;
;;;204        }
;;;205    }
000024  bd10              POP      {r4,pc}
;;;206    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      ||.data||
                  |L19.44|
                          DCD      USBD_MSC_MediaReady

                          AREA ||i.vfs_mngr_periodic||, CODE, READONLY, ALIGN=2

                  vfs_mngr_periodic PROC
;;;206    
;;;207    void vfs_mngr_periodic(uint32_t elapsed_ms)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;208    {
000004  4604              MOV      r4,r0
;;;209        bool change_state;
;;;210        vfs_mngr_state_t vfs_state_local;
;;;211        vfs_mngr_state_t vfs_state_local_prev;
;;;212        sync_assert_usb_thread();
000006  f7fffffe          BL       sync_assert_usb_thread
;;;213        sync_lock();
00000a  f7fffffe          BL       sync_lock
;;;214    
;;;215        // Return immediately if the desired state has been reached
;;;216        if (!changing_state()) {
00000e  f7fffffe          BL       changing_state
000012  b180              CBZ      r0,|L20.54|
;;;217            sync_unlock();
;;;218            return;
;;;219        }
;;;220    
;;;221        change_state = ready_for_state_change();
000014  f7fffffe          BL       ready_for_state_change
;;;222    
;;;223        if (time_usb_idle < MAX_EVENT_TIME_MS) {
000018  4a21              LDR      r2,|L20.160|
00001a  f64e2360          MOV      r3,#0xea60
00001e  6891              LDR      r1,[r2,#8]  ; time_usb_idle
000020  4299              CMP      r1,r3
000022  d201              BCS      |L20.40|
;;;224            time_usb_idle += elapsed_ms;
000024  4421              ADD      r1,r1,r4
000026  6091              STR      r1,[r2,#8]  ; time_usb_idle
                  |L20.40|
;;;225        }
;;;226    
;;;227        if (!change_state) {
000028  b128              CBZ      r0,|L20.54|
;;;228            sync_unlock();
;;;229            return;
;;;230        }
;;;231    
;;;232        vfs_mngr_printf("vfs_mngr_periodic()\r\n");
;;;233        vfs_mngr_printf("   time_usb_idle=%i\r\n", time_usb_idle);
;;;234        vfs_mngr_printf("   transfer_state=%i\r\n", file_transfer_state.transfer_state);
;;;235        // Transistion to new state
;;;236        vfs_state_local_prev = vfs_state;
;;;237        vfs_state = vfs_state_next;
00002a  7894              LDRB     r4,[r2,#2]  ; vfs_state_next
00002c  7855              LDRB     r5,[r2,#1]            ;236  ; vfs_state
00002e  7054              STRB     r4,[r2,#1]
;;;238    
;;;239        switch (vfs_state) {
000030  2c01              CMP      r4,#1
000032  d106              BNE      |L20.66|
000034  e003              B        |L20.62|
                  |L20.54|
000036  e8bd41f0          POP      {r4-r8,lr}            ;228
00003a  f7ffbffe          B.W      sync_unlock
                  |L20.62|
;;;240            case VFS_MNGR_STATE_RECONNECTING:
;;;241                // Transition back to the connected state
;;;242                vfs_state_next = VFS_MNGR_STATE_CONNECTED;
00003e  2002              MOVS     r0,#2
000040  7090              STRB     r0,[r2,#2]
                  |L20.66|
;;;243                break;
;;;244    
;;;245            default:
;;;246                // No state change logic required in other states
;;;247                break;
;;;248        }
;;;249    
;;;250        vfs_state_local = vfs_state;
;;;251        time_usb_idle = 0;
000042  2600              MOVS     r6,#0
;;;252        sync_unlock();
000044  6096              STR      r6,[r2,#8]  ; time_usb_idle
000046  f7fffffe          BL       sync_unlock
00004a  2701              MOVS     r7,#1                 ;237
;;;253        // Processing when leaving a state
;;;254        vfs_mngr_printf("    state %i->%i\r\n", vfs_state_local_prev, vfs_state_local);
;;;255    
;;;256        switch (vfs_state_local_prev) {
00004c  b1cd              CBZ      r5,|L20.130|
00004e  2d01              CMP      r5,#1
000050  d017              BEQ      |L20.130|
000052  2d02              CMP      r5,#2
000054  d115              BNE      |L20.130|
;;;257            case VFS_MNGR_STATE_DISCONNECTED:
;;;258                // No action needed
;;;259                break;
;;;260    
;;;261            case VFS_MNGR_STATE_RECONNECTING:
;;;262                // No action needed
;;;263                break;
;;;264    
;;;265            case VFS_MNGR_STATE_CONNECTED:
;;;266    
;;;267                // Close ongoing transfer if there is one
;;;268                if (file_transfer_state.transfer_state != TRASNFER_FINISHED) {
000056  4d13              LDR      r5,|L20.164|
000058  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
00005c  2803              CMP      r0,#3
00005e  d004              BEQ      |L20.106|
;;;269                    vfs_mngr_printf("    transfer timeout\r\n");
;;;270                    file_transfer_state.transfer_timeout = true;
000060  f8857026          STRB     r7,[r5,#0x26]
;;;271                    transfer_update_state(ERROR_SUCCESS);
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       transfer_update_state
                  |L20.106|
;;;272                }
;;;273    
;;;274                util_assert(TRASNFER_FINISHED == file_transfer_state.transfer_state);
00006a  f8950020          LDRB     r0,[r5,#0x20]  ; file_transfer_state
00006e  2803              CMP      r0,#3
000070  d012              BEQ      |L20.152|
000072  2000              MOVS     r0,#0
                  |L20.116|
000074  f44f7289          MOV      r2,#0x112
000078  a10b              ADR      r1,|L20.168|
00007a  f7fffffe          BL       _util_assert
;;;275                vfs_user_disconnecting();
00007e  f7fffffe          BL       vfs_user_disconnecting
                  |L20.130|
;;;276                break;
;;;277        }
;;;278    
;;;279        // Processing when entering a state
;;;280        switch (vfs_state_local) {
;;;281            case VFS_MNGR_STATE_DISCONNECTED:
;;;282                USBD_MSC_MediaReady = 0;
000082  4d16              LDR      r5,|L20.220|
000084  b154              CBZ      r4,|L20.156|
000086  2c01              CMP      r4,#1                 ;280
000088  d008              BEQ      |L20.156|
00008a  2c02              CMP      r4,#2                 ;280
00008c  d102              BNE      |L20.148|
;;;283                break;
;;;284    
;;;285            case VFS_MNGR_STATE_RECONNECTING:
;;;286                USBD_MSC_MediaReady = 0;
;;;287                break;
;;;288    
;;;289            case VFS_MNGR_STATE_CONNECTED:
;;;290                build_filesystem();
00008e  f7fffffe          BL       build_filesystem
;;;291                USBD_MSC_MediaReady = 1;
;;;292                break;
000092  602f              STR      r7,[r5,#0]  ; USBD_MSC_MediaReady
                  |L20.148|
;;;293        }
;;;294    
;;;295        return;
;;;296    }
000094  e8bd81f0          POP      {r4-r8,pc}
                  |L20.152|
000098  2001              MOVS     r0,#1                 ;274
00009a  e7eb              B        |L20.116|
                  |L20.156|
00009c  602e              STR      r6,[r5,#0]            ;286  ; USBD_MSC_MediaReady
00009e  e7f9              B        |L20.148|
;;;297    
                          ENDP

                  |L20.160|
                          DCD      ||.data||
                  |L20.164|
                          DCD      ||.bss||+0x200
                  |L20.168|
0000a8  2e2e5c2e          DCB      "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
0000ac  2e5c2e2e
0000b0  5c736f75
0000b4  7263655c
0000b8  6461706c
0000bc  696e6b5c
0000c0  64726167
0000c4  2d6e2d64
0000c8  726f705c
0000cc  7666735f
0000d0  6d616e61
0000d4  6765722e
0000d8  63      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L20.220|
                          DCD      USBD_MSC_MediaReady

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  usb_buffer
                          %        512
                  file_transfer_state
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  default_transfer_state
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  00000003          DCB      0x00,0x00,0x00,0x03

                          AREA ||.data||, DATA, ALIGN=2

                  fail_reason
000000  00                DCB      0x00
                  vfs_state
000001  00                DCB      0x00
                  vfs_state_next
000002  0000              DCB      0x00,0x00
                  sync_thread
                          DCD      0x00000000
                  time_usb_idle
                          DCD      0x00000000
                  sync_mutex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\source\\daplink\\drag-n-drop\\vfs_manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_vfs_manager_c_bf9123bc____REV16|
#line 129 "..\\..\\..\\source\\cmsis-core\\core_cmInstr.h"
|__asm___13_vfs_manager_c_bf9123bc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_vfs_manager_c_bf9123bc____REVSH|
#line 144
|__asm___13_vfs_manager_c_bf9123bc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
